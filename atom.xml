<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>锦泉^-^</title>
  
  <subtitle>JAVA工程师进阶之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arthurjq.com/"/>
  <updated>2021-03-12T14:08:42.140Z</updated>
  <id>https://arthurjq.com/</id>
  
  <author>
    <name>锦泉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java进阶</title>
    <link href="https://arthurjq.com/2021/03/10/java-advance/"/>
    <id>https://arthurjq.com/2021/03/10/java-advance/</id>
    <published>2021-03-10T11:21:38.000Z</published>
    <updated>2021-03-12T14:08:42.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前或之后额外做一些事情。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>实际上就是个map（key，value），里面存各种对象（在xml里配置的bean节点、@Component、@Controller），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放进map里、扫描到注解的类还是通过反射创建对象放到map。</p><p> 在代码需要用到里面对象时，再通过DI注入（autowired、resource等，xml里bean节点内的ref属性，项目启动时会读取xml节点ref属性根据id注入，也会扫描这些注解根据类型或id注入，id就是对象名）。</p><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>当A运行到需要B时，IOC容器会主动创建一个B注入到对象A需要的地方。对象A获得依赖对象B的过程，由<strong>主动行为变为了被动行为</strong>。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>实现IOC的方法</strong>，IOC容器在运行期间，动态地将某种依赖关系注入到对象中。</p><h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><p>ApplicationContext是BeanFactory的子接口，提供了更完整的功能：</p><ol><li>继承MessageSource，因此<strong>支持国际化</strong>，比如可以用MessageSource实现资源文件的读取（MessageSource接口中的getMessage方法）</li><li>统一的资源文件访问方式</li><li>提供在监听器中注册bean的事件（疑惑）</li><li>同时加载多个配置文件</li><li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><p>不同点：</p><ol><li>BeanFactory延迟加载注入Bean，而ApplicationContext在容器启动时一次性创建所以的Bean，这样<strong>有利于检查所依赖属性是否注入</strong>，无需等待，不足是占用内存空间</li><li>BeanFactory通常以编程方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li><li>他们都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，区别：BeanFactory需要手动注册，而ApplicationContext则是自动注册</li></ol><blockquote><p>BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改。</p><p>BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。</p></blockquote><h2 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h2><ol><li>解析类得到BeanDefinition</li><li>如果有多个构造方法，则推断构造方法</li><li>实例化得到一个对象</li><li>@Autowired注解属性填充</li><li>回调Aware方法，比如BeanNameAware（获取当前bean在IOC容器中的名字），BeanFactoryAware</li><li>调用BeanPostProcessor的初始化前的方法</li><li>调用初始化方法</li><li>调用BeanPostProcessor的初始化后的方法，在这里会进行AOP</li><li>如果当创建的bean是单例的则放入单例池</li><li>使用bean</li><li>容器关闭时调用DisposableBean中destory方法</li></ol><h2 id="Spring-Bean作用域"><a href="#Spring-Bean作用域" class="headerlink" title="Spring Bean作用域"></a>Spring Bean作用域</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-1.jpg" alt></p><h2 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>由一个工厂类根据传入的参数，动态觉得应该创建哪一个产品类</p><p>BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建根据具体情况来定。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>实现了FactoryBean接口的bean，spring会在使用getBean（）调用获得该bean时，会自动调用该bean的getObject（）方法，所以返回的不是factory这个bean，而是这个bean.getObject（）方法的返回值。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>Spring提供了全局的访问点BeanFactory，但是没有从构造器级别时控制单例，这是因为spring管理的是任意的java对象。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>Spring定义了一个适配接口，使每一种Controller有一种对应的适配器实现类（SpringMVC中HandlerAdapter），让适配器代替Controller执行相应的方法（Handler）。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>动态地给一个对象添加一些额外的职责。增加功能比生成子类更加灵活。</p><p>Spring中用到的装饰器模式在类名上有两种表现：1、类名中含有wrapper；2、类名中含有Decorator</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>切面在应用运行的时候被织入。在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。</p><p>在一个方法上加了@Transactional（申明式事务）注解后，Spring会<strong>基于这个类生成一个代理对象</strong>，Autowired后getBean从AOP容器中取得代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，代理逻辑会先把事务的自动提交设置为false。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Spring的事件驱动模型使用的是观察者模式，ApplicationContext事件机制是观察者模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Spring框架的资源访问Resource接口，该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。</p><h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h2><h3 id="autowire属性五种装配方式"><a href="#autowire属性五种装配方式" class="headerlink" title="autowire属性五种装配方式"></a>autowire属性五种装配方式</h3><h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>缺省情况下，自动配置时通过“ref”属性手动设定。</p><p>手动装配：以value或ref的方式明确指定属性值</p><h4 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h4><p>根据bean的属性名称进行自动装配</p><p>Customer的属性名称为person，Spring会将bean id为person的bean通过setter方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h4><p>根据bean的类型进行自动装配</p><p>Customer的属性person的类型为Person，Spring会将Person类型通过setter方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型相同，则进行自动装配，否则导致异常。</p><p>Customer构造函数的参数person的类型为Person，Spring会将Person类型通过构造方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>constructor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="autodetect"><a href="#autodetect" class="headerlink" title="autodetect"></a>autodetect</h4><p>如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配</p><h4 id="Autowired自动装配bean"><a href="#Autowired自动装配bean" class="headerlink" title="@Autowired自动装配bean"></a>@Autowired自动装配bean</h4><p>可在<strong>字段，setter方法，构造函数</strong>上使用。</p><h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。（Map&lt; url , handler &gt;，其中url可以是bean id、@RequestMapping、key）</li><li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器（Controller接口定义整个类为一个Handler、@RequestMapping定义方法、Servlet三种方法都有各自的适配器，support方法遍历适配器，找到后执行handle调用真正的handler）</li><li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet把ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图（将模型数据填充至视图中，比如JSP）</li><li>DispatcherServlet响应用户</li></ol><h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-2.jpg" alt></p><h2 id="和"><a href="#和" class="headerlink" title="#{ }和${ }"></a>#{ }和${ }</h2><p>#{ }是预编译处理，是占位符，${ }是字符串替换，是拼接符</p><ol><li>Mybatis在处理#{ }时，会将sql中的#{ }替换为 ？号，调用PreparedStatement来赋值（会自动加单引号）；</li><li>在处理${ }时，就是替换成变量值，调用Statement来赋值；</li></ol><h2 id="绝大多数需求为单条记录查询时可以选择哈希索引"><a href="#绝大多数需求为单条记录查询时可以选择哈希索引" class="headerlink" title="绝大多数需求为单条记录查询时可以选择哈希索引"></a>绝大多数需求为单条记录查询时可以选择哈希索引</h2><h2 id="定义有外键的数据列一定要建立索引"><a href="#定义有外键的数据列一定要建立索引" class="headerlink" title="定义有外键的数据列一定要建立索引"></a>定义有外键的数据列一定要建立索引</h2><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><ol><li>是否load了额外的数据</li><li>是否走索引</li><li>横向或纵向分表</li></ol><h2 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h2><ol><li><p>A由<strong>undo log</strong>日志保证，它记录了<strong>需要回滚的日志信息</strong>，事务回滚时撤销已经执行成功的sql</p></li><li><p>C由其他三大特性保证，<strong>程序代码</strong>要保证业务上的一致性</p></li><li><p>I由<strong>MVCC</strong>来保证</p></li><li><p>D由<strong>内存 + redo log</strong>来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复。redo log记录了<strong>数据修改的状态</strong></p><blockquote><p>InnoDB redo log写盘，InnoDB 事务进入prepare 状态。</p><p>如果前面 prepare成功，binlog 写盘，再继续将事务日志持久化到binlog。如果持久化成功，那么InnoDB事务则进入commit状态（在 redo log里面写一个commit记录）</p><p>所以说如果redo log中由commit，说明binlog持久化成功</p></blockquote><p>redo log的刷盘会在系统空闲时进行。（Mysql的主从同步（复制）通过binlog来同步）</p></li></ol><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><strong>多版本并发控制</strong>（Multi-Version Concurrency Control）：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p><p>MVCC只在 READ COMMITED 和REPEATABLE READ 下工作。因为READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而serializable则会对所有读取的行都加锁。</p><p>聚簇索引记录中有两个必要的隐藏列：</p><ol><li><strong>trx_id</strong>：用来存储每次对某条聚簇索引记录进行修改的时候的事务id</li><li><strong>roll_pointer</strong>：每次对聚簇索引修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了个<strong>指针</strong>，指向<strong>索引记录的上一个版本</strong>的位置。（注意插入操作的undo日志没有这个属性，因为它没有老版本）</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-3.jpg" alt></p><h2 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h2><p>主要由三个线程：master（binlog dump thread）、slave（I / O thread、SQL thread）</p><ol><li>主节点binlog，主从复制的基础是<strong>主库记录数据库的所有变更记录到binlog</strong>。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li><li>主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。</li><li>从节点I /O 线程接受binlog 内容，并将其写入到relay log 文件中。（relay log在从节点）</li><li>从节点的SQL线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库一致性。</li></ol><p>注：主从节点使用 <strong>binlog文件 + position</strong> 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置同步。</p><p>mysql默认的复制方式是异步的，主库把日志发送给从库不关心从库是否已经处理。有一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库，日志丢失了。</p><p><strong>全同步复制</strong>：主库写入binlog后强制同步日志到从库，<strong>所有</strong>从库执行完才返回客户端。</p><p><strong>半同步复制</strong>：从库写入日志成功后返回ACK确认给主库，主库<strong>收到至少一个</strong>从库的确认就认为完成。</p><h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><p>DNS方式实现负载均衡</p><p>硬件负载均衡：F5和A10</p><p>软件负载均衡：</p><ol><li><strong>Nginx</strong>：七层负载均衡，支持HTTP、E-mail协议，同时也支持4层负载均衡（解析url，与客户端和服务端都要保持长连接，性能损耗）</li><li><strong>HAproxy</strong>：支持七层规则，性能不错。OpenStack 默认使用</li><li><strong>LVS</strong>：运行在内核态，性能最高，严格说工作在第三层（ip——&gt;Server）</li></ol><h2 id="分布式下Session共享方案"><a href="#分布式下Session共享方案" class="headerlink" title="分布式下Session共享方案"></a>分布式下Session共享方案</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-4.jpg" alt></p><h2 id="分布式锁解决方案"><a href="#分布式锁解决方案" class="headerlink" title="分布式锁解决方案"></a>分布式锁解决方案</h2><p>需要这个锁独立于每一个服务之外，而不是在服务里面。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>利用<strong>主键冲突</strong>控制一次只有一个线程能获取锁，非阻塞（要自己写阻塞代码）、不可重入（递归不支持，要自己实现AQS）、单点、不支持失效时间（要自己写定时器）</p><p>比如在数据库中建张表，采用唯一约束，要获得锁就往数据库中插入同一个key的记录放到唯一键上面，如果放进去了就是拿到锁了。</p><h3 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h3><p>zk通过Znode解决<strong>死锁</strong>问题，一旦客户端获取锁后突然挂掉，这个临时节点会自动删除，其他客户端自动获取锁。</p><p>临时顺序节点解决<strong>惊群效应</strong>。</p><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>setNX命令，<strong>单线程处理网络请求</strong>，不需要考虑并发安全性。</p><p>Redis是个第三方中间件，在集群中很方便地实现分布式锁，所有服务节点设置相同地key，返回0则获取锁失败，T1申请到key后T2肯定申请不到。</p><h4 id="setNX问题"><a href="#setNX问题" class="headerlink" title="setNX问题"></a>setNX问题</h4><ol><li>早期版本<strong>没有超时参数</strong>，需要单独设置，存在死锁问题（key不会超时）</li><li>后期版本提供加锁和设置时间原子操作（set（NX,，timeout）），但是存在任务超时，锁自动释放，导致<strong>并发问题</strong>，加锁和释放锁不是同一线程问题（假如T1获得锁要执行15s，锁失效时间为10s，在这5s内T2获得了锁，T1执行完了要把锁释放掉，结果把T2的锁释放了，解决方法可以在value中存上线程的唯一标识或者uuid）</li></ol><p>删除锁：<strong>判断线程唯一标识再删除</strong></p><p>可重入性及<strong>锁续期</strong>没有实现，通过redisson解决（类似AQS实现（count计数），看门狗监听机制（设置一个监听器监听任务，任务没有执行完就延长过期时间））</p><p><strong>redlock</strong>：以上的机制都只操作单节点，即使Redis通过Sentinel保证高可用，如果这个master节点由于某些发生了主从切换，那么就会出现锁丢失的情况（主从节点间是异步通信，Redis同步设置可能数据丢失）。redlock从多个节点申请锁，当一半以上节点获取成功才算成功，redisson有相应的实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h2&gt;&lt;p&gt;将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>es分布式一致性原理</title>
    <link href="https://arthurjq.com/2021/03/10/es-node/"/>
    <id>https://arthurjq.com/2021/03/10/es-node/</id>
    <published>2021-03-09T17:01:38.000Z</published>
    <updated>2021-03-10T14:25:25.120Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><p>待完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;
&lt;p&gt;待完成&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="elasticsearch" scheme="https://arthurjq.com/tags/elasticsearch/"/>
    
      <category term="分布式系统" scheme="https://arthurjq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java的守护线程</title>
    <link href="https://arthurjq.com/2021/03/09/java/daemon-thread/"/>
    <id>https://arthurjq.com/2021/03/09/java/daemon-thread/</id>
    <published>2021-03-09T06:56:38.000Z</published>
    <updated>2021-03-10T02:14:37.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>用户线程</strong>即运行在前台的线程，而<strong>守护线程</strong>是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，比如垃圾回收线程就是一个守护线程。</p><p>其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以Daemon Thread也就退出了。</p><p>简单的讲就是<strong>JVM的退出不用考虑守护线程的退出，而必须考虑用户线程的退出</strong>。</p><p>用户也可以<strong>自行的设定守护线程</strong>，方法：<code>public final void setDaemon(boolean on)</code> ；但是有几点需要注意：</p><ol><li>thread.setDaemon（true）必须在thread.start（）之前设置，否则会跑出一个IllegalThreadStateException异常。<strong>你不能把正在运行的常规线程设置为守护线程</strong>。 （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</li><li>在Daemon线程中产生的新线程也是Daemon的。 （这一点又是有着本质的区别了：守护进程fork（）出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</li><li>守护线程<strong>不能用于去访问固有资源</strong>，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了</li><li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li></ol><p>转载：<a href="https://blog.csdn.net/lc1010078424/article/details/79613348" target="_blank" rel="noopener">https://blog.csdn.net/lc1010078424/article/details/79613348</a></p><h2 id="Daemon-Thread实际应用"><a href="#Daemon-Thread实际应用" class="headerlink" title="Daemon Thread实际应用"></a>Daemon Thread实际应用</h2><h3 id="web服务器中的Servlet"><a href="#web服务器中的Servlet" class="headerlink" title="web服务器中的Servlet"></a>web服务器中的Servlet</h3><p>web服务器中的Servlet，容器启动时后台初始化一个服务线程，即调度线程，负责处理http请求；</p><p>每个请求过来调度线程从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。</p><h3 id="Java的Timer"><a href="#Java的Timer" class="headerlink" title="Java的Timer"></a>Java的Timer</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Timer<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimerTaskRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统当前时间："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calendar<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上写法任务虽然运行完了，但进程还未销毁，为什么会出现这种情况呢？</p><p>可以看一下Timer的源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"Timer-"</span> <span class="token operator">+</span> <span class="token function">serialNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出<strong>每创建一个Timer就是启动一个新的线程，那么启动的线程不是守护线程，所以一直运行</strong>。那我们该如何将 新创建的的Timer 改成守护线程呢？更改如上的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimerTaskRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统当前时间："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calendar<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//设置Timer为true</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果只想执行一次等待执行完之后调用timer.cancel（）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用户线程&lt;/strong&gt;即运行在前台的线程，而&lt;strong&gt;守护线程&lt;/strong&gt;是运行在后台的线程。 守护线程作用
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="thread" scheme="https://arthurjq.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://arthurjq.com/2021/03/08/java-basis/"/>
    <id>https://arthurjq.com/2021/03/08/java-basis/</id>
    <published>2021-03-08T02:23:24.000Z</published>
    <updated>2021-03-10T11:17:37.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点： 性能比面向过程低</p><h2 id="Java和C"><a href="#Java和C" class="headerlink" title="Java和C++"></a>Java和C++</h2><ol><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ol><h2 id="构造器Constructor"><a href="#构造器Constructor" class="headerlink" title="构造器Constructor"></a>构造器Constructor</h2><h3 id="构造器-Constructor-是否可被-override？"><a href="#构造器-Constructor-是否可被-override？" class="headerlink" title="构造器 Constructor 是否可被 override？"></a>构造器 Constructor 是否可被 override？</h3><p>父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="overload和override"><a href="#overload和override" class="headerlink" title="overload和override"></a>overload和override</h2><p>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><p>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法</p><blockquote><p>方法重载跟返回值类型和修饰符无关</p></blockquote><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在<strong>程序运行期间</strong>才确定。</p><p>两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</p><p>条件：1.要有继承 2.要有方法的重写 3.父类引用指向子类对象</p><h2 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h2><ol><li>操作少量的数据 = String</li><li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li></ol><h2 id="静态方法内调用一个非静态成员"><a href="#静态方法内调用一个非静态成员" class="headerlink" title="静态方法内调用一个非静态成员"></a>静态方法内调用一个非静态成员</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>一、静态方法只能访问静态方法和静态成员。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//加入static关键字，变成静态方法</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> result<span class="token operator">=</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//静态方法调用静态方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result="</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、非静态方法要被实例化才能被静态方法调用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Test test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化类</span>        <span class="token keyword">int</span> result<span class="token operator">=</span>test<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用非静态方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result="</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无参构造的作用"><a href="#无参构造的作用" class="headerlink" title="无参构造的作用"></a>无参构造的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 super（）来调用父类特定的构造方法，则会调用父类中的无参构造。</p><p>在调用子类构造方法之前会先调用父类无参构造方法，是为了帮助子类做<strong>初始化工作</strong>。</p><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范</li></ol><h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><ol><li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的<br>变量或是方法的参数</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值</li></ol><h2 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h2><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li><li>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h2 id="equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h2><p>因为两个对象有相同的 hashcode 值，它们也不一定是相等的</p><blockquote><p>hashCode 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h2 id="类中所有的-private-方法都隐式地指定为-final"><a href="#类中所有的-private-方法都隐式地指定为-final" class="headerlink" title="类中所有的 private 方法都隐式地指定为 final"></a>类中所有的 private 方法都隐式地指定为 final</h2><h2 id="处理不想序列化的字段"><a href="#处理不想序列化的字段" class="headerlink" title="处理不想序列化的字段"></a>处理不想序列化的字段</h2><p>使用 transient 关键字修饰。</p><p>作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><p>transient 只能修饰变量，不能修饰类和方法。</p><h2 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h2><p>方法 1：通过 Scanner</p><pre class="line-numbers language-java"><code class="language-java">Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>String s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方法 2：通过 BufferedReader</p><pre class="line-numbers language-java"><code class="language-java">BufferedReader input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h2><p>Native Method就是一个java调用非java代码的接口。</p><p>被native关键字修饰的方法叫做本地方法，本地方法和其它方法不一样，本地方法意味着和平台有关，因此使用了native的程序可移植性都不太高。另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的<strong>本地方法栈</strong>。native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。被native修饰的方法可以被C语言重写。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p><strong>堆</strong>是进程和线程共有的空间，唯一目的是<strong>存放对象实例</strong>，创建的对象和数组都保存在堆中。</p><p><strong>栈</strong>是每个线程独有的，每个线程的栈相互独立。每个方法在执行的同时都会创建一个栈帧用来存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>每条线程都还有<strong>私有的</strong>ThreadLocalMap容器，无需使用同步机制保证多线程访问容器的互斥性。（使用static，又不想考虑线程安全的时候用）</p><p>使用场景：</p><ol><li>在进行<strong>对象跨层传递</strong>的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息（Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection）</li><li>数据库连接，Session会话管理</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-1.png" alt></p><p>ThreadLocal内存泄漏的根源：<strong>由于ThreadLocalMap的生命周期跟Thread一样长</strong>，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p>正确用法：</p><ol><li>每次使用完ThreadLocal都<strong>调用它的remove（）方法</strong>清除数据</li><li>将ThreadLocal变量定义成<strong>private static</strong>，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="对象锁（monitor）"><a href="#对象锁（monitor）" class="headerlink" title="对象锁（monitor）"></a>对象锁（monitor）</h3><p>synchronized的具体底层实现，demo:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中有一个同步代码块，<strong>锁住的是类对象</strong>，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到SynchronizedDemo.class的同级目录之后，然后用<code>javap -v SynchronizedDemo.class</code>查看字节码文件：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-2.png" alt></p><p>使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是<strong>互斥</strong>的，即同一时刻只有一个线程能够获取到monitor。</p><p>从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是<strong>锁的重入性</strong>，<strong>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</strong>。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-3.png" alt></p><p>该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现</p><h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的。</p><h4 id="自旋时间过长"><a href="#自旋时间过长" class="headerlink" title="自旋时间过长"></a>自旋时间过长</h4><p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时CAS能保证其原子性，<strong>如果对多个共享变量进行操作，CAS就不能保证其原子性</strong>。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><h4 id="总线lock"><a href="#总线lock" class="headerlink" title="总线lock"></a>总线lock</h4><p>在CPU1要操作共享变量的时候，其在总线上发出一个LOCK#信号，其他处理器就不能操作缓存了该共享变量内存地址的缓存。</p><h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h4><p>当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在它们内部的缓存，或者从主内存中重新读取</p><p>MESI协议：在每个缓存行上维护两个状态位</p><ol><li><p>​    M：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且<strong>没有更新到内存</strong>中。</p></li><li><p>​    E：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其<strong>数据没有修改</strong>，即与内存中一致。</p></li><li><p>​    S：共享的。处于这一状态的数据在多个CPU中都有缓存，且<strong>与内存一致</strong>。</p></li><li><p>​    I：无效的。本CPU中的这份缓存已经无效。</p></li><li><p>M状态必须时刻<strong>监听所有试图读取该缓存行</strong>对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</p></li><li><p>E状态必须时刻<strong>监听其他试图读取该缓存行</strong>对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</p></li><li><p>S状态必须时刻<strong>监听使该缓存行无效或者独享该缓存行的请求</strong>，如果监听到，则必须把其缓存行状态设置为I。</p></li></ol><blockquote><p>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</p><p>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令（Read Or Ownership，这是一种总线事务），通知其他CPU置缓存无效（I），这种情况下性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger.incrementAndGet（用了CAS）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>quartz实现高级定制化定时任务中用AtomicInteger标识程序执行过程中是否发生了异常</p></blockquote><p>把普通变量升级为原子变量：主要是<code>AtomicIntegerFieldUpdater&lt;T&gt;</code>类</p><p>在高并发情况下，LongAdder（累加器）比AtomicLong原子操作效率更高，LongAdder累加器是java8新加入的</p><p>在高度并发竞争情形下，AtomicLong每次进行add都需要flush和refresh（这一块涉及到java内存模型中的工作内存和主内存的，所有变量操作只能在工作内存中进行，然后写回主内存，其它线程再次读取新值），每次add都需要同步，在高并发时会有比较多冲突，比较耗时导致效率低；而LongAdder中每个线程会维护自己的一个计数器，在最后执行<code>LongAdder.sum()</code>方法时候才需要同步，把所有计数器全部加起来，不需要flush和refresh操作。</p><p>转载：<a href="https://blog.csdn.net/fanrenxiang/article/details/80623884" target="_blank" rel="noopener">https://blog.csdn.net/fanrenxiang/article/details/80623884</a></p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>final</strong>也保证可见性</p><p><strong>synchronized</strong>（阻塞同步）</p><ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol><p><strong>volatile</strong>（非阻塞同步）：在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令</strong>（缓存一致性）</p><ol><li><strong>它先对总线和缓存加锁</strong>，然后执行后面的指令，在<strong>Lock锁住总线</strong>的时候，其他CPU的读写请求都会<strong>被阻塞</strong>，<strong>直到锁释放</strong>。</li><li>最后释放锁后会把高速缓存中的脏数据全部刷新回主内存，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</li></ol><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>synchronized</strong>：对Java中的对象加锁，一种排他的、可重入的锁。通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是<strong>单线程</strong>执行的。满足了as-if-serial语义（单线程），单线程的有序性就天然存在了（<strong>不能禁止重排序</strong>）</p><blockquote><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器和处理器不会对存在<strong>数据依赖关系</strong>的操作做重排序，因为这种重排序会改变执行结果。</p></blockquote><p><strong>volatile</strong>：禁止重排序，使用内存屏障，统一由jvm来生成内存屏障的指令，Lock是软件指令。</p><p>内存屏障的作用：</p><ol><li>屏障下面的代码不能跟屏障上面的代码交换执行顺序</li><li>线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本失效（使用MESI协议）</li></ol><p><strong>内存屏障</strong>是CPU指令。如果字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令：</p><ol><li>对于Load Barrier来说，在指令前插入Load Barrier，可以<strong>让高速缓存中的数据失效，强制从新从主内存加载新数据</strong></li><li>对于Store Barrier来说，在指令后插入Store Barrier，能<strong>让写入缓存中的最新数据更新写入主内存，让其他线程可见</strong></li></ol><p><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p><blockquote><p>如果指令甲happens-before指令乙，那么指令甲必须排序在指令乙之前，并且指令甲的执行结果对指令乙可见。</p></blockquote><h2 id="线程池中为什么先入队列而不是先创建最大线程"><a href="#线程池中为什么先入队列而不是先创建最大线程" class="headerlink" title="线程池中为什么先入队列而不是先创建最大线程"></a>线程池中为什么先入队列而不是先创建最大线程</h2><p>在创建新线程时，要获取全局锁，这时其他都得阻塞，影响效率。</p><h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><p>线程池将线程和任务进行解耦，摆脱了之前通过Thread创建线程时一个线程必须对应一个任务的限制。</p><p>同一个线程可以从阻塞队列中不对获取新任务来执行，其核心原理在于线程池对Thread封装，并<strong>不是每次执行任务都调用Thread.start（）来创建新线程</strong>，而是让每个线程执行一个“循环任务”，不断检查是否有任务需要被执行，有就<strong>调用任务中的run方法</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;p&gt;优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Helm安装ingress</title>
    <link href="https://arthurjq.com/2021/03/06/project/helm-ingress/"/>
    <id>https://arthurjq.com/2021/03/06/project/helm-ingress/</id>
    <published>2021-03-06T02:15:13.000Z</published>
    <updated>2021-03-06T08:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Helm介绍"><a href="#Helm介绍" class="headerlink" title="Helm介绍"></a>Helm介绍</h2><p>Helm是Kubernetes的包管理器，主要用来管理 Charts。Helm Chart是用来封装Kubernetes原生应用程序的一系列YAML文件。可以在你部署应用的时候自定义应用程序的一些Metadata，以便于应用程序的分发。</p><p>对于应用发布者而言，可以通过Helm打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。对于使用者而言，使用Helm后不用需要编写复杂的应用部署文件，可以以简单的方式在Kubernetes上查找、安装、升级、回滚、卸载应用程序。</p><p>Helm和Kubernetes之间的关系可以如下类比。</p><ul><li>Helm &lt;–&gt; Kubernetes</li><li>Yum &lt;–&gt; CentOS</li></ul><p>Kubernetes的应用编排存在着一些问题，Helm可以用来解决这些问题。</p><p>1：管理、编辑与更新大量的Kubernetes配置文件</p><p>2：部署一个含有大量配置文件的复杂Kubernetes应用</p><p>3：分享和复用Kubernetes配置和应用</p><p>4：参数化配置模板支持多个环境</p><p>5：管理应用的发布：回滚、diff 和查看发布历史</p><p>6：控制一个部署周期中的某一些环节</p><p>7：发布后的测试验证</p><h2 id="Helm原理"><a href="#Helm原理" class="headerlink" title="Helm原理"></a>Helm原理</h2><p>下面两张图描述了 Helm 的几个关键组件 Helm（客户端）、Tiller（服务器）、Repository（Chart 软件仓库）、Chart（软件包）之间的关系以及它们之间如何通信</p><p>helm 组件通信：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/helm-1.png" alt></p><p>helm 架构</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/helm-2.png" alt></p><p><strong>创建release</strong></p><ol><li>helm 客户端从指定的目录或本地tar文件或远程repo仓库解析出chart的结构信息</li><li>helm 客户端指定的 chart 结构和 values 信息通过 gRPC 传递给 Tiller</li><li>Tiller 服务端根据 chart 和 values 生成一个 release</li><li>Tiller 将install release请求直接传递给 kube-apiserver</li></ol><p><strong>删除release</strong></p><ol><li>helm 客户端从指定的目录或本地tar文件或远程repo仓库解析出chart的结构信息</li><li>helm 客户端指定的 chart 结构和 values 信息通过 gRPC 传递给 Tiller</li><li>Tiller 服务端根据 chart 和 values 生成一个 release</li><li>Tiller 将delete release请求直接传递给 kube-apiserver</li></ol><p><strong>更新release</strong></p><ol><li>helm 客户端将需要更新的 chart 的 release 名称 chart 结构和 value 信息传给 Tiller</li><li>Tiller 将收到的信息生成新的 release，并同时更新这个 release 的 history</li><li>Tiller 将新的 release 传递给 kube-apiserver 进行更新</li></ol><h3 id="chart基本结构"><a href="#chart基本结构" class="headerlink" title="chart基本结构"></a>chart基本结构</h3><p>Helm的打包格式叫做chart，所谓chart就是一系列文件, 它描述了一组相关的 k8s 集群资源。Chart中的文件安装特定的目录结构组织, 最简单的chart 目录如下所示：</p><pre class="line-numbers language-text"><code class="language-text">./├── charts├── Chart.yaml├── templates│   ├── deployment.yaml│   ├── _helpers.tpl│   ├── ingress.yaml│   ├── NOTES.txt│   ├── serviceaccount.yaml│   ├── service.yaml│   └── tests│       └── test-connection.yaml└── values.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>charts 目录存放依赖的chart</li><li>Chart.yaml 包含Chart的基本信息，包括chart版本，名称等</li><li>templates 目录下存放应用一系列 k8s 资源的 yaml 模板</li><li>_helpers.tpl 此文件中定义一些可重用的模板片断，此文件中的定义在任何资源定义模板中可用</li><li>NOTES.txt 介绍chart 部署后的帮助信息，如何使用chart等</li><li>values.yaml 包含了必要的值定义（默认值）, 用于存储 templates 目录中模板文件中用到变量的值</li></ol><h2 id="Helm安装"><a href="#Helm安装" class="headerlink" title="Helm安装"></a>Helm安装</h2><p>下载helm v3.0.2，地址 <a href="https://get.helm.sh/helm-v3.0.2-linux-amd64.tar.gz" target="_blank" rel="noopener">https://get.helm.sh/helm-v3.0.2-linux-amd64.tar.gz</a></p><p>上传并解压。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tar</span> zxvf helm-v3.0.2-linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将helm拷贝到系统path路径下，以下为 /usr/local/bin/helm</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> linux-amd64/helm /usr/local/bin/helm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看helm版本</p><pre class="line-numbers language-bash"><code class="language-bash">helm versionversion.BuildInfo<span class="token punctuation">{</span>Version:<span class="token string">"v3.0.0"</span>, GitCommit:<span class="token string">"e29ce2a54e96cd02ccfce88bee4f58bb6e2a28b6"</span>, GitTreeState:<span class="token string">"clean"</span>, GoVersion:<span class="token string">"go1.13.4"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>增加常用chart源。helm提供了常用的chart源，可以在helm的hub库：<a href="https://hub.helm.sh/charts" target="_blank" rel="noopener">https://hub.helm.sh/charts</a></p><p>查看提供的各种应用的chart库，左边是各种官方chart库，右边是chart库中的应用chart。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#除了阿里云应该都需要科学，stable是官方的，aliyuncs最快</span>helm repo add stable https://kubernetes-charts.storage.googleapis.comhelm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com helm repo add bitnami https://charts.bitnami.com/bitnamihelm repo add aliyuncs https://apphub.aliyuncs.comhelm repo add aliyun-stable https://acs-k8s-ingress.oss-cn-hangzhou.aliyuncs.com/charts<span class="token comment" spellcheck="true">#查看chart列表</span>helm repo listNAME            URLstable          https://kubernetes-charts.storage.googleapis.comincubator       https://kubernetes-charts-incubator.storage.googleapis.combitnami         https://charts.bitnami.com/bitnamialiyuncs        https://apphub.aliyuncs.comaliyun-stable   https://acs-k8s-ingress.oss-cn-hangzhou.aliyuncs.com/charts<span class="token comment" spellcheck="true">#更新依赖源</span>helm repo update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="采用Deployment-多Replica的部署形式安装ingress"><a href="#采用Deployment-多Replica的部署形式安装ingress" class="headerlink" title="采用Deployment+多Replica的部署形式安装ingress"></a>采用Deployment+多Replica的部署形式安装ingress</h4><p>下载<a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.44.0/deploy/static/provider/cloud/deploy.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.44.0/deploy/static/provider/cloud/deploy.yaml</a></p><p>修改对应的镜像源：image:<a href="http://quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.31.1" target="_blank" rel="noopener">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.31.1</a></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f ingress.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看对应的ingress pod是否有启动成功</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get po -n ingress-nginxkubectl describe pod pod_id -n ingress-nginx<span class="token comment" spellcheck="true">#查看ingress服务是否正常</span>kubectl get svc -n ingress-nginx<span class="token comment" spellcheck="true">#删除辅助的POD</span>kubectl delete pod xxxxx -n ingress-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看对应的节点端口</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get svc -n ingress-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器用<code>物理节点IP:31434</code>访问，看是否正常</p><h2 id="用ingress对服务做路由"><a href="#用ingress对服务做路由" class="headerlink" title="用ingress对服务做路由"></a>用ingress对服务做路由</h2><h3 id="ingress概述"><a href="#ingress概述" class="headerlink" title="ingress概述"></a>ingress概述</h3><p>k8s 对外暴露服务（service）主要有两种方式：NotePort, LoadBalance， 此外externalIPs也可以使各类service对外提供服务</p><ol><li>但是当集群服务很多的时候，NodePort方式最大的缺点是会占用很多集群机器的端口；</li><li>LB方式最大的缺点则是每个service一个LB又有点浪费和麻烦，并且需要k8s之外的支持； </li><li>而ingress则<strong>只需要一个NodePort或者一个LB</strong>就可以满足所有service对外服务的需求。</li></ol><p>ingress工作机制大致可以用下图表示：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/helm-3.png" alt></p><p>实际上，ingress相当于一个<strong>7层的负载均衡器</strong>，是k8s对反向代理的一个抽象。大概的工作原理也确实类似于Nginx，可以理解成<strong>在 Ingress 里建立一个个映射规则 , ingress Controller 通过监听 Ingress这个api对象里的配置规则并转化成 Nginx 的配置</strong>（kubernetes声明式API和控制循环） , 然后<strong>对外部提供服务</strong>。ingress包括：ingress controller 和 ingress resources</p><p><strong>ingress controller</strong>：核心是一个deployment，实现方式有很多，比如nginx, Contour, Haproxy, trafik, Istio，需要编写的yaml有：Deployment, Service, ConfigMap, ServiceAccount（Auth），其中service的类型可以是NodePort或者LoadBalancer。</p><p><strong>ingress resources</strong>：这个就是一个类型为Ingress的k8s api对象了，这部分则是面向开发人员。</p><p>Kubernetes给出的方案就是Ingress，Ingress包含了两大主件Ingress Controller和Ingress。</p><p>Ingress解决的是新的服务加入后，域名和服务的对应问题，基本上是一个ingress的对象，通过yaml进行创建和更新进行加载。</p><p>Ingress Controller是将Ingress这种变化生成一段Nginx的配置，然后将这个配置通过Kubernetes API写到Nginx的Pod中，然后reload.（注意：写入 nginx.conf 的不是service的地址，而是service backend 的 pod 的地址，避免在 service 在增加一层负载均衡转发）</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/helm-4.png" alt></p><p>从上图中可以很清晰的看到，实际上请求进来还是被<strong>负载均衡器</strong>拦截，比如 nginx，然后 Ingress Controller 通过跟 Ingress 交互得知某个域名对应哪个 service，再通过跟 kubernetes API 交互得知 service 地址等信息；综合以后生成配置文件实时写入负载均衡器，然后负载均衡器 reload 该规则便可实现服务发现，即动态映射</p><p>了解了以上内容以后，这也就很好的说明了我为什么喜欢把负载均衡器部署为 Daemon Set；因为无论如何请求首先是被负载均衡器拦截的，所以在每个 node 上都部署一下，同时 hostport 方式监听 80 端口；那么就解决了其他方式部署不确定 负载均衡器在哪的问题，同时访问每个 node 的 80 都能正确解析请求；如果前端再 放个 nginx 就又实现了一层负载均衡。<br>Ingress Controller 会根据你定义的 Ingress 对象，提供对应的代理能力。业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为Kubernetes 专门维护了对应的 Ingress Controller。</p><p>Ingress Controller 会根据你定义的 Ingress 对象，提供对应的代理能力。业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为Kubernetes 专门维护了对应的 Ingress Controller。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/helm-5.png" alt></p><h3 id="ingress-nginx-部署"><a href="#ingress-nginx-部署" class="headerlink" title="ingress-nginx 部署"></a>ingress-nginx 部署</h3><p>ingress调度的是后端的service，而不是pod</p><p>ingress调度hello-service这个服务</p><p>创建对应的hello-ingress.yaml部署文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>ingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/service-upstream</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> hello.abc.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行部署</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f hello-ingress.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Helm介绍&quot;&gt;&lt;a href=&quot;#Helm介绍&quot; class=&quot;headerlink&quot; title=&quot;Helm介绍&quot;&gt;&lt;/a&gt;Helm介绍&lt;/h2&gt;&lt;p&gt;Helm是Kubernetes的包管理器，主要用来管理 Charts。Helm Chart是用来封装Kube
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="运维开发" scheme="https://arthurjq.com/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
      <category term="kubernetes" scheme="https://arthurjq.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>k8s部署栗子</title>
    <link href="https://arthurjq.com/2021/03/04/project/k8s-exp/"/>
    <id>https://arthurjq.com/2021/03/04/project/k8s-exp/</id>
    <published>2021-03-04T10:45:34.000Z</published>
    <updated>2021-03-04T11:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：mvn对应的项目的jar"><a href="#1：mvn对应的项目的jar" class="headerlink" title="1：mvn对应的项目的jar"></a>1：mvn对应的项目的jar</h2><h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><p>以最简单的可以运行java的镜像举例</p><pre class="line-numbers language-shell"><code class="language-shell">FROM openjdk:8COPY study-0.0.1-SNAPSHOT.jar /study-0.0.1-SNAPSHOT.jarCMD ["java","-jar","/study-0.0.1-SNAPSHOT.jar"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3：build出对应的image"><a href="#3：build出对应的image" class="headerlink" title="3：build出对应的image"></a>3：build出对应的image</h2><pre class="line-numbers language-shell"><code class="language-shell">docker build -t helloworld .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4：docker-push到指定的镜像中心"><a href="#4：docker-push到指定的镜像中心" class="headerlink" title="4：docker push到指定的镜像中心"></a>4：docker push到指定的镜像中心</h2><h2 id="5：编写deployment-yaml部署文件"><a href="#5：编写deployment-yaml部署文件" class="headerlink" title="5：编写deployment.yaml部署文件"></a>5：编写deployment.yaml部署文件</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> springboot  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2 </span><span class="token comment" spellcheck="true"># tells deployment to run 2 pods matching the template</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> springboot    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> springboot        <span class="token key atrule">image</span><span class="token punctuation">:</span> helloworld        <span class="token comment" spellcheck="true">#本地拉取镜像</span>        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Never        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6：发布部署"><a href="#6：发布部署" class="headerlink" title="6：发布部署"></a>6：发布部署</h2><pre class="line-numbers language-shell"><code class="language-shell">kubectl apply -f helloworld-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看部署是否成功</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7：编写service-yaml部署文件"><a href="#7：编写service-yaml部署文件" class="headerlink" title="7：编写service.yaml部署文件"></a>7：编写service.yaml部署文件</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> springboot  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看部署是否成功</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get services<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8：查看服务端口绑定到物理节点的端口"><a href="#8：查看服务端口绑定到物理节点的端口" class="headerlink" title="8：查看服务端口绑定到物理节点的端口"></a>8：查看服务端口绑定到物理节点的端口</h2><pre class="line-numbers language-shell"><code class="language-shell">kubectl get svc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>服务端口映射到物理主机的端口是32405</p><h2 id="9：验证是否可以使用访问"><a href="#9：验证是否可以使用访问" class="headerlink" title="9：验证是否可以使用访问"></a>9：验证是否可以使用访问</h2><p>那么一个最基本的boot服务从package到打入docker镜像，再到k8s集群去负责编排调度，到完成使用就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：mvn对应的项目的jar&quot;&gt;&lt;a href=&quot;#1：mvn对应的项目的jar&quot; class=&quot;headerlink&quot; title=&quot;1：mvn对应的项目的jar&quot;&gt;&lt;/a&gt;1：mvn对应的项目的jar&lt;/h2&gt;&lt;h2 id=&quot;编写Dockerfile&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="运维开发" scheme="https://arthurjq.com/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
      <category term="kubernetes" scheme="https://arthurjq.com/tags/kubernetes/"/>
    
      <category term="docker" scheme="https://arthurjq.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>sql注意要点和规范</title>
    <link href="https://arthurjq.com/2021/03/04/database/sql-standard/"/>
    <id>https://arthurjq.com/2021/03/04/database/sql-standard/</id>
    <published>2021-03-04T06:33:32.000Z</published>
    <updated>2021-03-04T15:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语句书写规则"><a href="#SQL语句书写规则" class="headerlink" title="SQL语句书写规则"></a>SQL语句书写规则</h2><p>1：SQL语句中出现的所有表名、表别名、字段名、序列等数据库对象都应<strong>小写</strong>。</p><p>2：SQL 语句中出现的系统保留字、内置函数名、SQL保留字、绑定变量等都应<strong>大写</strong>。</p><p>3：SQL语句中出现的变量参数应遵循各语言编码规范的要求。</p><p>4：SQL语句中的表别名应简短明了，宜反映表名的实际意义。</p><p>5：应遵循各语言的编码规范的要求。</p><p>6：单引号应与所属的 SQL子句位于同一行。</p><p>7：SQL语句内的算术运算符、逻辑运算符（AND、OR、NOT）、 比较运算符（=、&lt;=、&gt;=、&gt;、&lt;、&lt;&gt;、BETWEEN AND）、IN、LIKE等运算符<strong>前后都应加一空格</strong>。</p><p>8：SQL语句中逗号后应加一空格。</p><p>9：<strong>不等于应统一使用符号“&lt;&gt;”</strong>。</p><p>10：应遵循各语言编码规范的代码注释要求。</p><p>11：对较为复杂的 SQL语句应注释，并说明算法和功能。</p><p>12：对重要的计算应说明其功能。</p><p>13：对常量及变量注释时，应注释被保存值的含义，宜包括合法取值的范围。</p><h2 id="SQL优化要点"><a href="#SQL优化要点" class="headerlink" title="SQL优化要点"></a>SQL优化要点</h2><h3 id="“inner-join”-和直接“-”等号的区别"><a href="#“inner-join”-和直接“-”等号的区别" class="headerlink" title="“inner join” 和直接“=”等号的区别"></a>“inner join” 和直接“=”等号的区别</h3><p>效果一样，但是实现原理不一样，join是基于hashtable连接比较，而=直接就是取笛卡尔集再过滤，所以后者效率低，是<code>O(N^2)</code>，前者是<code>O(LogN)</code></p><h3 id="Union-amp-Union-All"><a href="#Union-amp-Union-All" class="headerlink" title="Union &amp; Union All"></a>Union &amp; Union All</h3><ol><li>Union：对两个结果集进行并集操作，不包括重复行，同时进行<strong>默认规则的排序</strong>；</li><li>Union All：对两个结果集进行并集操作，包括重复行，<strong>不进行排序</strong>；</li></ol><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>（1）主键索引 （ PRIMARY ）</p><p>（2）唯一索引 （ UNIQUE ）</p><p>（3）普通索引 （ INDEX ）</p><p>（4）全文索引（FULLTEXT , MYISAM 及 mysql 5.6 以上的 Innodb ）</p><p>更多索引分类可以看：<a href="https://arthurjq.com/2020/12/17/database/mysql-index/">https://arthurjq.com/2020/12/17/database/mysql-index/</a></p><h3 id="慢SQL问题"><a href="#慢SQL问题" class="headerlink" title="慢SQL问题"></a>慢SQL问题</h3><p>（1）SQL编写问题，由于语句编写的问题导致的慢查询。</p><p>（2）锁，由于锁的问题导致表被锁无法进行正常的读取或写入。</p><p>（3）IO资源竞争，创建索引或者大量插入数据会占用大量的IO。</p><p>（4）服务器硬件问题</p><h3 id="SQL编写问题"><a href="#SQL编写问题" class="headerlink" title="SQL编写问题"></a>SQL编写问题</h3><p><strong>语句写完后，建议大家务必使用explain检查下自己写的语句是否有用到索引，是否导致了全表扫描</strong>。</p><p>关于explain的返回结果的字段意思可以看：<a href="https://arthurjq.com/2020/12/30/database/mysql-explain/">https://arthurjq.com/2020/12/30/database/mysql-explain/</a></p><p>我们在编写SQL的时候需要注意：</p><p>（1）<strong>字段类型转换导致不用索引</strong>，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</p><p>（2）mysql <strong>不支持函数转换</strong>，所以字段前面不能加函数，否则这将用不到索引；</p><p>（3）不要在字段前面加减运算；</p><p>（4）字符串比较长的可以考虑索引一部分减少索引文件大小，提高写入效率；</p><p>（5）like % 在前面用不到索引；</p><p>（6）根据联合索引的第二个及以后的字段单独查询用不到索引；</p><p>（7）不要使用 select *；</p><p>（8）or 的查询尽量用 union 代替 （Innodb）；</p><p>（9）复合索引高选择性的字段排在前面；</p><p>（10）order by / group by 字段包括在索引当中减少排序，效率会更高。</p><p>（11）尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；</p><p>（12）<strong>删除表所有记录请用 truncate</strong>，不要用 delete；</p><p>（13）<strong>不让 mysql 干多余的事情，如计算</strong>；</p><p>（14）<strong>输写 SQL 带字段</strong>，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；</p><p>（15）在 Innodb上用 <code>select count(*)</code>，因为 Innodb 会存储统计信息；</p><p>（16）慎用<code>Order by rand()</code>。</p><p>（17）索引列的数据长度满足业务的情况下能少则少。</p><p>（18）表中的<strong>索引并不是越多越好</strong>，冗余或者无用索引会占用磁盘空间并且会影响增删改的效率。</p><p>之前也发布过mysql数据库优化方法：<a href="https://arthurjq.com/2021/02/03/database/mysql-optimization/">https://arthurjq.com/2021/02/03/database/mysql-optimization/</a></p><h3 id="索引失效的条件"><a href="#索引失效的条件" class="headerlink" title="索引失效的条件"></a>索引失效的条件</h3><p>（1）不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p><p>（2）存储引擎不能使用索引</p><p>（3）联合索引右边的列</p><p>（4）尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p><p>（5）mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p><p>（6）like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。</p><p>（7）WHERE条件中IN可以使用索引， NOT IN 无法使用索引。</p><p>更多索引失效的现象可以看：<a href="https://arthurjq.com/2020/12/26/database/index-missing/">https://arthurjq.com/2020/12/26/database/index-missing/</a></p><h3 id="联合索引注意要点"><a href="#联合索引注意要点" class="headerlink" title="联合索引注意要点"></a>联合索引注意要点</h3><p>索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">5</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">----  abc顺序</span><span class="token number">abc</span>三个索引都在<span class="token keyword">where</span>条件里面用到了，而且都发挥了作用<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span>  <span class="token number">c</span><span class="token operator">=</span><span class="token number">4</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">6</span> <span class="token operator">and</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">where</span>里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token number">a</span>用到索引，<span class="token number">b</span>没有用，所以<span class="token number">c</span>是没有用到索引效果的<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">></span><span class="token number">7</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">---- b范围值，断点，阻塞了c的索引</span><span class="token number">a</span>用到了，<span class="token number">b</span>也用到了，<span class="token number">c</span>没有用到，这个地方<span class="token number">b</span>是范围值，也算断点，只不过自身用到了索引<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">3</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--- 联合索引必须按照顺序使用，并且需要全部使用</span>因为<span class="token number">a</span>索引没有使用，所以这里 <span class="token number">bc</span>都没有用上索引效果<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">></span><span class="token number">4</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">7</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token number">a</span>用到了  <span class="token number">b</span>没有使用，<span class="token number">c</span>没有使用<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">b</span><span class="token punctuation">;</span><span class="token number">a</span>用到了索引，<span class="token number">b</span>在结果排序中也用到了索引的效果，<span class="token number">a</span>下面任意一段的<span class="token number">b</span>是排好序的<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myTest  <span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">c</span><span class="token punctuation">;</span><span class="token number">a</span>用到了索引，但是这个地方<span class="token number">c</span>没有发挥排序效果，因为中间断点了，使用 <span class="token keyword">explain</span> 可以看到 filesort<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mytable <span class="token keyword">where</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">a</span><span class="token punctuation">;</span><span class="token number">b</span>没有用到索引，排序中<span class="token number">a</span>也没有发挥索引效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL语句书写规则&quot;&gt;&lt;a href=&quot;#SQL语句书写规则&quot; class=&quot;headerlink&quot; title=&quot;SQL语句书写规则&quot;&gt;&lt;/a&gt;SQL语句书写规则&lt;/h2&gt;&lt;p&gt;1：SQL语句中出现的所有表名、表别名、字段名、序列等数据库对象都应&lt;strong&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sql" scheme="https://arthurjq.com/tags/sql/"/>
    
      <category term="index" scheme="https://arthurjq.com/tags/index/"/>
    
      <category term="数据库优化" scheme="https://arthurjq.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>timestamp时间格式</title>
    <link href="https://arthurjq.com/2021/03/03/database/timestamp/"/>
    <id>https://arthurjq.com/2021/03/03/database/timestamp/</id>
    <published>2021-03-03T11:10:35.000Z</published>
    <updated>2021-03-04T05:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timestamp和datetime"><a href="#timestamp和datetime" class="headerlink" title="timestamp和datetime"></a>timestamp和datetime</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>timestamp</td><td>4个字节</td><td>支持默认值</td><td>支持自动更新</td><td>时间范围1970–</td></tr><tr><td>datetime</td><td>8个字节</td><td>不支持</td><td>不支持</td><td>时间范围1900 –</td></tr></tbody></table><p>以前的一些项目，所有表字段里都会有个update_time字段，设置为根据时间戳更新</p><p>以下timestamp介绍转载：<a href="https://www.cnblogs.com/csl0910/p/4956815.html" target="_blank" rel="noopener">https://www.cnblogs.com/csl0910/p/4956815.html</a></p><h2 id="TIMESTAMP的变体（用法）"><a href="#TIMESTAMP的变体（用法）" class="headerlink" title="TIMESTAMP的变体（用法）"></a>TIMESTAMP的变体（用法）</h2><p>TIMESTAMP时间戳在创建的时候可以有多重不同的特性，如：</p><p>1.在<strong>创建新记录和修改现有记录</strong>的时候都对这个数据列刷新：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">TIMESTAMP</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.在创建新记录的时候把这个字段设置为当前时间，但<strong>以后修改时，不再刷新它</strong>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">TIMESTAMP</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.在创建新记录的时候<strong>把这个字段设置为0</strong>，以后修改时刷新它：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.在创建新记录的时候<strong>把这个字段设置为给定值</strong>，以后修改时刷新它：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">TIMESTAMP</span> <span class="token keyword">DEFAULT</span> <span class="token string">'yyyy-mm-dd hh:mm:ss'</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>MySQL目前不支持列的Default 为函数的形式,如达到你某列的默认值为当前更新日期与时间的功能,你可以使用TIMESTAMP列类型</strong></p><h2 id="timestamp列类型"><a href="#timestamp列类型" class="headerlink" title="timestamp列类型"></a>timestamp列类型</h2><p>TIMESTAMP值可以从<strong>1970</strong>的某时的开始一直到<strong>2037</strong>年，精度为一秒，其值作为数字显示。<br>TIMESTAMP值显示尺寸的格式如下表所示：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+----------------+</span><span class="token operator">|</span> 列类型　　　　<span class="token operator">|</span> 显示格式　　　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span> <span class="token operator">|</span> YYYYMMDDHHMMSS <span class="token operator">|</span>　<span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">|</span> YYMMDDHHMMSS　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">|</span> YYMMDDHHMM　　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>　<span class="token operator">|</span> YYYYMMDD　　　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>　<span class="token operator">|</span> YYMMDD　　　　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>　<span class="token operator">|</span> YYMM　　　　　 <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>　<span class="token operator">|</span> YY　　　　　　 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+----------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“完整”TIMESTAMP格式是14位，但TIMESTAMP列也可以用更短的显示尺寸，创造最常见的显示尺寸是6、8、12、和14。</p><p>你可以在创建表时指定一个任意的显示尺寸，但是定义列长为0或比14大均会被强制定义为列长14。<br><strong>列长在从1～13范围的奇数值尺寸均被强制为下一个更大的偶数</strong>：</p><pre class="line-numbers language-sql"><code class="language-sql">定义字段长度　　 强制字段长度<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>　<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>　<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>　<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>　<span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的TIMESTAMP列都有同样的存储大小，使用被指定的时期时间值的完整精度（14位）存储合法的值不考虑显示尺寸。不合法的日期，将会被强制为0存储</p><h3 id="含意"><a href="#含意" class="headerlink" title="含意"></a>含意</h3><ol><li><p>虽然你建表时定义了列TIMESTAMP（8），但在你进行数据插入与更新时TIMESTAMP列<strong>实际上保存了14位的数据</strong>（包括年月日时分秒），只不过在你进行查询时MySQL返回给你的是8位的年月日数据。如果你使用ALTER TABLE拓宽一个狭窄的TIMESTAMP列，以前被“隐蔽”的信息将被显示。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test <span class="token punctuation">(</span><span class="token string">'id'</span> <span class="token keyword">INT</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> UNSIGNED <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token string">'date1'</span><span class="token keyword">TIMESTAMP</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test <span class="token keyword">SET</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">20021114</span>　　　 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> test CHANGE <span class="token string">'date1'</span> <span class="token string">'date1'</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">20021114093723</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用TIMESTAMP列类型自动地用当前的日期和时间标记INSERT或UPDATE的操作。</p></li><li><p>同样，<strong>缩小一个TIMESTAMP列不会导致信息失去</strong>，除了感觉上值在显示时，较少的信息被显示出。</p></li><li><p>尽管TIMESTAMP值被存储为完整精度，直接操作存储值的唯一函数是<code>UNIX_TIMESTAMP()</code>；由于MySQL返回 TIMESTAMP列的列值是进过格式化后的检索的值，这意味着你可能不能使用某些函数来操作TIMESTAMP列（例如<code>HOUR()或 SECOND()</code>），除非TIMESTAMP值的相关部分被包含在格式化的值中。<br>例如，一个TIMESTAMP列只有被定义为TIMESTAMP（10）以上时，TIMESTAMP列的HH部分才会被显示，因此在更短的TIMESTAMP值上使用<code>HOUR()</code>会产生一个不可预知的结果。</p></li><li><p>不合法TIMESTAMP值被变换到适当类型的“零”值（00000000000000）。（DATETIME,DATE亦然）</p></li></ol><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>如果你有多个TIMESTAMP列，只有第一个自动更新。自动更新第一个TIMESTAMP列在下列任何条件下发生：</p><ol><li>列值没有明确地在一个INSERT或LOAD DATA INFILE语句中指定。</li><li>列值没有明确地在一个UPDATE语句中指定且另外一些的列改变值。（注意一个UPDATE设置一个列为它已经有的值，这将不引起TIMESTAMP列被更新，因为如果你设置一个列为它当前的值，MySQL为了效率而忽略更改）</li><li>你明确地设定TIMESTAMP列为NULL</li><li>除第一个以外的TIMESTAMP列也可以设置到当前的日期和时间，只要将列设为NULL，或NOW（）。</li></ol><p>建两个timestamp字段后执行insert操作：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test <span class="token punctuation">(</span> <span class="token string">'id'</span> <span class="token keyword">INT</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> UNSIGNED <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token string">'date1'</span> <span class="token keyword">TIMESTAMP</span> <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'date2'</span> <span class="token keyword">TIMESTAMP</span> <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test <span class="token punctuation">(</span>id<span class="token punctuation">,</span> date1<span class="token punctuation">,</span> date2<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test <span class="token keyword">SET</span> id<span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　<span class="token operator">|</span> date2　　　　　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">20021114093723</span> <span class="token operator">|</span> <span class="token number">20021114093723</span> <span class="token operator">|</span><span class="token operator">|</span>　<span class="token number">2</span> <span class="token operator">|</span> <span class="token number">20021114093724</span> <span class="token operator">|</span> <span class="token number">00000000000000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条指令因设date1、date2为NULL,所以date1、date2值均为当前时间第二条指令因没有设date1、date2列值，第一 个TIMESTAMP列date1为更新为当前时间，而二个TIMESTAMP列date2因日期不合法而变为“00000000000000”</p><p>然后进行update操作：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> test <span class="token keyword">SET</span> id<span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　<span class="token operator">|</span> date2　　　　　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span>　<span class="token number">3</span> <span class="token operator">|</span> <span class="token number">20021114094009</span> <span class="token operator">|</span> <span class="token number">20021114093723</span> <span class="token operator">|</span><span class="token operator">|</span>　<span class="token number">2</span> <span class="token operator">|</span> <span class="token number">20021114093724</span> <span class="token operator">|</span> <span class="token number">00000000000000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这条指令没有明确地设定date2的列值，所以第一个TIMESTAMP列date1将被更新为当前时间</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> test <span class="token keyword">SET</span> id<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>date1<span class="token operator">=</span>date1<span class="token punctuation">,</span>date2<span class="token operator">=</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　<span class="token operator">|</span> date2　　　　　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">20021114094009</span> <span class="token operator">|</span> <span class="token number">20021114094320</span> <span class="token operator">|</span><span class="token operator">|</span>　<span class="token number">2</span> <span class="token operator">|</span> <span class="token number">20021114093724</span> <span class="token operator">|</span> <span class="token number">00000000000000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+----------------+----------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这条指令因设定date1=date1，所以在更新数据时date1列值并不会发生改变而因设定date2=NOW（），所以在更新数据时date2列值会被更新为当前时间此指令等效为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> test <span class="token keyword">SET</span> id<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>date1<span class="token operator">=</span>date1<span class="token punctuation">,</span>date2<span class="token operator">=</span><span class="token boolean">NULL</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因MySQL返回的 TIMESTAMP 列为数字显示形式，你可以用<code>DATE_FROMAT()</code>函数来格式化 TIMESTAMP 列，如下所示：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>DATE_FORMAT<span class="token punctuation">(</span>date1<span class="token punctuation">,</span><span class="token string">'%Y-%m-%d %H:%i:%s'</span><span class="token punctuation">)</span> <span class="token keyword">As</span> date1<span class="token punctuation">,</span>DATE_FORMAT<span class="token punctuation">(</span>date2<span class="token punctuation">,</span><span class="token string">'%Y-%m-%d %H:%i:%s'</span><span class="token punctuation">)</span> <span class="token keyword">As</span> date2 <span class="token keyword">FROM</span> test<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+---------------------+---------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　　　　　 <span class="token operator">|</span> date2　　　　　　　 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+---------------------+---------------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span> <span class="token number">09</span>:<span class="token number">40</span>:<span class="token number">09</span> <span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span> <span class="token number">09</span>:<span class="token number">43</span>:<span class="token number">20</span> <span class="token operator">|</span><span class="token operator">|</span>　<span class="token number">2</span> <span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span> <span class="token number">09</span>:<span class="token number">37</span>:<span class="token number">24</span> <span class="token operator">|</span> <span class="token number">0000</span><span class="token operator">-</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">00</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+---------------------+---------------------+</span><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>DATE_FORMAT<span class="token punctuation">(</span>date1<span class="token punctuation">,</span><span class="token string">'%Y-%m-%d'</span><span class="token punctuation">)</span> <span class="token keyword">As</span> date1<span class="token punctuation">,</span>DATE_FORMAT<span class="token punctuation">(</span>date2<span class="token punctuation">,</span><span class="token string">'%Y-%m-%d'</span><span class="token punctuation">)</span> <span class="token keyword">As</span> date2 <span class="token keyword">FROM</span> test<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+-------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> date1　　　 <span class="token operator">|</span> date2　　　 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+-------------+</span><span class="token operator">|</span>　<span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span>　<span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span>　<span class="token operator">|</span><span class="token operator">|</span>　<span class="token number">2</span> <span class="token operator">|</span> <span class="token number">2002</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">14</span>　<span class="token operator">|</span> <span class="token number">0000</span><span class="token operator">-</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">00</span>　<span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------------+-------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在某种程度上，你可以把一种日期类型的值赋给一个不同的日期类型的对象。</p><p>然而，而尤其注意的是：值有可能发生一些改变或信息的损失：</p><ol><li>如果你将一个DATE值赋给一个DATETIME或TIMESTAMP对象，结果值的时间部分被设置为’00:00:00’，因为DATE值中不包含有时间信息。　</li><li>如果你将一个DATETIME或TIMESTAMP值赋给一个DATE对象，结果值的时间部分被删除，因为DATE类型不存储时间信息。</li><li>尽管DATETIME, DATE和TIMESTAMP值全都可以用同样的格式集来指定，但所有类型不都有同样的值范围。</li></ol><p>例如，<strong>TIMESTAMP值不能比1970早，也不能比2037晚，这意味着，一个日期例如’1968-01-01’，当作为一个 DATETIME或DATE值时它是合法的，但它不是一个正确TIMESTAMP值！并且如果将这样的一个对象赋值给TIMESTAMP列，它将被变换为 0</strong>。  </p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li><p><strong>允许作为字符串指定值的宽松格式能被欺骗。</strong>例如，因为“:”分隔符的使用，值’10:11:12’可能看起来像时间值，但是如果在一个日期中使用，上下文将作为年份被解释成’2010-11-12’。值’10:45:15’将被变换到’0000-00-00’，因为’45’不是一个合法的月份。</p></li><li><p><strong>以2位数字指定的年值是模糊的，因为世纪是未知的。</strong>MySQL使用下列规则解释2位年值：在00-69范围的年值被变换到2000-2069。 在范围70-99的年值被变换到1970-1999。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;timestamp和datetime&quot;&gt;&lt;a href=&quot;#timestamp和datetime&quot; class=&quot;headerlink&quot; title=&quot;timestamp和datetime&quot;&gt;&lt;/a&gt;timestamp和datetime&lt;/h2&gt;&lt;table&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://arthurjq.com/tags/mysql/"/>
    
      <category term="数据库优化" scheme="https://arthurjq.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>事务不生效</title>
    <link href="https://arthurjq.com/2021/03/02/java/transaction-no-effect/"/>
    <id>https://arthurjq.com/2021/03/02/java/transaction-no-effect/</id>
    <published>2021-03-02T11:51:15.000Z</published>
    <updated>2021-03-11T08:44:28.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>支付模块是事务操作，如果在支付逻辑执行的过程中有异常，需要做回滚。比如你支付—订单表里插入了订单数据—成功—-然后调起支付失败，此时需要回滚订单表数据。</p><h2 id="transactional注解不生效"><a href="#transactional注解不生效" class="headerlink" title="transactional注解不生效"></a>transactional注解不生效</h2><p>transactional注解什么时候不生效？</p><p>1、检查你的方法是不是public的。@Transactional注解只能应用到public可见度的方法上，如果应用在protected、private或者package可见度的方法上，也不会报错，不过事务设置不会起作用。</p><p>2、检查你的异常类型是不是unchecked异常。默认情况下，Spring会对unchecked异常进行事务回滚，如果是checked异常则不回滚。如空指针异常、算术异常等，会被回滚；文件读写、网络出问题，spring就没法回滚了。如果你想check异常也回滚怎么办，注解上面写明异常类型即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型的还有norollbackFor，自定义不回滚的异常。</p><p>3、是否在service中进行了try…catch的操作，由于已经被捕获异常，故事务也不会回滚。如果非要在service中try…catch异常，又想要事务回滚，可在catch块中抛出运行时异常：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法有个不足之处，就是不能在catch块中存在return子句，若想捕获异常时回滚事务，同时返回提示信息，可以使用手动回滚：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    TransactionAspectSupport<span class="token punctuation">.</span><span class="token function">currentTransactionStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERROR_MESSAGE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>另外说明一下，在controller层捕获了service层的异常，事务还会回滚吗？答案是会的，只要你service层抛出了异常，并且你加的事务可以处理这个异常，也就是rollbackFor = Exception.class这个符合你抛出的异常，不管外面有没有捕获都可以回滚。</p></blockquote><p>4、是否开启了对注解的解析：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span>          <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span> <span class="token attr-name">proxy-target-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、数据库引擎要支持事务，如果是mysql，注意表要使用支持事务的引擎，比如innodb，如果是myisam，事务是不起作用的。</p><p>6、spring是否扫描到你这个包，如下是扫描到org.test下面的包：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.test<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、检查是不是同一个类中的方法调用（如A方法无@Transactional注解，调用了一个有@Transactional注解的方法），这样事务也是不生效的。</p><p>原因：我们知道spring事务的原理是采用aop,其实质是给你的service对象另外造了一个代理对象。这个代理对象和你的service对象有同样的方法名,但是额外在你的 方法前后加了对事务的处理,处理完后再通过this调用你自己service对象的相关方法。<br>所以,当调用方是处于你的service的外面,你拿到的其实不是你写的service的实例,是spring加上事务处理特性后的代理对象,这样子调用事务是能够生效的。<br>但是,你用service 内部方法调用注解了@Transactional的方法, <strong>内部方法得通过this调用这个注解了@Transactional的方法</strong>,此时this对象并不是spring的代理对象,而是你自己写的service的实例.而你自己写的service实例的所有方法都没有事务特性,所以事务必然不生效了。</p><p>8、请确保你的业务和事务入口在<strong>同一个线程</strong>里，否则事务也是不生效的，比如下面代码事务不生效：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>User user1<span class="token punctuation">,</span> User user2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">saveError</span><span class="token punctuation">(</span>user1<span class="token punctuation">,</span> user2<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>数据库不支持事务</li><li>注解放在了私有方法上</li><li>类内部调用，类里面使用this调用本类方法（this通常省略）</li><li>未捕获异常</li><li>没有被Spring管理（没加@Service等注解）</li><li>多线程场景</li></ol><p>这些场景都会导致@Transactional失效</p><h2 id="Transactional注解的使用场景和注意点"><a href="#Transactional注解的使用场景和注意点" class="headerlink" title="Transactional注解的使用场景和注意点"></a>Transactional注解的使用场景和注意点</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务，能避免尽量避免，使用分布式事务中间件不是变慢这么简单，比如你用了事务包围里的一个函数是有一个数据库的写操作，spring会通过jdbc进行锁表的，而此时你又要RPC去调用其他服务，其他服务同样又要都这个表进行写入操作，此时就会死锁。所以如果是分布式事务的话，能避免就避免，因为不同的service是不同的人做，设计到的数据读写，你不是很清楚的情况下，很容易这样的。</p><h3 id="单一表写操作"><a href="#单一表写操作" class="headerlink" title="单一表写操作"></a>单一表写操作</h3><p>单一表的写操作。。就没必要加事务了。。会降低性能的，多表才需要加事务</p><p>mysql会帮你做好并发处理的，单表操作，对于程序逻辑而言是原子性的，不用加事务处理</p><blockquote><p>pagehelper github上有给这个中间件，分页用的，很好用，SQL拦截的</p></blockquote><p>待补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;支付模块是事务操作，如果在支付逻辑执行的过程中有异常，需要做回滚。比如你支付—订单表里插入了订单数据—成功—-然后调起支付失败，此时需要回滚
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="事务" scheme="https://arthurjq.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="annotation" scheme="https://arthurjq.com/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>Redis的cache</title>
    <link href="https://arthurjq.com/2021/03/01/database/redis-cache/"/>
    <id>https://arthurjq.com/2021/03/01/database/redis-cache/</id>
    <published>2021-03-01T08:56:15.000Z</published>
    <updated>2021-03-03T13:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考步骤"><a href="#思考步骤" class="headerlink" title="思考步骤"></a>思考步骤</h2><ol><li><p>评估是否真的需要缓存</p><p>1.1 使用场景？有返回时间要求吗？</p><p>1.2 是否频繁？落到数据库压力大吗？</p><p>1.3 计算难度有多大？</p></li><li><p>真的需要缓存了</p><p>2.1 数据粒度？<br>2.2 数据类型？<br>2.3 数据大小？<br>2.4 数据有效时长？<br>2.5 加载进缓存的时机？<br>2.6 删除缓存的时机？<br>2.7 更新缓存的时机？</p></li><li><p>根据多个缓存对缓存进行操作</p><p>3.1 缓存值可信吗？</p><p>3.2 为什么要根据缓存值对缓存操作？想要的是过程值还是结果值？</p><p>3.3 考虑过拿第一个缓存成功，拿第二个缓存成功，但是第一个缓存在第二个缓存操作的时候失效的情况和后果吗？</p><p>3.4 缓存联动管理是否困难？</p></li></ol><h2 id="简易操作缓存方案"><a href="#简易操作缓存方案" class="headerlink" title="简易操作缓存方案"></a>简易操作缓存方案</h2><ol><li>使用饿汉模式进行管理。只有在要读的时候，才进行缓存加载，其他操作删除相关缓存。</li><li>缓存时间设置不宜过长，5分钟内为宜（因为现在业务没什么对数据库压力特别大、计算又很复杂的时候）</li><li>不同Key的缓存失效时间尽量随机</li><li>考虑缓存穿透问题</li><li>不要使用redis事务</li><li>先进行数据库操作，再操作缓存</li><li>数据粒度要很大时，借助定时任务定期刷新内存</li><li>缓存中找不到时，应该去查找数据库中是否存在，记得用一定策略保证击穿问题得到解决</li><li>用service屏蔽缓存的直接操作，避免造成缓存管理困难（因为service的操作一定可以反映到数据库上，直接操作缓存不一定能落到数据库）</li></ol><p>ps: 数据一致性可以借助<strong>数据库</strong>事务进行实现，保证最坏结果是一次最近更新的值</p><h2 id="补充规范"><a href="#补充规范" class="headerlink" title="补充规范"></a>补充规范</h2><p>1：key定义的规范，这个是用的时候比较容易出错的，重名，和系统关键字冲突，长度等，都需要给出规范来<br>2：value上，应该控制数据的长度，比如防止一些大数据类型，redis本来是提速的，不要因为数据长度影响了自身性能，另外就是合理的使用数据类型，节省存储提升性能，比如能整型的就不要字符串型<br>3：提前评估生命周期，必须保证每个变量都有过期时间；需要对数据进行手动清理，打散过期时间，防止雪崩<br>4：尽可能只使用set和get，避免使用其他命令，特别是flushXXX<br>5：尽量不要使用事务，事务逻辑尽量通过对应的框架实现，包括分布式事务seata<br>6：做好防穿透，击穿，雪崩的常规逻辑处理，比如增加有效数据校验，防止数据库压力过大，增加互斥锁，降低并发，打乱过期时间等。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>原本是用RedisTemplate实现</p><p>建议每个函数还可以重载一个默认值的函数，不然每个函数都要写入太多的参数，一般除了KEY值外，其他的值，都可以根据规范来给一个默认的</p><p>还有封装的话最好用原生提供的jedis：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/redis-cache-1.png" alt></p><p>就是从redis读取对应的key的值，使用100次耗费的时长，单位毫秒</p><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>属于只读缓存方案，1.就是删改直接删缓存，2.增加直接加入数据库。3.查时到缓存取，没有再从数据库中加载，再放到缓存</p><p>回复：数据库那块不属于缓存工具类的职责，不用写</p><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考步骤&quot;&gt;&lt;a href=&quot;#思考步骤&quot; class=&quot;headerlink&quot; title=&quot;思考步骤&quot;&gt;&lt;/a&gt;思考步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;评估是否真的需要缓存&lt;/p&gt;
&lt;p&gt;1.1 使用场景？有返回时间要求吗？&lt;/p&gt;
&lt;p&gt;1.2 是否频繁？
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务" scheme="https://arthurjq.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="redis" scheme="https://arthurjq.com/tags/redis/"/>
    
      <category term="cache" scheme="https://arthurjq.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 查询原理</title>
    <link href="https://arthurjq.com/2021/02/25/database/lucene/"/>
    <id>https://arthurjq.com/2021/02/25/database/lucene/</id>
    <published>2021-02-25T09:44:37.000Z</published>
    <updated>2021-02-26T07:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和搜索能力进行。想要理解搜索系统的实现原理，就需要深入lucene这一层，看看lucene是如何存储需要检索的数据，以及如何完成高效的数据检索。</p><p>转载至阿里云：<a href="https://zhuanlan.zhihu.com/p/35814539" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35814539</a>  |   <a href="https://blog.csdn.net/baichoufei90/article/details/111303223" target="_blank" rel="noopener">https://blog.csdn.net/baichoufei90/article/details/111303223</a></p><h2 id="Lucene数据模型"><a href="#Lucene数据模型" class="headerlink" title="Lucene数据模型"></a>Lucene数据模型</h2><p>Lucene中包含了四种基本数据类型，分别是：</p><ol><li><strong>Index</strong>：索引，由很多的Document组成。</li><li><strong>Document</strong>：由很多的Field组成，是Index和Search的最小单位。</li><li><strong>Field</strong>：由很多的Term组成，包括Field Name和Field Value。</li><li><strong>Term</strong>：由很多的字节组成。一般将Text类型的Field Value分词之后的每个最小单元叫做Term。</li></ol><p>在lucene中，<strong>读写路径是分离的</strong>。写入的时候创建一个IndexWriter，而读的时候会创建一个IndexSearcher。</p><p>下面是一个简单的代码示例，如何使用lucene的IndexWriter建索引以及如何使用indexSearch进行搜索查询。</p><pre class="line-numbers language-java"><code class="language-java">Analyzer analyzer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardAnalyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Store the index in memory:</span>    Directory directory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RAMDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// To store an index on disk, use this instead:</span>    <span class="token comment" spellcheck="true">//Directory directory = FSDirectory.open("/tmp/testindex");</span>    IndexWriterConfig config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexWriterConfig</span><span class="token punctuation">(</span>analyzer<span class="token punctuation">)</span><span class="token punctuation">;</span>    IndexWriter iwriter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexWriter</span><span class="token punctuation">(</span>directory<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>    Document doc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String text <span class="token operator">=</span> <span class="token string">"This is the text to be indexed."</span><span class="token punctuation">;</span>    doc<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Field</span><span class="token punctuation">(</span><span class="token string">"fieldname"</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> TextField<span class="token punctuation">.</span>TYPE_STORED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    iwriter<span class="token punctuation">.</span><span class="token function">addDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>    iwriter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Now search the index:</span>    DirectoryReader ireader <span class="token operator">=</span> DirectoryReader<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">;</span>    IndexSearcher isearcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexSearcher</span><span class="token punctuation">(</span>ireader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Parse a simple query that searches for "text":</span>    QueryParser parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryParser</span><span class="token punctuation">(</span><span class="token string">"fieldname"</span><span class="token punctuation">,</span> analyzer<span class="token punctuation">)</span><span class="token punctuation">;</span>    Query query <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ScoreDoc<span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> isearcher<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>query<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>scoreDocs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//assertEquals(1, hits.length);</span>    <span class="token comment" spellcheck="true">// Iterate through the results:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hits<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         Document hitDoc <span class="token operator">=</span> isearcher<span class="token punctuation">.</span><span class="token function">doc</span><span class="token punctuation">(</span>hits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hitDoc<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"fieldname"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ireader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    directory<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个示例中可以看出，lucene的读写有各自的操作类。本文重点关注读逻辑，在使用IndexSearcher类的时候，需要一个DirectoryReader和QueryParser：</p><ol><li>DirectoryReader需要对应写入时候的Directory实现。</li><li>QueryParser主要用来解析你的查询语句，例如你想查 “A and B”，lucene内部会有机制解析出是term A和term B的交集查询。</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-8.png" alt></p><ul><li>虚线箭头（a、b、c、d）表示<strong>写索引</strong>的主要过程</li><li>实线箭头（1-9）表示<strong>查询</strong>的主要过程</li></ul><p>Lucene 中的主要模块及模块说明如下：</p><ol><li>analysis：主要负责词法分析及语言处理，也就是我们常说的<strong>分词</strong>，通过该模块可最终形成存储或者搜索的最小单元 Term。</li><li>index 模块：主要负责<strong>索引的创建工作</strong>。</li><li>store 模块：主要负责<strong>索引的读写</strong>，主要是对文件的一些操作，其主要目的是抽象出和平台文件系统无关的存储。</li><li>queryParser 模块：主要负责<strong>语法分析</strong>，把我们的查询语句生成 Lucene 底层可以识别的条件。</li><li>search 模块：主要负责<strong>对索引的搜索工作</strong>。</li><li>similarity 模块：主要负责<strong>相关性打分和排序的实现</strong></li></ol><h2 id="Lucene-查询过程"><a href="#Lucene-查询过程" class="headerlink" title="Lucene 查询过程"></a>Lucene 查询过程</h2><p>在lucene中查询是基于segment。每个segment可以看做是一个独立的subindex，在建立索引的过程中，lucene会不断的flush内存中的数据持久化形成新的segment。多个segment也会不断的被merge成一个大的segment，在老的segment还有查询在读取的时候，不会被删除，没有被读取且被merge的segement会被删除。这个过程类似于LSM数据库的merge过程。下面我们主要看在一个segment内部如何实现高效的查询。</p><p>为了方便大家理解，我们以人名字，年龄，学号为例，如何实现查某个名字（有重名）的列表。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-1.jpg" alt></p><p>在lucene中为了查询 name=XXX 的这样一个条件，会建立基于name的倒排链。以上面的数据为例，倒排链如下：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-2.png" alt></p><p>如果我们还希望按照年龄查询，例如想查 年龄=18 的列表，我们还可以建立另一个倒排链：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-3.png" alt></p><p>在这里，Alice，Alan，18，这些都是term。所以<strong>倒排本质上就是基于term的反向列表</strong>，方便进行属性查找。到这里我们有个很自然的问题，如果term非常多，如何快速拿到这个倒排链呢？在lucene里面就引入了term dictonary的概念，也就是term的字典。term字典里我们可以按照term进行排序，那么用一个二分查找就可以定为这个term所在的地址。这样的复杂度是logN，在term很多，内存放不下的时候，效率还是需要进一步提升。可以用一个hashmap，当有一个term进入，hash继续查找倒排链。这里hashmap的方式可以看做是term dictionary的一个index。 从lucene4开始，为了方便实现rangequery或者前缀，后缀等复杂的查询语句，lucene使用FST数据结构来存储term字典，下面就详细介绍下FST的存储结构。</p><h2 id="FST"><a href="#FST" class="headerlink" title="FST"></a>FST</h2><p>我们就用Alice和Alan这两个单词为例，来看下FST的构造过程。首先对所有的单词做一下排序为“Alice”，“Alan”。</p><ol><li><p>插入“Alan”</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-4.png" alt></p></li><li><p>插入“Alice”</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-5.jpg" alt></p></li></ol><p>这样你就得到了一个<strong>有向无环图</strong>，有这样一个数据结构，就可以很快查找某个人名是否存在。FST在单term查询上可能相比hashmap并没有明显优势，甚至会慢一些。但是在范围，前缀搜索以及压缩率上都有明显的优势。</p><p>在通过FST定位到倒排链后，有一件事情需要做，就是倒排链的合并。因为查询条件可能不止一个，例如上面我们想找 name= “alan” and age = “18” 的列表。lucene是如何实现倒排链的合并呢。这里就需要看一下倒排链存储的数据结构</p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>为了能够快速查找docid，lucene采用了SkipList这一数据结构。SkipList有以下几个特征：</p><ol><li>元素排序的，对应到我们的倒排链，lucene是按照docid进行排序，从小到大。</li><li>跳跃有一个固定的间隔，这个是需要建立SkipList的时候指定好，例如下图以间隔是3</li><li>SkipList的层次，这个是指整个SkipList有几层</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-6.jpg" alt></p><p>有了这个SkipList以后比如我们要查找docid=12，原来可能需要一个个扫原始链表，1，2，3，5，7，8，10，12。有了SkipList以后先访问第一层看到是然后大于12，进入第0层走到3，8，发现15大于12，然后进入原链表的8继续向下经过10和12。</p><p>SkipList本质上是在有序的链表上实现实现二分查找，它能有效的提升链表的查找效率，其时间复杂度为O(logn)（其中n为链表长度）。简单说SkipList优化了Postings的随机查找的性能问题。</p><p>SkipList的节点存储了三部分数据：</p><ol><li>当前节点指向Block的信息，是关于Block本身的信息；</li><li>指向下层的索引；</li><li>存储freq和norm的信息，它被封装在Impact里面。</li></ol><p>Impact结构仅是 &lt;freq, norm&gt; 的键值对，与文档无关，在SkipList的索引节点中。Impacts表示一系列Impact结构，用有序的TreeSet存储。这里强调的是Impact并没有与具体文档关联，其次按freq和norm作为主键去重。也就是Impacts代表了该索引节点指向数据点以及之前所有数据节点所包含的文档得分的分布。</p><p>如果此索引节点中最大的Impact都小于Scorer的水位线，那么此节点的范围内的所有节点都不需要再进入Scorer评分程序，在TOP_SCORE模式下。</p><p>实际上SkipList的性能提升是通过在链表上加上多级索引获得的，所以说它属于<strong>空间换时间</strong>的做法，在索引时牺牲小量空间换取在搜索时的性能提升。而层级越高，索引的步长越短，构建索引的空间代价也会越高。这也解释了Lucene为什么要采用8个Block作为步长，虽然它的查询性能相比会差一些，但是需要的空间也缩减少n/8，是一种存储空间和性能的折中方案。</p><h2 id="倒排结构图解"><a href="#倒排结构图解" class="headerlink" title="倒排结构图解"></a>倒排结构图解</h2><p>有了FST和SkipList的介绍以后，我们大体上可以画一个下面的图来说明lucene是如何实现整个倒排结构的：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-7.jpg" alt></p><p>有了这张图，我们可以理解为什么基于lucene可以快速进行倒排链的查找和docid查找，下面就来看一下有了这些后如何进行倒排链合并返回最后的结果。</p><h2 id="倒排合并"><a href="#倒排合并" class="headerlink" title="倒排合并"></a>倒排合并</h2><p>假如我们的查询条件是name = “Alice”，那么按照之前的介绍，首先在term字典中定位是否存在这个term，如果存在的话进入这个term的倒排链，并根据参数设定返回分页返回结果即可。这类查询，在数据库中使用二级索引也是可以满足，那lucene的优势在哪呢。</p><p>假如我们有多个条件，例如我们需要按名字或者年龄单独查询，也需要进行组合 name = “Alice” and age = “18”的查询，那么使用传统二级索引方案，你可能需要建立两张索引表，然后分别查询结果后进行合并，这样如果age = 18的结果过多的话，查询合并会很耗时。那么在lucene这两个倒排链是怎么合并呢。</p><p>假如我们有下面三个倒排链需要进行合并。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-9.png" alt></p><p>在lucene中会采用下列顺序进行合并：</p><ol><li>在termA开始遍历，得到第一个元素docId=1</li><li>Set currentDocId=1</li><li>在termB中 search（currentDocId） = 1 （返回大于等于currentDocId的一个doc，这一步搜索时就会进行SkipList数据跳过）,<ol><li>因为currentDocId ==search结果1，继续</li><li>如果currentDocId 和search返回的不相等，则执行2，然后继续（执行2是什么意思。。。）</li></ol></li><li>到termC后搜索结果依然符合，返回结果</li><li>Set currentDocId = termC.nextItem = 2</li><li>然后继续步骤3 依次循环。直到某个倒排链到末尾。</li></ol><blockquote><p>这里有点看不明白，留个坑</p></blockquote><p>整个合并步骤我可以发现，如果某个链很短，会大幅减少比对次数，并且由于SkipList结构的存在，在某个倒排中定位某个docid的速度会比较快不需要一个个遍历（该例子所需的时间比完整遍历三个posting list要快得多，但是前提是每个list需要使用SkipList独有的Advance操作）。可以很快的返回最终的结果。从倒排的定位，查询，合并整个流程组成了lucene的查询过程，和传统数据库的索引相比，lucene合并过程中的优化减少了读取数据的IO，倒排合并的灵活性也解决了传统索引较难支持多条件查询的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="elasticsearch" scheme="https://arthurjq.com/tags/elasticsearch/"/>
    
      <category term="lucene" scheme="https://arthurjq.com/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 集群架构学习</title>
    <link href="https://arthurjq.com/2021/02/25/database/es/"/>
    <id>https://arthurjq.com/2021/02/25/database/es/</id>
    <published>2021-02-25T02:30:05.000Z</published>
    <updated>2021-02-26T03:29:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-集群架构"><a href="#Elasticsearch-集群架构" class="headerlink" title="Elasticsearch 集群架构"></a>Elasticsearch 集群架构</h2><p>Elasticsearch是一个非常著名的开源搜索和分析系统，目前被广泛应用于互联网多种领域中，尤其是以下三个领域特别突出。</p><ol><li>搜索领域，相对于solr，真正的后起之秀，成为很多搜索系统的不二之选。</li><li>Json文档数据库，相对于MongoDB，读写性能更佳，而且支持更丰富的地理位置查询以及数字、文本的混合查询等。</li><li>时序数据分析处理，目前是日志处理、监控数据的存储、分析和可视化方面做得非常好，可以说是该领域的引领者了。</li></ol><p><strong>转载至阿里云</strong>：<a href="https://zhuanlan.zhihu.com/p/32990496" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32990496</a></p><p>Elasticsearch的详细介绍可以到<a href="https://link.zhihu.com/?target=https%3A//www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">官网</a>查看。我们先来看一下Elasticsearch中几个关键概念：</p><ol><li><strong>节点</strong>（Node）：物理概念，一个运行的Elasticearch实例，一般是一台机器上的一个进程。</li><li><strong>索引</strong>（Index），逻辑概念，包括配置信息mapping和倒排正排数据文件，一个索引的数据文件可能会分布于一台机器，也有可能分布于多台机器。索引的另外一层意思是倒排索引文件。</li><li><strong>分片</strong>（Shard）：为了支持更大量的数据，索引一般会按某个维度分成多个部分，每个部分就是一个分片，分片被节点（Node）管理。一个节点一般会管理多个分片，这些分片可能是属于同一份索引，也有可能属于不同索引，但是为了可靠性和可用性，同一个索引的分片尽量会分布在不同节点上。分片有两种，主分片和副本分片。</li><li><strong>副本</strong>（Replica）：同一个分片（Shard）的备份数据，一个分片可能会有0个或多个副本，这些副本中的数据保证强一致或最终一致。</li></ol><p>用图形表示出来可能是这样子的：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-1.png" alt></p><ol><li>Index 1：蓝色部分，有3个shard，分别是P1，P2，P3，位于3个不同的Node中，这里没有Replica。</li><li>Index 2：绿色部分，有2个shard，分别是P1，P2，位于2个不同的Node中。并且每个shard有一个replica，分别是R1和R2。基于系统可用性的考虑，同一个shard的 primary 和 replica 不能位于同一个Node中。这里Shard1的P1和R1分别位于Node3和Node2中，如果某一刻Node2发生宕机，服务基本不会受影响，因为还有一个P1和R2都还是可用的。因为是主备架构，当主分片发生故障时，需要切换，这时候需要选举一个副本作为新主，这里除了会耗费一点点时间外，也会有丢失数据的风险。</li></ol><h2 id="建Index流程"><a href="#建Index流程" class="headerlink" title="建Index流程"></a>建Index流程</h2><p>建索引（Index）的时候，一个Doc先是经过路由规则定位到主Shard，发送这个doc到主Shard上建索引，成功后再发送这个Doc到这个Shard的副本上建索引，等副本上建索引成功后才返回成功。</p><p>在这种架构中，索引数据全部位于Shard中，主Shard和副本Shard各存储一份。当某个副本Shard或者主Shard丢失（比如机器宕机，网络中断等）时，需要将丢失的Shard在其他Node中恢复回来，这时候就需要从其他副本（Replica）全量拷贝这个Shard的所有数据到新Node上构造新Shard。这个拷贝过程需要一段时间，这段时间内只能由剩余主副本来承载流量，在恢复完成之前，整个系统会处于一个比较危险的状态，直到failover结束。</p><p>这里就体现了副本（Replica）存在的一个理由，<strong>避免数据丢失，提高数据可靠性</strong>。副本（Replica）存在的另一个理由是读请求量很大的时候，一个Node无法承载所有流量，这个时候就需要一个副本来分流查询压力，目的就是<strong>扩展查询能力</strong>。</p><h2 id="角色部署方式"><a href="#角色部署方式" class="headerlink" title="角色部署方式"></a>角色部署方式</h2><p>看看角色分工的两种不同方式：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-2.jpg" alt></p><p>Elasticsearch支持上述两种方式：</p><p><strong>混合部署</strong>（左图）：</p><ul><li><ol><li>默认方式。</li><li>不考虑 MasterNode 的情况下，还有两种Node，<strong>Data Node 和 Transport Node</strong> ，这种部署模式下，这两种不同类型Node角色都位于同一个Node中，相当于一个Node具备两种功能：Data和Transport。</li><li>当有index或者query请求的时候，请求随机（自定义）发送给任何一个Node，这台<strong>Node中会持有一个全局的路由表</strong>，通过路由表选择合适的Node，将请求发送给这些Node，然后等所有请求都返回后，合并结果，然后返回给用户。一个Node分饰两种角色。</li><li>好处就是使用极其<strong>简单</strong>，易上手，对推广系统有很大价值。最简单的场景下只需要启动一个Node，就能完成所有的功能。</li><li>缺点就是<strong>多种类型的请求会相互影响</strong>，在大集群如果某一个 Data Node 出现热点，那么就会影响途经这个Data Node的所有其他跨Node请求。如果发生故障，故障影响面会变大很多。</li><li>Elasticsearch中每个Node都需要和其余的每一个Node都保持13个连接。这种情况下，每个Node都需要和其他所有Node保持连接，而一个系统的连接数是有上限的，这样连接数就会限制集群规模。</li><li>还有就是<strong>不能支持集群的热更新</strong>。</li></ol></li></ul><p><strong>分层部署</strong>（右图）：</p><ul><li><ol><li>通过配置可以隔离开Node。</li><li>设置部分Node为Transport Node，<strong>专门用来做请求转发和结果合并</strong>。</li><li>其他Node可以设置为DataNode，<strong>专门用来处理数据</strong>。</li><li>缺点是上手复杂，需要提前设置好Transport的数量，且数量和Data Node、流量等相关，否则要么资源闲置，要么机器被打爆。</li><li>好处就是<strong>角色相互独立</strong>，不会相互影响，一般Transport Node的流量是平均分配的，很少出现单台机器的CPU或流量被打满的情况，而DataNode由于处理数据，很容易出现单机资源被占满，比如CPU，网络，磁盘等。独立开后，DataNode如果出了故障只是影响单节点的数据处理，不会影响其他节点的请求，影响限制在最小的范围内。</li><li>角色独立后，只需要Transport Node连接所有的DataNode，而DataNode则不需要和其他DataNode有连接。一个集群中DataNode的数量远大于Transport Node，这样集群的规模可以更大。另外，还可以通过分组，使Transport Node只连接固定分组的DataNode，这样Elasticsearch的连接数问题就彻底解决了。</li><li>可以<strong>支持热更新</strong>：先一台一台的升级DataNode，升级完成后再升级Transport Node，整个过程中，可以做到让用户无感知。</li></ol></li></ul><h2 id="Elasticsearch-数据层架构"><a href="#Elasticsearch-数据层架构" class="headerlink" title="Elasticsearch 数据层架构"></a>Elasticsearch 数据层架构</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>Elasticsearch的Index和meta，目前支持存储在本地文件系统中，同时支持niofs，mmap，simplefs，smb等不同加载方式，性能最好的是直接将索引LOCK进内存的MMap方式。默认，Elasticsearch会自动选择加载方式，另外可以自己在配置文件中配置。这里有几个细节，具体可以看官方文档。</p><p>索引和meta数据都存在本地，会带来一个问题：当某一台机器宕机或者磁盘损坏的时候，数据就丢失了。为了解决这个问题，可以使用Replica（副本）功能。</p><h3 id="副本（Replica）"><a href="#副本（Replica）" class="headerlink" title="副本（Replica）"></a>副本（Replica）</h3><p>可以为每一个Index设置一个配置项：副本（Replicda）数，如果设置副本数为2，那么就会有3个Shard，其中一个是PrimaryShard，其余两个是ReplicaShard，这三个Shard会被Mater尽量调度到不同机器，甚至机架上，这三个Shard中的数据一样，提供同样的服务能力。</p><p>副本（Replica）的目的有三个：</p><ol><li><strong>保证服务可用性</strong>：当设置了多个Replica的时候，如果某一个Replica不可用的时候，那么请求流量可以继续发往其他Replica，服务可以很快恢复开始服务。</li><li><strong>保证数据可靠性</strong>：如果只有一个Primary，没有Replica，那么当Primary的机器磁盘损坏的时候，那么这个Node中所有Shard的数据会丢失，只能reindex了。</li><li><strong>提供更大的查询能力</strong>：当Shard提供的查询能力无法满足业务需求的时候， 可以继续加N个Replica，这样查询能力就能提高N倍，轻松增加系统的并发度。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上面说了一些优势，这种架构同样在一些场景下会有些问题。</p><p>Elasticsearch采用的是基于本地文件系统，使用Replica保证数据可靠性的技术架构，这种架构一定程度上可以满足大部分需求和场景，但是也存在一些遗憾：</p><ol><li>Replica带来<strong>成本浪费</strong>。为了保证数据可靠性，必须使用Replica，但是当一个Shard就能满足处理能力的时候，另一个Shard的计算能力就会浪费。</li><li>Replica带来<strong>写性能和吞吐的下降</strong>。每次Index或者update的时候，需要先更新Primary Shard，更新成功后再并行去更新Replica，再加上长尾，写入性能会有不少的下降。</li><li>当出现热点或者需要紧急扩容的时候<strong>动态增加Replica慢</strong>。新Shard的数据需要完全从其他Shard拷贝，拷贝时间较长。</li></ol><p>上面介绍了Elasticsearch数据层的架构，以及副本策略带来的优势和不足，下面简单介绍了几种不同形式的分布式数据系统架构。</p><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="第一种：基于本地文件系统的分布式系统"><a href="#第一种：基于本地文件系统的分布式系统" class="headerlink" title="第一种：基于本地文件系统的分布式系统"></a>第一种：基于本地文件系统的分布式系统</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-3.jpg" alt></p><p>上图中是一个基于本地磁盘存储数据的分布式系统。Index一共有3个Shard，每个Shard除了Primary Shard外，还有一个Replica Shard。当Node 3机器宕机或磁盘损坏的时候，首先确认P3已经不可用，重新选举R3位Primary Shard，此Shard发生主备切换。然后重新找一台机器Node 7，在Node7 上重新启动P3的新Replica。由于数据都会存在本地磁盘，此时需要将Shard 3的数据从Node 6上拷贝到Node7上。如果有200G数据，千兆网络，拷贝完需要1600秒。如果没有replica，则这1600秒内这些Shard就不能服务。</p><p>为了保证可靠性，就需要冗余Shard，会导致更多的物理资源消耗。</p><p>这种思想的另外一种表现形式是<strong>使用双集群</strong>，集群级别做备份。</p><p>在这种架构中，如果你的数据是在其他存储系统中生成的，比如HDFS/HBase，那么你还需要一个数据传输系统，将准备好的数据分发到相应的机器上。</p><p>这种架构中为了保证可用性和可靠性，需要双集群或者Replica才能用于生产环境，优势和副作用在上面介绍Elasticsearch的时候已经介绍过了，这里就就不赘述了。</p><p>Elasticsearch使用的就是这种架构方式。</p><h3 id="第二种：基于分布式文件系统的分布式系统（共享存储）"><a href="#第二种：基于分布式文件系统的分布式系统（共享存储）" class="headerlink" title="第二种：基于分布式文件系统的分布式系统（共享存储）"></a>第二种：基于分布式文件系统的分布式系统（共享存储）</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-4.png" alt></p><p>针对第一种架构中的问题，另一种思路是：<strong>存储和计算分离</strong>。</p><p>第一种思路的问题根源是数据量大，拷贝数据耗时多，那么有没有办法可以不拷贝数据？为了实现这个目的，一种思路是底层存储层使用共享存储，每个Shard只需要连接到一个分布式文件系统中的一个目录/文件即可，Shard中不含有数据，只含有计算部分。相当于每个Node中只负责计算部分，存储部分放在底层的另一个分布式文件系统中，比如<strong>HDFS</strong>。</p><p>上图中，Node 1 连接到第一个文件；Node 2连接到第二个文件；Node3连接到第三个文件。当Node 3机器宕机后，只需要在Node 4机器上新建一个空的Shard，然后构造一个新连接，连接到底层分布式文件系统的第三个文件即可，创建连接的速度是很快的，总耗时会非常短。</p><p>这种是一种典型的存储和计算分离的架构，优势有以下几个方面：</p><ol><li>在这种架构下，资源可以更加弹性，当存储不够的时候只需要扩容存储系统的容量；当计算不够的时候，只需要扩容计算部分容量。</li><li>存储和计算是独立管理的，资源管理粒度更小，管理更加精细化，浪费更少，结果就是总体成本可以更低。</li><li>负载更加突出，抗热点能力更强。一般热点问题基本都出现在计算部分，对于存储和计算分离系统，计算部分由于没有绑定数据，可以实时的扩容、缩容和迁移，当出现热点的时候，可以第一时间将计算调度到新节点上。</li></ol><p>这种架构同时也有一个不足：</p><p><strong>访问分布式文件系统的性能可能不及访问本地文件系统</strong>。在上一代分布式文件系统中，这是一个比较明显的问题，但是目前使用了各种用户态协议栈后，这个差距已经越来越小了。</p><p>HBase使用的就是这种架构方式。</p><p>Solr也支持这种形式的架构。</p><h2 id="Lucene数据模型"><a href="#Lucene数据模型" class="headerlink" title="Lucene数据模型"></a>Lucene数据模型</h2><p>Lucene中包含了四种基本数据类型，分别是：</p><ol><li>Index：索引，由很多的Document组成。</li><li>Document：由很多的Field组成，是Index和Search的最小单位。</li><li>Field：由很多的Term组成，包括Field Name和Field Value。</li><li>Term：由很多的字节组成，可以分词。</li></ol><p>上述四种类型在Elasticsearch中同样存在，意思也一样。</p><p>Lucene中存储的索引主要分为三种类型：</p><ol><li>Invert Index：<strong>倒排索引</strong>，或者简称Index，<strong>通过Term可以查询到拥有该Term的文档</strong>。可以配置为是否分词，如果分词可以配置不同的分词器。索引存储的时候有多种存储类型，分别是：<ol><li>DOCS：只存储DocID。</li><li>DOCS_AND_FREQS：存储DocID和词频（Term Freq）。</li><li>DOCS_AND_FREQS_AND_POSITIONS：存储DocID、词频（Term Freq）和位置。</li><li>DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS：存储DocID、词频（Term Freq）、位置和偏移。</li></ol></li><li>DocValues：正排索引，采用列式存储。<strong>通过DocID可以快速读取到该Doc的特定字段的值</strong>。由于是列式存储，性能会比较好。一般用于sort，agg等需要高频读取Doc字段值的场景。</li><li>Store：字段原始内容存储，同一篇文章的多个Field的Store会存储在一起，适用于一次读取少量且多个字段内存的场景，比如摘要等。</li></ol><p>Lucene中提供索引和搜索的最小组织形式是Segment，Segment中按照索引类型不同，分成了Invert Index，Doc Values和Store这三大类（还有一些辅助类，这里省略），每一类里面都是按照Doc为最小单位存储。</p><ol><li>Invert Index中存储的Key是Term，Value是Doc ID的链表；</li><li>Doc Value中Key 是Doc ID和Field Name，Value是Field Value；</li><li>Store的Key是Doc ID，Value是Filed Name和Filed Value。</li></ol><p>由于Lucene中没有主键概念和更新逻辑，所有对Lucene的更新都是Append一个新Doc，类似于一个只能Append的队列，所有Doc都被同等对等，同样的处理方式。其中的Doc由众多Field组成，没有特殊Field，每个Field也都被同等对待，同样的处理方式。</p><p>从上面介绍来看，Lucene只是提供了一个索引和查询的最基本的功能，距离一个完全可用的完整搜索引擎还有一些距离</p><h2 id="Lucene-gt-Elasticsearch"><a href="#Lucene-gt-Elasticsearch" class="headerlink" title="Lucene =&gt; Elasticsearch"></a>Lucene =&gt; Elasticsearch</h2><p>在Elasticsearch中，为了支持分布式，增加了一个系统字段<code>_routing</code>（路由），通过<code>_routing</code>将Doc分发到不同的Shard，不同的Shard可以位于不同的机器上，这样就能实现简单的分布式了。</p><p>采用类似的方式，Elasticsearch增加了<code>_id、_version、_source和_seq_no</code>等等多个系统字段，通过这些Elasticsearch中特有的系统字段可以有效解决上述的几个问题，新增的系统字段主要是下列几个：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-5.jpg" alt></p><h3 id="1-id"><a href="#1-id" class="headerlink" title="1. _id"></a>1. _id</h3><p><strong>Doc的主键</strong>，在写入的时候，可以指定该Doc的ID值，<strong>如果不指定，则系统自动生成一个唯一的UUID</strong>值。</p><p>Lucene中没有主键索引，要保证系统中同一个Doc不会重复，Elasticsearch引入了<code>_id</code>字段来实现主键。每次写入的时候都会先查询id，如果有，则说明已经有相同Doc存在了。</p><p>通过<code>_id</code>值（ES内部转换成_uid）可以唯一在Elasticsearch中确定一个Doc。</p><p>Elasticsearch中，<code>_id</code>只是一个用户级别的虚拟字段，在Elasticsearch中并不会映射到Lucene中，所以也就不会存储该字段的值。</p><p><code>_id</code>的值可以由<code>_uid</code>解析而来（<code>_uid =type + &#39;#&#39; + id</code>），Elasticsearch中会存储<code>_uid</code>。</p><h3 id="2-uid"><a href="#2-uid" class="headerlink" title="2. _uid"></a>2. _uid</h3><p>_uid的格式是：<code>type + &#39;#&#39; + id</code>。</p><p>_uid会存储在Lucene中，在Lucene中的映射关系如下：dex下可能存在多个id值相同的Doc，而6.0.0之后只支持单Type，同Index下id值是唯一的。</p><p>uid会存储在Lucene中，在Lucene中的映射关系如下：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-6.png" alt></p><p><code>_uid</code> <strong>只是存储了倒排Index和原文store</strong>：倒排Index的目的是可以通过<code>_id</code>快速查询到文档；原文store用来在返回的Response里面填充完整的<code>_id</code>值。</p><p>在Lucene中存储<code>_uid</code>，而不是<code>_id</code>的原因是，在6.0.0之前版本里面，<code>_uid</code>可以比<code>_id</code>表示更多的信息，比如Type。在6.0.0版本之后，同一个Index只能有一个Type，这时候Type就没多大意义了，后面Type应该会消失，那时候<code>_id</code>就会和<code>_uid</code>概念一样，到时候两者会合二为一，也能简化大家的理解。</p><h3 id="3-version"><a href="#3-version" class="headerlink" title="3. _version"></a>3. _version</h3><p>Elasticsearch中每个Doc都会有一个Version，该Version可以由用户指定，也可以由系统自动生成。如果是系统自动生成，那么每次Version都是递增1。</p><p><code>_version</code>是实时的，不受搜索的近实时性影响，原因是可以通过<code>_uid</code>从内存中versionMap或者TransLog中读取到。</p><p>Version在Lucene中也是映射为一个特殊的Field存在。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-7.png" alt></p><p>Elasticsearch中Version字段的主要目的是<strong>通过doc_id读取Version</strong>，所以Version只要存储为DocValues就可以了，类似于KeyValue存储。</p><p>Elasticsearch通过使用version来<strong>保证对文档的变更能以正确的顺序执行</strong>，避免乱序造成的数据丢失。</p><h3 id="4-source"><a href="#4-source" class="headerlink" title="4. _source"></a>4. _source</h3><p>Elasticsearch中有一个重要的概念是source，<strong>存储原始文档</strong>，也可以通过过滤设置只存储特定Field。</p><p>Source在Lucene中也是映射为了一个特殊的Field存在：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-8.png" alt></p><p>Elasticsearch中_source字段的主要目的是通过doc_id读取该文档的原始内容，所以只需要存储Store即可。</p><p><code>_source</code>其实是名为<code>_source</code>的虚拟Store Field。</p><p>Elasticsearch中使用_source字段可以实现以下功能：</p><ol><li>Update：部分更新时，需要从读取文档保存在<code>_source</code>字段中的原文，然后和请求中的部分字段合并为一个完整文档。如果没有<code>_source</code>，则不能完成部分字段的Update操作。</li><li>Rebuild：最新的版本中新增了rebuild接口，可以通过Rebuild API完成索引重建，过程中不需要从其他系统导入全量数据，而是从当前文档的<code>_source</code>中读取。如果没有<code>_source</code>，则不能使用Rebuild API。</li><li>Script：不管是Index还是Search的Script，都可能用到存储在Store中的原始内容，如果禁用了<code>_source</code>，则这部分功能不再可用。</li><li>Summary：摘要信息也是来源于<code>_source</code>字段。</li></ol><h3 id="5-seq-no"><a href="#5-seq-no" class="headerlink" title="5. _seq_no"></a>5. _seq_no</h3><p><strong>严格递增的顺序号</strong>，每个文档一个，Shard级别严格递增，保证后写入的Doc的<code>_seq_no</code>大于先写入的Doc的<code>_seq_no</code>。</p><p>任何类型的写操作，包括index、create、update和Delete，都会生成一个<code>_seq_no</code>。</p><p><code>_seq_no</code>在Primary Node中由SequenceNumbersService生成，但其实真正产生这个值的是LocalCheckpointTracker，每次递增1：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * The next available sequence number.     */</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> nextSeqNo<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Issue the next sequence number.     *     * @return the next assigned sequence number     */</span>    <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">generateSeqNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextSeqNo<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个文档在使用Lucene的document操作接口之前，会获取到一个<code>_seq_no</code>，这个<code>_seq_no</code>会以系统保留Field的名义存储到Lucene中，文档写入Lucene成功后，会标记该seq_no为完成状态，这时候会使用当前seq_no更新local_checkpoint。</p><p>checkpoint分为 local_checkpoint 和 global_checkpoint ，主要是用于保证有序性，以及减少Shard恢复时数据拷贝的数据拷贝量，更详细的介绍可以看这篇文章：<a href="https://link.zhihu.com/?target=https%3A//www.elastic.co/blog/elasticsearch-sequence-ids-6-0" target="_blank" rel="noopener">Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You</a>。</p><p><code>_seq_no</code>在Lucene中的映射：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-9.png" alt></p><p>Elasticsearch中<code>_seq_no</code>的作用有两个：</p><ol><li>通过doc_id查询到该文档的seq_no，</li><li>通过seq_no范围查找相关文档，所以也就需要存储为Index和DocValues（或者Store）。</li></ol><p>由于是在冲突检测时才需要读取文档的<code>_seq_no</code>，而且此时只需要读取<code>_seq_no</code>，不需要其他字段，这时候存储为列式存储的DocValues比Store在性能上更好一些。</p><p><code>_seq_no</code>是严格递增的，写入Lucene的顺序也是递增的，所以DocValues存储类型可以设置为Sorted。</p><p>另外，<code>_seq_no</code>的索引应该仅需要支持存储DocId就可以了，不需要FREQS、POSITIONS和分词。如果多存储了这些，对功能也没影响，就是多占了一点资源而已。</p><h3 id="6-primary-term"><a href="#6-primary-term" class="headerlink" title="6. _primary_term"></a>6. _primary_term</h3><p><code>_primary_term</code>也和<code>_seq_no</code>一样是一个整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，<code>_primary_term</code>会递增1。</p><p><code>_primary_term</code>主要是用来恢复数据时处理当多个文档的<code>_seq_no</code>一样时的冲突，避免Primary Shard上的写入被覆盖。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-10.png" alt></p><p>Elasticsearch中<code>_primary_term</code>只需要通过doc_id读取到即可，所以只需要保存为DocValues就可以了</p><h3 id="7-routing"><a href="#7-routing" class="headerlink" title="7. _routing"></a>7. _routing</h3><p><strong>路由规则</strong>，写入和查询的routing需要一致，否则会出现写入的文档没法被查到情况。</p><p>在mapping中，或者Request中可以指定按某个字段路由。默认是按照<code>_Id</code>值路由。</p><p><code>_routing</code>在Lucene中映射为：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-11.png" alt></p><p>Elasticsearch中文档级别的<code>_routing</code>主要有两个目的：</p><ol><li>可以查询到使用某种<code>_routing</code>的文档有哪些，当发生<code>_routing</code>变化时，可以对历史<code>_routing</code>的文档重新读取再Index，这个需要倒排Index。</li><li>查询到文档后，在Response里面展示该文档使用的<code>_routing</code>规则，这里需要存储为Store。</li></ol><h3 id="8-field-names"><a href="#8-field-names" class="headerlink" title="8. _field_names"></a>8. _field_names</h3><p>该字段会索引某个Field的名称，用来<strong>判断某个Doc中是否存在某个Field</strong>，用于exists或者missing请求。</p><p><code>_field_names</code>在Lucene中的映射：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/es-12.png" alt></p><p>Elasticsearch中<code>_field_names</code>的目的是查询哪些Doc的这个Field是否存在，所以<strong>只需要倒排Index</strong>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch-集群架构&quot;&gt;&lt;a href=&quot;#Elasticsearch-集群架构&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 集群架构&quot;&gt;&lt;/a&gt;Elasticsearch 集群架构&lt;/h2&gt;&lt;p&gt;Elasti
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="elasticsearch" scheme="https://arthurjq.com/tags/elasticsearch/"/>
    
      <category term="分布式系统" scheme="https://arthurjq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="lucene" scheme="https://arthurjq.com/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的原理和分布式锁</title>
    <link href="https://arthurjq.com/2021/02/24/project/zookeeper/"/>
    <id>https://arthurjq.com/2021/02/24/project/zookeeper/</id>
    <published>2021-02-24T06:56:18.000Z</published>
    <updated>2021-02-25T15:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h2><p>Zookeeper是一个高性能的分布式一致系统，在分布式系统中有着广泛的应用。基于它，可以实现分布式同步、配置管理、命名空间管理等众多功能，是分布式系统中常见的基础系统。</p><p>Zookeeper主要用来解决分布式集群中应用系统的一致性问题，它有着树状结构的节点，每个节点均可存储少量的数据。同时，用户可以修改和订阅节点中的内容。分布式系统中的节点通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</p><p>从设计模式角度来看，Zookeeper是基于观察者模式实现的。可以把它作为一个信息的中心。使用该服务的生产者和消费者都以Zookeeper中的数据为基准。即：</p><ol><li>生产者可以改变Zookeeper的节点，或者节点上的数据</li><li>消费者通过订阅Zookeeper节点，从而能够在节点变动时收到通知</li></ol><p>基于这样的机制，将Zookeeper作为信息中心，便可以实现分布式系统中节点状态的最终一致性。</p><p><strong>Zookeeper具有以下特点</strong>：</p><ol><li>最终一致性：客户端不论连接到哪个Zookeeper的哪一个节点，都会收到同一份状态。这是zookeeper最重要的性能。</li><li>可靠性：Zookeeper集群具有简单、健壮、良好的性能，如果消息m被到一台server接受，那么它将被所有的server接受。</li><li>实时性：Zookeeper保证client将在一个时间间隔范围内获得server的更新信息，或者server失效的信息。但由于网络延时等原因，Zookeeper不能保证两个client能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li><li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li><li>原子性：更新只能成功或者失败，没有中间状态。</li><li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台server上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li></ol><h2 id="zookeeper应用场景"><a href="#zookeeper应用场景" class="headerlink" title="zookeeper应用场景"></a>zookeeper应用场景</h2><ol><li><p><strong>数据发布与订阅</strong>：应用配置集中到节点上，应用启动时主动获取，并在节点上注册一个watcher，每次配置更新都会通知到应用。</p></li><li><p><strong>名空间服务</strong>：分布式命名服务，创建一个节点后，节点的路径就是全局唯一的，可以作为全局名称使用。</p></li><li><p><strong>分布式通知/协调</strong>：不同的系统都监听同一个节点，一旦有了更新，另一个系统能够收到通知。</p></li><li><p><strong>分布式锁</strong>：Zookeeper能<strong>保证数据的强一致性</strong>，用户任何时候都可以相信集群中每个节点的数据都是相同的。一个用户创建一个节点作为锁，另一个用户检测该节点，如果存在，代表别的用户已经锁住，如果不存在，则可以创建一个节点，代表拥有一个锁。</p></li><li><p><strong>集群管理</strong>：每个加入集群的机器都创建一个节点，写入自己的状态。监控父节点的用户会受到通知，进行相应的处理。离开时删除节点，监控父节点的用户同样会收到通知。如图：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/zookeeper-1.jpg" alt></p></li><li><p><strong>配置管理</strong>：在分布式应用环境中很常见，例如同一个应用系统需要多台节点运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。像这样的配置信息完全可以交给 Zookeeper 来管理，<strong>将配置信息保存在 Zookeeper 的某个目录节点</strong>中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。如图：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/zookeeper-2.jpg" alt></p></li></ol><h2 id="分布式锁的流程"><a href="#分布式锁的流程" class="headerlink" title="分布式锁的流程"></a>分布式锁的流程</h2><p>分布式锁的应用上面已经讲到了，具体流程如下：</p><p>假如说有n个分布式的工作点，定义为a1,a2,a3,a4……</p><p>当某个分布式点做一件事时，先去zk某个固定位置判断（例如：/aTask/sync目录下）是否存在一个特定节点（例如节点名：lock）:</p><ol><li>如果没有，则创建该节点，即声明自己持有该锁。然后进行分布式任务，任务结束后。去删除该节点，表明释放该锁。</li><li>如果有，表明其他工作点持有了锁，不能开展分布式任务。</li></ol><h2 id="分布式锁的应用"><a href="#分布式锁的应用" class="headerlink" title="分布式锁的应用"></a>分布式锁的应用</h2><p>举一个最简单的例子：</p><p>1、假如有一个系统，能够提供报表查看功能——&gt;于是我们开发了一个单节点应用</p><p>2、该系统访量非常大，系统难以支撑——&gt;我们部署了多个节点（加入为5个），分担访问请求。于是成了分布式应用</p><p>3、老板要求增加一个每天晚上向指定邮件发送该日统计报表的功能—–&gt;应用中增加个定时线程，每天晚上半夜跑报表，发邮件</p><p>这个时候，出问题了，老板每天晚上会收到5封邮件！因为同样的程序我们部署了5个节点！怎么解决呢？</p><p><strong>方案一</strong>：有一个节点和其他节点不一样，具有每日汇总功能。</p><p>优点：开发简单。</p><p>缺点：这样，一个应用便成了两个应用。我们必须维护两份代码。一份是不具有每日汇总功能的，一份是具有每日汇总功能的。</p><p><strong>方案二</strong>：增加分布式锁。这样，5个节点中，只有获取到锁的节点才会发出邮件。</p><p>优点：代码还是只有一份，维护简单。扩展性强，可以继续扩展类似的需要锁的功能（例如某个业务流程只允许处理一次，还可以继续复用相关逻辑）。</p><p>缺点：开发稍微复杂一点。</p><p>因此，方案二是最好的选择。</p><h2 id="基于ZooKeeper的三种分布式锁实现"><a href="#基于ZooKeeper的三种分布式锁实现" class="headerlink" title="基于ZooKeeper的三种分布式锁实现"></a>基于ZooKeeper的三种分布式锁实现</h2><p><a href="https://www.cnblogs.com/codestory/p/11387116.html" target="_blank" rel="noopener">https://www.cnblogs.com/codestory/p/11387116.html</a></p><h2 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 版本信息：3.5.8</span><span class="token comment" spellcheck="true"># 路径：/home/rndii/projects/zookeeper/apache-zookeeper-3.5.8</span><span class="token comment" spellcheck="true"># 服务器节点：10.0.1.104   10.0.1.117    10.0.1.127</span><span class="token comment" spellcheck="true"># 操作系统用户：rndii</span><span class="token comment" spellcheck="true"># 1.修改zoo.conf文件，如果该文件不存在，则cp zoo.simple.cnf zoo.cnf</span><span class="token comment" spellcheck="true"># zoo.cnf 如下修改：</span><span class="token comment" spellcheck="true"># The number of milliseconds of each tick</span>tickTime<span class="token operator">=</span>2000<span class="token comment" spellcheck="true"># The number of ticks that the initial </span><span class="token comment" spellcheck="true"># synchronization phase can take</span>initLimit<span class="token operator">=</span>10<span class="token comment" spellcheck="true"># The number of ticks that can pass between </span><span class="token comment" spellcheck="true"># sending a request and getting an acknowledgement</span>syncLimit<span class="token operator">=</span>5<span class="token comment" spellcheck="true"># the directory where the snapshot is stored.</span><span class="token comment" spellcheck="true"># do not use /tmp for storage, /tmp here is just </span><span class="token comment" spellcheck="true"># example sakes.</span>dataDir<span class="token operator">=</span>/home/rndii/projects/zookeeper/apache-zookeeper-3.5.8/data<span class="token comment" spellcheck="true"># the port at which the clients will connect</span>clientPort<span class="token operator">=</span>2181<span class="token comment" spellcheck="true"># the maximum number of client connections.</span><span class="token comment" spellcheck="true"># increase this if you need to handle more clients</span><span class="token comment" spellcheck="true">#maxClientCnxns=60</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Be sure to read the maintenance section of the </span><span class="token comment" spellcheck="true"># administrator guide before turning on autopurge.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The number of snapshots to retain in dataDir</span><span class="token comment" spellcheck="true">#autopurge.snapRetainCount=3</span><span class="token comment" spellcheck="true"># Purge task interval in hours</span><span class="token comment" spellcheck="true"># Set to "0" to disable auto purge feature</span><span class="token comment" spellcheck="true">#autopurge.purgeInterval=1</span>server.1<span class="token operator">=</span>10.0.1.104:2888:3888server.2<span class="token operator">=</span>10.0.1.117:2888:3888server.3<span class="token operator">=</span>10.0.1.127:2888:3888<span class="token comment" spellcheck="true"># 配置文件到此结束</span><span class="token comment" spellcheck="true"># 2.在data文件夹中新增myid文本文件，内容为对应ip的节点id。对应zoo.cnf下的server.x=10.0.1.104:2888:3888的x</span><span class="token comment" spellcheck="true"># 3.如果未配置全局环境变量可修改zoo下的bin/zkServer.sh文件增加JAVA_HOME=xx</span><span class="token comment" spellcheck="true"># 4. 常规命令</span><span class="token comment" spellcheck="true"># 启动</span>bin/zkServer.sh start<span class="token comment" spellcheck="true"># 停止</span>bin/zkServer.sh stop<span class="token comment" spellcheck="true"># 查看zookeeper的状态</span>bin/zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Zookeeper介绍&quot;&gt;&lt;a href=&quot;#Zookeeper介绍&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper介绍&quot;&gt;&lt;/a&gt;Zookeeper介绍&lt;/h2&gt;&lt;p&gt;Zookeeper是一个高性能的分布式一致系统，在分布式系统中有着广
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="lock" scheme="https://arthurjq.com/tags/lock/"/>
    
      <category term="zookeeper" scheme="https://arthurjq.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="https://arthurjq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>RefreshScope注解和Spring bean scope</title>
    <link href="https://arthurjq.com/2021/02/23/java/refreshscope/"/>
    <id>https://arthurjq.com/2021/02/23/java/refreshscope/</id>
    <published>2021-02-23T10:01:53.000Z</published>
    <updated>2021-03-11T06:30:18.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-bean-scope详解"><a href="#Spring-bean-scope详解" class="headerlink" title="Spring bean scope详解"></a>Spring bean scope详解</h2><p>Scope是定义Spring如何创建bean的实例的。@Scope 代表了Bean的作用域</p><p>在创建bean的时候可以带上scope属性，scope有下面几种类型。</p><ol><li><strong>Singleton</strong>：这也是Spring默认的scope，表示Spring容器<strong>只创建一个bean的实例</strong>，Spring在创建第一次后会缓存起来，之后不再创建，就是设计模式中的<strong>单例模式</strong>。</li><li><strong>Prototype</strong>：代表线程每次调用这个bean都新创建一个实例。</li><li><strong>Request</strong>：表示每个request作用域（HTTP请求）内的请求只创建一个实例。</li><li><strong>Session</strong>：表示每个session内的请求只创建一个实例，session过期bean随之失效。</li><li><strong>application</strong>：bean被定义为ServletContext的生命周期中复用一个单例对象。</li><li><strong>websocket</strong>：bean被定义为在websocket的生命周期中复用一个单例对象。</li><li>GlobalSession：全局作用域，这个只在porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的web应用使用了这个scope，容器会把它作为普通的session作用域的scope创建。</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/RefreshScope-1.jpg" alt></p><h3 id="在创建bean的时候如何指定"><a href="#在创建bean的时候如何指定" class="headerlink" title="在创建bean的时候如何指定"></a>在创建bean的时候如何指定</h3><p><strong>xml方式</strong>：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注解方式</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="doGetBean中的使用"><a href="#doGetBean中的使用" class="headerlink" title="doGetBean中的使用"></a>doGetBean中的使用</h3><p>AbstractBeanFactory#doGetBean（）</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">final</span> RootBeanDefinition mbd <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          String scopeName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>scopeName<span class="token punctuation">)</span><span class="token punctuation">;</span>          Object scopedInstance <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Singleton和Prototype是硬编码的，并不是Scope子类。 Scope实际上是自定义扩展的接口</li><li>Scope Bean实例交由Scope自己创建，例如SessionScope是从Session中获取实例的，ThreadScope是从ThreadLocal中获取的，而RefreshScope是在内建缓存中获取的。</li></ol><blockquote><p>硬编码和软编码的区别是：软编码可以在运行时确定，修改；而硬编码是不能够改变的。</p></blockquote><h3 id="Scope-的属性"><a href="#Scope-的属性" class="headerlink" title="Scope 的属性"></a>Scope 的属性</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Scope</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Alias for {@link #scopeName}.     * @see #scopeName     */</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"scopeName"</span><span class="token punctuation">)</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *  singleton  表示该bean是单例的。(默认)     *  prototype    表示该bean是多例的，即每次使用该bean时都会新建一个对象。     *  request        在一次http请求中，一个bean对应一个实例。     *  session        在一个httpSession中，一个bean对应一个实例     */</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>    String <span class="token function">scopeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**    *   DEFAULT            不使用代理。(默认)    *     NO                不使用代理，等价于DEFAULT。    *     INTERFACES        使用基于接口的代理(jdk dynamic proxy)。    *     TARGET_CLASS    使用基于类的代理(cglib)。    */</span>    ScopedProxyMode <span class="token function">proxyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> ScopedProxyMode<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>我们需要关心的就是ScopedProxyMode.TARGET_CLASS 这个属性，当ScopedProxyMode 为TARGET_CLASS 的时候会给当前创建的bean 生成一个代理对象，会通过代理对象来访问，每次访问都会创建一个新的对象。</strong></p><h2 id="RefreshScope的实现原理"><a href="#RefreshScope的实现原理" class="headerlink" title="RefreshScope的实现原理"></a>RefreshScope的实现原理</h2><h3 id="先来看下-RefreshScope"><a href="#先来看下-RefreshScope" class="headerlink" title="先来看下@RefreshScope"></a>先来看下@RefreshScope</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"refresh"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RefreshScope</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @see Scope#proxyMode()     */</span>    ScopedProxyMode <span class="token function">proxyMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> ScopedProxyMode<span class="token punctuation">.</span>TARGET_CLASS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，它使用就是 @Scope ，其内部就一个属性默认 ScopedProxyMode.TARGET_CLASS。知道了是通过Spring Scope 来实现的那就简单了，我们来看下Scope 这个接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Scope</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Return the object with the given name from the underlying scope,     * {@link org.springframework.beans.factory.ObjectFactory#getObject() creating it}     * if not found in the underlying storage mechanism.     * &lt;p>This is the central operation of a Scope, and the only operation     * that is absolutely required.     * @param name the name of the object to retrieve     * @param objectFactory the {@link ObjectFactory} to use to create the scoped     * object if it is not present in the underlying storage mechanism     * @return the desired object (never {@code null})     * @throws IllegalStateException if the underlying scope is not currently active     */</span>    Object <span class="token function">get</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> objectFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    Object <span class="token function">remove</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">registerDestructionCallback</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Runnable callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    Object <span class="token function">resolveContextualObject</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    String <span class="token function">getConversationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看下接口，我们只看<code>Object get(String name, ObjectFactory&lt;?&gt; objectFactory)</code>; 这个方法帮助我们来<strong>创建一个新的bean</strong> ，也就是说，@RefreshScope 在调用 刷新的时候会使用此方法来给我们创建新的对象，这样就可以通过spring 的装配机制将属性重新注入了，也就实现了所谓的动态刷新。</p><h3 id="get（）方法"><a href="#get（）方法" class="headerlink" title="get（）方法"></a>get（）方法</h3><p>它究竟是怎么处理老的对象，又怎么除法创建新的对象呢？</p><p>因为RefreshScope extends GenericScope和 GenericScope implements Scope，RefreshScope继承GenericScope。</p><p>通过查看代码，是GenericScope 实现了 Scope 最重要的 <code>get(String name, ObjectFactory&lt;?&gt; objectFactory)</code>方法，在GenericScope 里面 包装了一个内部类 BeanLifecycleWrapperCache 来对加了 @RefreshScope 从而创建的对象进行缓存，使其在不刷新时获取的都是同一个对象。（这里你可以把 BeanLifecycleWrapperCache 想象成为一个大Map 缓存了所有@RefreshScope 标注的对象）</p><p>知道了对象是缓存的，所以在进行动态刷新的时候，只需要清除缓存，重新创建就好了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ContextRefresher 外面使用它来进行方法调用 ============================== 我是分割线</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> <span class="token function">refreshEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>scope<span class="token punctuation">.</span><span class="token function">refreshAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> keys<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RefreshScope 内部代码  ============================== 我是分割线</span>    <span class="token annotation punctuation">@ManagedOperation</span><span class="token punctuation">(</span>description <span class="token operator">=</span> <span class="token string">"Dispose of the current instance of all beans in this scope and force a refresh on next method execution."</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refreshAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RefreshScopeRefreshedEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// GenericScope 里的方法 ============================== 我是分割线</span>    <span class="token comment" spellcheck="true">//进行对象获取，如果没有就创建并放入缓存</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> objectFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BeanLifecycleWrapper value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">BeanLifecycleWrapper</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> objectFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        locks<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>errors<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//进行缓存的数据清理</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Throwable<span class="token operator">></span> errors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Throwable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>BeanLifecycleWrapper<span class="token operator">></span> wrappers <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanLifecycleWrapper wrapper <span class="token operator">:</span> wrappers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Lock lock <span class="token operator">=</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    wrapper<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                errors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>errors<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>errors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>errors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们截取了三个片段所得之，ContextRefresher 就是外层调用方法用的，GenericScope 里面的 get 方法<strong>负责对象的创建和缓存</strong>，destroy 方法负责再刷新时缓存的清理工作。</p><h3 id="总结下-RefreshScope-实现流程"><a href="#总结下-RefreshScope-实现流程" class="headerlink" title="总结下@RefreshScope 实现流程"></a>总结下@RefreshScope 实现流程</h3><ol><li>需要动态刷新的类标注@RefreshScope 注解</li><li>@RefreshScope 注解标注了@Scope 注解，并默认了ScopedProxyMode.TARGET_CLASS; 属性，此属性的功能就是在创建一个代理，在每次调用的时候都用它来调用GenericScope get 方法来获取对象</li><li>如属性发生变更会调用 ContextRefresher refresh（） -》RefreshScope refreshAll（） 进行缓存清理方法调用，并发送刷新事件通知 -》 GenericScope 真正的 清理方法destroy（）实现清理缓存</li><li>在下一次使用对象的时候，会调用GenericScope get（String name, ObjectFactory&lt;?&gt; objectFactory） 方法创建一个新的对象，并存入缓存中，此时新对象因为Spring 的装配机制就是新的属性了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-bean-scope详解&quot;&gt;&lt;a href=&quot;#Spring-bean-scope详解&quot; class=&quot;headerlink&quot; title=&quot;Spring bean scope详解&quot;&gt;&lt;/a&gt;Spring bean scope详解&lt;/h2&gt;&lt;p&gt;Sc
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="springcloud" scheme="https://arthurjq.com/tags/springcloud/"/>
    
      <category term="spring" scheme="https://arthurjq.com/tags/spring/"/>
    
      <category term="annotation" scheme="https://arthurjq.com/tags/annotation/"/>
    
      <category term="bean" scheme="https://arthurjq.com/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>doGetBean方法</title>
    <link href="https://arthurjq.com/2021/02/23/java/dogetbean/"/>
    <id>https://arthurjq.com/2021/02/23/java/dogetbean/</id>
    <published>2021-02-23T04:23:15.000Z</published>
    <updated>2021-02-23T14:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token keyword">boolean</span> typeCheckOnly<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过三种形式获取beanName</span>        <span class="token comment" spellcheck="true">//一个是原始的beanName，一个是加了&amp;的，一个是别名</span>        <span class="token keyword">final</span> String beanName <span class="token operator">=</span> <span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Eagerly check singleton cache for manually registered singletons.</span>        <span class="token comment" spellcheck="true">//尝试从单例缓存集合里获取bean实例</span>        Object sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object bean<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果先前已经创建过单例Bean的实例，并且调用的getBean方法传入的参数为空</span>        <span class="token comment" spellcheck="true">//则执行if里面的逻辑</span>        <span class="token comment" spellcheck="true">//args之所以要求为空是因为如果有args，则需要做进一步赋值，因此无法直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果Bean还在创建中，则说明是循环引用</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Returning eagerly cached instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                            <span class="token string">"' that is not fully initialized yet - a consequence of a circular reference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Returning cached instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果是普通bean，直接返回，如果是FactoryBean，则返回它的getObject</span>            bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//若scope为prototype或者单例模式但是缓存中还不存在bean</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果scope为prototype并且 显示还在创建中，则基本是循环依赖的情况</span>            <span class="token comment" spellcheck="true">//针对prototype的循环依赖，spring误解，直接抛出异常</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrototypeCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Check if bean definition exists in this factory.</span>            BeanFactory parentBeanFactory <span class="token operator">=</span> <span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//从当前容器中找不到指定名称的bean，此时递归去parentFactory查找</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Not found -> check parent.</span>                <span class="token comment" spellcheck="true">//主要针对FactoryBean，将Bean的&amp;重新加上</span>                String nameToLookup <span class="token operator">=</span> <span class="token function">originalBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果parent容器依旧是AbstractBeanFactory的实例</span>                <span class="token comment" spellcheck="true">//instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//直接递归调用方法来查找</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractBeanFactory<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doGetBean</span><span class="token punctuation">(</span>                            nameToLookup<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> args<span class="token punctuation">,</span> typeCheckOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果有参数，则委派父类容器根据指定名称和显示的参数查找</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>nameToLookup<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// No args -> delegate to standard getBean method.</span>                    <span class="token comment" spellcheck="true">//委派父级容器根据指定名称和类型查找</span>                    <span class="token keyword">return</span> parentBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>nameToLookup<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//委派父级容器根据指定名称查找</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>nameToLookup<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//typeCheckOnly是用来判断调用getBean()是否仅仅是为了类型检查获取bean，而不是为了创建Bean</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeCheckOnly<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果不是仅仅做类型检查则是创建bean</span>                <span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//将父类的BeanDefinition与子类的BeanDefinition进行合并覆盖</span>                <span class="token keyword">final</span> RootBeanDefinition mbd <span class="token operator">=</span> <span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//对合并的BeanDefinition做验证，主要看属性是否为abstract的</span>                <span class="token function">checkMergedBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Guarantee initialization of beans that the current bean depends on.</span>                <span class="token comment" spellcheck="true">//获取当前Bean所有依赖Bean的名称</span>                String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependsOn <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果当前Bean设置了dependsOn的属性</span>                <span class="token comment" spellcheck="true">//depends-on用来指定Bean初始化及销毁时的顺序</span>                <span class="token comment" spellcheck="true">//&lt;bean id="a" Class="com.imooc.A" depends-on="b" /></span>                <span class="token comment" spellcheck="true">//&lt;bean id="b" Class="com.imooc.B" /></span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dependsOn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>String dep <span class="token operator">:</span> dependsOn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//校验该依赖是否已经注册给当前bean，注意这里传入的key是当前的bean名称</span>                        <span class="token comment" spellcheck="true">//这里主要是判断是否有以下这种类型的依赖：</span>                        <span class="token comment" spellcheck="true">//&lt;bean id="beanA" Class="com.imooc.A" depends-on="beanB" /></span>                        <span class="token comment" spellcheck="true">//&lt;bean id="beanB" Class="com.imooc.B" depends-on="beanA" /></span>                        <span class="token comment" spellcheck="true">//如果有，直接抛出异常</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDependent</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> dep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                                    <span class="token string">"Circular depends-on relationship between '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' and '"</span> <span class="token operator">+</span> dep <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//缓存依赖调用，注意这里传入的key是被依赖的bean名称</span>                        <span class="token function">registerDependentBean</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//递归调用getBean方法，注册Bean之间的依赖(如C需要晚于B初始化，而B需要晚于A初始化)</span>                            <span class="token comment" spellcheck="true">//初始化依赖的bean</span>                            <span class="token function">getBean</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchBeanDefinitionException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                                    <span class="token string">"'"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' depends on missing bean '"</span> <span class="token operator">+</span> dep <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Create bean instance.</span>                <span class="token comment" spellcheck="true">//如果BeanDefinition为单例</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span>                    sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>                        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// Explicitly remove instance from singleton cache: It might have been put there</span>                            <span class="token comment" spellcheck="true">// eagerly by the creation process, to allow for circular reference resolution.</span>                            <span class="token comment" spellcheck="true">// Also remove any beans that received a temporary reference to the bean.</span>                            <span class="token comment" spellcheck="true">//显示从单例缓存中删除bean实例</span>                            <span class="token comment" spellcheck="true">//因为单例模式下为了解决循环依赖，可能它已经存在了，所以将其销毁</span>                            <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//只有在单例情况下才会尝试解决循环依赖</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果是普通bean，直接返回，如果是FactoryBean，则返回它的getObject</span>                    bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// It's a prototype -> create a new instance.</span>                    Object prototypeInstance <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        prototypeInstance <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>prototypeInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//指定的scope上实例化bean</span>                    String scopeName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>scopeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>scope <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No Scope registered for scope name '"</span> <span class="token operator">+</span> scopeName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        Object scopedInstance <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                            <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">try</span> <span class="token punctuation">{</span>                                <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">finally</span> <span class="token punctuation">{</span>                                <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>scopedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                                <span class="token string">"Scope '"</span> <span class="token operator">+</span> scopeName <span class="token operator">+</span> <span class="token string">"' is not active for the current thread; consider "</span> <span class="token operator">+</span>                                <span class="token string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span><span class="token punctuation">,</span>                                ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">cleanupAfterBeanCreationFailure</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Check if required type matches the type of the actual bean instance.</span>        <span class="token comment" spellcheck="true">//检查需要的类型是否符合bean的实际类型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>requiredType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                T convertedBean <span class="token operator">=</span> <span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>convertedBean <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> convertedBean<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TypeMismatchException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Failed to convert bean '"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"' to required type '"</span> <span class="token operator">+</span>                            ClassUtils<span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/doGetBean-1.png" alt></p><h3 id="尝试从缓存中加载单例"><a href="#尝试从缓存中加载单例" class="headerlink" title="尝试从缓存中加载单例"></a>尝试从缓存中加载单例</h3><p>单例在spring容器内只会创建一次，后续获取都是从单例缓存中获取。如果获取不到则从singletonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建的时候为了避免循环依赖，在Spring中创建bean的原则是不等bean创建完就会将创建bean的ObjectFactory提早曝光，也就是将ObjectFactory加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用ObjectFactory。</p><p>缓存池获取bean实例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//一级缓存：存放的是已经完成实例化，属性填充和初始化步骤的单例bean实例</span>    Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//二级缓存：存放的是提前暴露的单例bean实例，可能是代理对象，也可能是未经代理的原对象，但都还没有完成初始化的步骤</span>            singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//三级缓存：存放的是ObjectFactory的匿名内部类实例</span>                ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory <span class="token operator">=</span> <span class="token punctuation">(</span>ObjectFactory<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//回调ObjectFactory#getObject方法获取提前暴露的引用</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//移入二级缓存</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//移除三级缓存</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> singletonObject <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> singletonObject <span class="token operator">:</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码解析&quot;&gt;&lt;a href=&quot;#代码解析&quot; class=&quot;headerlink&quot; title=&quot;代码解析&quot;&gt;&lt;/a&gt;代码解析&lt;/h2&gt;&lt;p&gt;org.springframework.beans.factory.support.AbstractBeanFactory#
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="spring" scheme="https://arthurjq.com/tags/spring/"/>
    
      <category term="bean" scheme="https://arthurjq.com/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器classloader</title>
    <link href="https://arthurjq.com/2021/02/22/java/classloader/"/>
    <id>https://arthurjq.com/2021/02/22/java/classloader/</id>
    <published>2021-02-22T03:23:15.000Z</published>
    <updated>2021-03-09T05:06:11.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是classloader"><a href="#什么是classloader" class="headerlink" title="什么是classloader"></a>什么是classloader</h2><p>转载至阿里巴巴淘系技术：<a href="https://www.zhihu.com/question/46719811/answer/1739289578" target="_blank" rel="noopener">https://www.zhihu.com/question/46719811/answer/1739289578</a></p><p>classloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><h2 id="classloader的加载过程"><a href="#classloader的加载过程" class="headerlink" title="classloader的加载过程"></a>classloader的加载过程</h2><p>类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：<strong>类加载、验证、准备、解析、初始化</strong>、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-1.jpg" alt></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指的是把class字节码文件从各个来源通过类加载器装<strong>载入内存</strong>中</p><p>主要任务：</p><ol><li>通过“类全名”来获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li></ol><p>相对于类加载过程的其他阶段，加载阶段是通过类加载（ClassLoader）来完成的，而类加载器也可以由用户自定义完成，因此，开发人员可以通过定义类加载器去控制字节流的获取方式。加载之后，二进制文件会被读入到虚拟机所需的格式存储在<strong>方法区</strong>中，方法区中存储格式由虚拟机自行定义，然后在java堆中实例化一个java.lang.Class类对象，通过这个对象就可以访问方法区中的数据。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段是链接阶段的第一步，目的就是确保class文件的字节流中包含的信息<strong>符合虚拟机的要求</strong>，不能危害虚拟机自身安全。验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li>文件格式的验证，文件中是否有不规范的或者附加的其他信息。例如常量中是否有不被支持的常量。</li><li>元数据的验证，保证其描述的信息复合Java语言规范的要求。例如类是否有父类，是否继承了不被允许的final类等</li><li>字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</li><li>符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类，校验符号引用中的访问性（private，public等）是否可被当前类访问等。</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>这个阶段就是<strong>为类变量分配内存并设置类变量初始值</strong>的阶段，这些内存将在方法区中进行分配。</p><p>要注意的是，进行分配内存的<strong>只是包括类变量，而不包括实例变量</strong>，实例变量是在对象实例化时随着对象一起分配在java堆中的。</p><p>通常情况下，初始值为零值，假设public static int value = 2;那么value在准备阶段过后的初始值为0，不为2，这时候只是开辟了内存空间，并没有运行java代码，value赋值为2的指令是程序被编译后。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将虚拟机常量池的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p><p>比如，现在调用方法hello（），这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p><p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换成具体的内存地址或偏移量，也就是直接引用。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。在以下四种情况下初始化过程会被触发执行：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化。</li><li>jvm启动时，用户指定一个执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。</li></ol><h4 id="lt-clinit-gt-和-lt-init-gt-的区别"><a href="#lt-clinit-gt-和-lt-init-gt-的区别" class="headerlink" title="&lt;clinit&gt;() 和 &lt;init&gt;() 的区别"></a><code>&lt;clinit&gt;()</code> 和 <code>&lt;init&gt;()</code> 的区别</h4><ul><li><code>&lt;clinit&gt;()</code> </li></ul><p>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code> 方法。 如果类中没有静态语句和静态代码块，那可以不生成<code>&lt;clinit&gt;()</code>方法。</p><p>并且 <code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><ul><li><code>&lt;init&gt;()</code></li></ul><p>对象构造时用以初始化对象的，构造器以及非静态初始化块中的代码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Test instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这句编译器报错，非法向前引用</span>        <span class="token comment" spellcheck="true">// System.out.println("x=" + x);</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x="</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">";y="</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 构造器可以访问声明于他们后面的静态变量</span>        <span class="token comment" spellcheck="true">// 因为静态变量在类加载的准备阶段就已经分配内存并初始化0值了</span>        <span class="token comment" spellcheck="true">// 此时 x=0，y=0</span>        x<span class="token operator">++</span><span class="token punctuation">;</span>        y<span class="token operator">++</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x="</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">";y="</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Test <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test obj <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x="</span> <span class="token operator">+</span> obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y="</span> <span class="token operator">+</span> obj<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出信息如下：</p><pre class="line-numbers language-shell"><code class="language-shell">static开始构造器开始x=0;y=0x=1;y=1构造器结束static结束x=6y=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>虚拟机首先执行的是类加载初始化过程中的 <code>&lt;clinit&gt;()</code> 方法，也就是静态变量赋值以及静态代码块中的代码，如果 <code>&lt;clinit&gt;()</code> 方法中触发了对象的初始化，也就是 <code>&lt;init&gt;()</code> 方法，那么会进入执行 <code>&lt;init&gt;()</code> 方法，执行 <code>&lt;init&gt;()</code> 方法完成之后，再回来继续执行 <code>&lt;clinit&gt;()</code> 方法。</strong></p><p>上面代码中，先执行 static 代码块，此时调用了构造器，构造器中对类变量 x 和 y 进行加 1 ，之后继续完 static 代码块，接着执行下面的 <code>public static int x = 6;</code> 来重新给类变量 x 赋值为 6，因此，最后输出的是 x=6， y=1。</p><p>如果希望输出的是 x=7，y=1，很简单，将语句 <code>public static int x = 6;</code> 移至 static 代码块之前就可以了。</p><blockquote><p>初始化顺序依次是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法 </p></blockquote><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>为了方便记忆，我们可以使用一句话来表达其加载的整个过程，<strong>家宴准备了西式菜</strong>，即家（加载）宴（验证）准备（准备）了西（解析）式（初始化）菜。</p><h2 id="classloader双亲委托机制"><a href="#classloader双亲委托机制" class="headerlink" title="classloader双亲委托机制"></a>classloader双亲委托机制</h2><p>classloader的双亲委托机制是指多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。其具体的过程表现为：当一个类加载的过程中，它首先不会去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类，即Bootstrap Classloader进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。</p><p>使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种层次模型，可以<strong>避免类的重复加载</strong>，也可以<strong>避免核心类被不同的类加载器加载到内存中造成冲突和混乱</strong>，从而保证了Java核心库的安全。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-2.jpg" alt></p><p>整个java虚拟机的类加载层次关系如上图所示，启动类加载器（Bootstrap Classloader）负责将<java_home>/lib 目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如<code>java.util.**，java.io.**，java.lang.**</code>等等都是由根加载器加载。</java_home></p><p>扩展类加载器（Extention Classloader）负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于 <java_home>/lib/ext 目录中。</java_home></p><p>应用程序加载器（Application Classloader）也叫系统类加载器，它负责加载用户路径（ClassPath）上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的。</p><p>自定义加载器（Custom Classloader）通常是我们为了某些特殊目的实现的自定义加载器，如tomcat、jboss都会根据j2ee规范自行实现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>    <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        <span class="token comment" spellcheck="true">//缓存中是否已经存在</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果parent classloader存在，则委托给父类进行加载</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                <span class="token comment" spellcheck="true">//自己加载</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//是否进行解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="classloader的应用场景"><a href="#classloader的应用场景" class="headerlink" title="classloader的应用场景"></a>classloader的应用场景</h2><p>类加载器是java语言的一项创新，也是java语言流行的重要原因这一。通过灵活定义classloader的加载机制，我们可以完成很多事情，例如解决类冲突问题，实现热加载以及热部署，甚至可以实现jar包的加密保护。</p><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>做过多人协同开发的大型项目的同学可能深有感触。基于maven的pom进制可以方便的进行依赖管理，但是由于maven依赖的传递性，会导致我们的依赖错综复杂，这样就会导致引入类冲突的问题。最典型的就是NoSuchMethodException异常了。</p><p>例如阿里内部也很多成熟的中间件，由不同的中间件团队来负责。那么当一个项目引入不同的中间件的时候，该如何避免依赖冲突的问题呢？</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-3.jpg" alt></p><p>某个业务引用了消息中间件（例如metaq）和微服务中间件（例如dubbo），这两个中间件也同时引用了fastjson-2.0和fastjson-3.0版本，而业务自己本身也引用了fastjson-1.0版本。这三个版本表现不同之处在于classA类中方法数目不相同，我们根据maven依赖处理的机制，引用路径最短的fastjson-1.0会真正作为应用最终的依赖，其它两个版本的fastjson则会被忽略，那么中间件在调用method2方法的时候，则会抛出方法找不到异常。</p><p>或许你会说，将所有依赖fastjson的版本都升级到3.0不是就能解解决问题吗？确实这样能够解决问题，但是在实际操作中不太现实：</p><ol><li>首先，中间件团队和业务团队之间并不是一个团队，并不能做到高效协同</li><li>其次是中间件的稳定性是需要保障的，不可能因为包冲突问题，就升级版本</li><li>更何况一个中间件依赖的包可能有上百个，如果纯粹依赖包升级来解决，不仅稳定性难以保障，排包耗费的时间恐怕就让人窒息了</li></ol><p>那如何解决包冲突的问题呢？答案就是pandora（潘多拉），通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。这样每个中间件的classloader就可以加载各自版本的fastjson。因为<strong>一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识</strong>，这也是阿里pandora实现<strong>依赖隔离</strong>的基础。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-4.jpg" alt></p><p>可能到这里，你又会有新的疑惑，根据双亲委托模型，App Classloader分别继承了Custom Classloader，那么业务包中的fastjson的class在加载的时候，会先委托到Custom ClassLoader。这样不就会导致自身依赖的fastjson版本被忽略吗？</p><p>确实如此，所以潘多拉又是如何做的呢？</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-5.jpg" alt></p><p>首先每个中间件对应的ModuleClassLoader在加载中间对应的class文件的同时，根据中间件配置的export.index负责将要需要透出的<strong>class</strong>（主要是提供api接口的相关类）<strong>索引到exportedClassHashMap中</strong>。</p><p>然后应用程序的类加载器会持有这个exportedClassHashMap，因此应用程序代码在loadClass的时候，会优先判断exportedClassHashMap是否存在当前类，如果存在，则直接返回，如果不存在，则再使用传统的双亲委托机制来进行类加载。这样中间件MoudleClassloader不仅实现了中间件的加载，也实现了中间件关键服务类的透出。</p><p>我们可以大概看下应用程序类加载的过程</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-6.jpg" alt></p><h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><p>通过classloader我们可以完成对变更内容的加载，然后快速的启动。</p><p>常用的热加载方案有好几个，接下来我们介绍下spring官方推荐的热加载方案，即 spring boot devtools 。</p><p>首先我们需要思考下，为什么重新启动一个应用会比较慢，那是因为在启动应用的时候，JVM虚拟机需要将所有的应用程序重新装载到整个虚拟机。可想而知，一个复杂的应用程序所包含的jar包可能有上百兆，每次微小的改动都是全量加载，那自然是很慢了。</p><p>那么我们是否可以做到，当我们修改了某个文件后，在JVM中替换到这个文件相关的部分而不全量的重新加载呢？而spring boot devtools正是基于这个思路进行处理的。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-7.jpg" alt></p><p>如上图所示，通常一个项目的代码由以上四部分组成，即<strong>基础类、扩展类、二方包/三方包、以及我们自己编写的业务代码</strong>组成。上面的一排是我们通常的类加载结构，其中业务代码和二方包/三方包是由应用加载器加载的。</p><p>而实际开发和调试的过程中，<strong>主要变化的是业务代码</strong>，并且业务代码相对二方包/三方包的内容来说会更少一些。因此我们可以将业务代码单独通过一个自定义的加载器Custom Classloader来进行加载，当监控发现业务代码发生改变后，我们重新加载启动，老的业务代码的相关类则由虚拟机的垃圾回收机制来自动回收。其工程流程大概如下。有兴趣的同学可以去看下源码，会更加清楚。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-8.jpg" alt></p><p>RestartClassLoader为自定义的类加载器，其<strong>核心是loadClass的加载方式</strong>，我们发现其通过<strong>修改了双亲委托机制，默认优先从自己加载</strong>，如果自己没有加载到，从parent进行加载。这样保证了业务代码可以优先被RestartClassLoader加载。进而通过重新加载RestartClassLoader即可完成应用代码部分的重新加载。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-9.jpg" alt></p><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>热部署本质其实与热加载并没有太大的区别，通常我们说热加载是指在开发环境中进行的classloader加载，而热部署则更多是指在线上环境使用classloader的加载机制完成业务的部署。所以这二者使用的技术并没有本质的区别。那热部署除了与热加载具有发布更快之外，还有更多的更大的优势就是<strong>具有更细的发布粒度</strong>。我们可以想像以下的一个业务场景。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-10.jpg" alt></p><p>假设某个营销投放平台涉及到4个业务方的开发，需要对会场业务进行投放。而这四个业务方的代码全部都在一个应用里面。因此某个业务方有代码变更则需要对整个应用进行发布，同时其它业务方也需要跟着回归。因此每个微小的发动，则需要走整个应用的全量发布。这种方式带来的稳定性风险估且不说，整个发布迭代的效率也可想而知了。这在整个互联网里，时间和效率就是金钱的理念下，显然是无法接受的。</p><p>那么我们完全可以通过类加载机制，<strong>将每个业务方通过一个classloader来加载</strong>。基于类的隔离机制，可以保障各个业务方的代码不会相互影响，同时也可以做到各个业务方进行独立的发布。其实在移动客户端，每个应用模块也可以基于类加载，实现插件化发布。本质上也是一个原理。</p><p>在阿里内部像阿拉丁投放平台，以及crossbow容器化平台，本质都是使用classloader的热加载技术，实现业务细粒度的开发部署以及多应用的合并部署。</p><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>众所周期，基于java开发编译产生的jar包是由 .class 字节码组成，由于字节码的文件格式是有明确规范的。因此对于字节码进行反编译，就很容易知道其源码实现了。</p><p>因此大致会存在如下两个方面的诉求。</p><ol><li>在服务端，我们向别人提供三方包实现的时候，不希望别人知道核心代码实现，我们可以考虑对jar包进行加密</li><li>在客户端则会比较普遍，那就是我们打包好的apk的安装包，不希望被人家反编译而被人家翻个底朝天，我们也可以对apk进行加密。</li></ol><p>jar包加密的本质，还是对字节码文件进行操作。但是JVM虚拟机加载class的规范是统一的，因此我们在最终加载class文件的时候，还是需要满足其class文件的格式规范，否则虚拟机是不能正常加载的。因此我们可以在打包的时候对class进行正向的加密操作，然后，在加载class文件之前通过自定义classloader先进行反向的解密操作，然后再按照标准的class文件标准进行加载，这样就完成了class文件正常的加载。因此这个加密的jar包只有能够实现解密方法的classloader才能正常加载。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-11.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/classloader-12.jpg" alt></p><p>更高安全的保障则取决于加密算法的安全性了以及如何保障加密算法的密钥不被泄露的问题了。这有种套娃的感觉，所谓安全基本都是相对的。安全保障只要做到使对方破解的成本高于收益即是安全，所以一定程度的安全性，足以减少很多低成本的攻击了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是classloader&quot;&gt;&lt;a href=&quot;#什么是classloader&quot; class=&quot;headerlink&quot; title=&quot;什么是classloader&quot;&gt;&lt;/a&gt;什么是classloader&lt;/h2&gt;&lt;p&gt;转载至阿里巴巴淘系技术：&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="classloader" scheme="https://arthurjq.com/tags/classloader/"/>
    
      <category term="jvm" scheme="https://arthurjq.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>mysql的锁</title>
    <link href="https://arthurjq.com/2021/02/19/database/mysql-lock/"/>
    <id>https://arthurjq.com/2021/02/19/database/mysql-lock/</id>
    <published>2021-02-19T04:21:53.000Z</published>
    <updated>2021-03-11T10:52:07.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>操作类型：</p><ol><li><p>读锁（共享锁，Shared Lock）：对同一个数据，多个读操作可以同时进行，互不干扰</p></li><li><p>写锁（互斥锁，Exclusive Lock）： 如果当前写操作没有完毕，则无法进行其他的读操作、写操作</p></li></ol><p>操作范围：</p><ol><li>表锁 ：一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。</li><li>行锁：一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。</li></ol><p>记录锁（Record Lock）：记录锁也是属于行锁的一种，锁的只是表中的某一条记录。精准条件命中，并且命中的条件字段是<strong>唯一索引</strong>。加了记录锁后数据可以避免数据在查询时被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读的问题。</p><p>页锁：开销、并发度和加锁时间界于表锁和行锁之间，<strong>会出现死锁</strong></p><p>间隙锁（Gap Lock）：属于行锁的一种，是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现间隙则会形成一个区间，遵循左开右闭原则。只会出现在重复读的事务级别中。</p><p>临建锁（Next-Key Lock）：行锁的一种，是Innodb的行锁默认算法，就是记录锁和间隙锁的结合，临建锁会把查询出来的记录锁住，同时也会把该范围内的所有间隙也锁住，再之它会把相邻的下一个区间也会锁住。触发条件：范围查询并命中，查询命中了索引。结合记录锁和间隙锁的特性，临建锁避免了再范围查询时出现脏读，重复读，幻读问题。加了临建锁后，再范围区间内数据不允许被修改和插入。</p><h2 id="基本的指令"><a href="#基本的指令" class="headerlink" title="基本的指令"></a>基本的指令</h2><h3 id="增加锁和释放锁"><a href="#增加锁和释放锁" class="headerlink" title="增加锁和释放锁"></a>增加锁和释放锁</h3><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">table</span> 表<span class="token number">1</span>  <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span>  <span class="token punctuation">,</span>表<span class="token number">2</span>  <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock <span class="token keyword">tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查看加锁的表"><a href="#查看加锁的表" class="headerlink" title="查看加锁的表"></a>查看加锁的表</h3><p>show open tables列举在表缓存中当前被打开的非TEMPORARY表。</p><p>如果您没有表的权限，则它不会显示在输出中</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span><span class="token comment" spellcheck="true"># 返回结果</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span> <span class="token keyword">where</span> in_use <span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+-------+--------+-------------+</span><span class="token operator">|</span> <span class="token keyword">Database</span> <span class="token operator">|</span> <span class="token keyword">Table</span> <span class="token operator">|</span> In_use <span class="token operator">|</span> Name_locked <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+-------+--------+-------------+</span><span class="token operator">|</span> MyDB     <span class="token operator">|</span> test  <span class="token operator">|</span>      <span class="token number">1</span> <span class="token operator">|</span>           <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+-------+--------+-------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>Database</strong>：含有该表的数据库。</li><li><strong>Table</strong>：表名称。</li><li><strong>In_use</strong>：表当前被查询使用的次数。为1表示上锁了。</li><li><strong>Name_locked</strong>：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</li></ol><h3 id="分析表锁定的严重程度"><a href="#分析表锁定的严重程度" class="headerlink" title="分析表锁定的严重程度"></a>分析表锁定的严重程度</h3><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'table%'</span><span class="token comment" spellcheck="true">--Table_locks_immediate :即可能获取到的锁数</span><span class="token comment" spellcheck="true">--Table_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>加读锁</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- tablelock引擎是myisam</span><span class="token keyword">create</span> <span class="token keyword">table</span> tablelock<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span> <span class="token punctuation">,</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">engine</span> myisam<span class="token punctuation">;</span>        会话<span class="token number">0</span>：            <span class="token keyword">lock</span> <span class="token keyword">table</span>  tablelock <span class="token keyword">read</span> <span class="token punctuation">;</span>            <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablelock<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--读（查），可以</span>            <span class="token keyword">delete</span> <span class="token keyword">from</span> tablelock <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--写（增删改），不可以</span>            <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--读，不可以</span>            <span class="token keyword">delete</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> eid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--写，不可以</span>            结论<span class="token number">1</span>：            <span class="token comment" spellcheck="true">--如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作； 且 该会话不能对其他表进行读、写操作。</span>            <span class="token comment" spellcheck="true">--即如果给A表加了读锁，则当前会话只能对A表进行读操作。</span>        会话<span class="token number">1</span>（其他会话）：            <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tablelock<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--读（查），可以</span>            <span class="token keyword">delete</span> <span class="token keyword">from</span> tablelock <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--写，会“等待”会话0将锁释放</span>        会话<span class="token number">1</span>（其他会话）：            <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--读（查），可以</span>            <span class="token keyword">delete</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> eno <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--写，可以</span>            结论<span class="token number">2</span>：            <span class="token comment" spellcheck="true">--总结：会话0给A表加了锁；其他会话的操作：a.可以对其他表（A表以外的表）进行读、写操作 b.对A表：读-可以；  写-需要等待释放锁。</span>        释放锁: unlock <span class="token keyword">tables</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h3><pre class="line-numbers language-sql"><code class="language-sql">    会话<span class="token number">0</span>：        <span class="token keyword">lock</span> <span class="token keyword">table</span> tablelock <span class="token keyword">write</span> <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">--当前会话（会话0） 可以对加了写锁的表  进行任何操作（增删改查）；但是不能 操作（增删改查）其他表</span>    其他会话：        对会话<span class="token number">0</span>中加写锁的表，可以进行增删改查的前提是：等待会话<span class="token number">0</span>释放写锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL表级锁的锁模式"><a href="#MySQL表级锁的锁模式" class="headerlink" title="MySQL表级锁的锁模式"></a>MySQL表级锁的锁模式</h3><p>MyISAM在执行查询语句（SELECT）前，会<strong>自动给涉及的所有表加读锁</strong>，在执行更新操作（DML）前，会<strong>自动给涉及的表加写锁</strong>。</p><p>所以对MyISAM表进行操作，会有以下情况：</p><ol><li>对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li></ol><h2 id="行锁（InnoDB）"><a href="#行锁（InnoDB）" class="headerlink" title="行锁（InnoDB）"></a>行锁（InnoDB）</h2><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> linelock<span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span> <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> linelock<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>  <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> linelock<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>  <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> linelock<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span>  <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> linelock<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span>  <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> linelock<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>  <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--mysql默认自动commit;    oracle默认不会自动commit ;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了研究行锁，暂时将自动commit关闭; </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">set</span> autocommit <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span><span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span><span class="token keyword">begin</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--上边三种都可以，关闭后需要手动通过commit提交</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务（commit/rollback）后  才能对数据a进行操作。</li><li>表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。</li></ol><h3 id="行锁的注意事项"><a href="#行锁的注意事项" class="headerlink" title="行锁的注意事项"></a>行锁的注意事项</h3><p>如果没有索引，则行锁会转为表锁</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> linelock <span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> linelock <span class="token keyword">add</span> <span class="token keyword">index</span> idx_linelock_name<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    会话<span class="token number">0</span>： 写操作        <span class="token keyword">update</span> linelock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'ai'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'3'</span> <span class="token punctuation">;</span>    会话<span class="token number">1</span>： 写操作， 不同的数据        <span class="token keyword">update</span> linelock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'aX'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'4'</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--上边不会阻塞。    </span>    会话<span class="token number">0</span>： 写操作        <span class="token keyword">update</span> linelock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'ai'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">;</span>    会话<span class="token number">1</span>： 写操作， 不同的数据        <span class="token keyword">update</span> linelock <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'aX'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token number">4</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">--可以发现，数据被阻塞了（加锁）</span><span class="token comment" spellcheck="true">-- 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>行锁的一种特殊情况：<strong>间隙锁</strong>（值在范围内，但却不存在）</p><pre class="line-numbers language-sql"><code class="language-sql">     <span class="token comment" spellcheck="true">--此时linelock表中 没有id=7的数据</span>     <span class="token keyword">update</span> linelock <span class="token keyword">set</span> name <span class="token operator">=</span><span class="token string">'x'</span> <span class="token keyword">where</span> id <span class="token operator">></span><span class="token number">1</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">9</span> <span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>完全避过了主键记录, 锁住数据不存在的区间</strong></p><p><strong>间隙</strong>：Mysql会自动给 间隙 加锁 -&gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。如果有where，则<strong>实际加锁的范围就是where后面的范围</strong>（不是实际的值）</p><blockquote><p>锁其实是锁住了索引</p><ul><li><p>如果不使用索引<br>走表锁</p></li><li><p>使用了索引<br>走行锁, 锁住了是索引, 不是锁住了一行</p></li></ul></blockquote><h3 id="for-update"><a href="#for-update" class="headerlink" title="for update"></a>for update</h3><p>查询数据想加锁的话用for update</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> linelock <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">for</span> <span class="token keyword">update</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>行锁分析：</p><p>show status like ‘%innodb_row_lock%’ ;<br>         Innodb_row_lock_current_waits :当前正在等待锁的数量<br>         Innodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间<br>         Innodb_row_lock_time_avg  ：平均等待时长。从系统启到现在平均等待的时间<br>         Innodb_row_lock_time_max  ：最大等待时长。从系统启到现在最大一次等待的时间<br>         Innodb_row_lock_waits ：    等待次数。从系统启到现在一共等待的次数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;操作类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;读锁（共享锁，Shared Lock）：对同一个数据，多个读操作可以同时进行，互不干扰&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://arthurjq.com/tags/mysql/"/>
    
      <category term="lock" scheme="https://arthurjq.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>OLTP vs OLAP</title>
    <link href="https://arthurjq.com/2021/02/05/database/oltp-olap/"/>
    <id>https://arthurjq.com/2021/02/05/database/oltp-olap/</id>
    <published>2021-02-05T09:19:15.000Z</published>
    <updated>2021-02-05T09:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>OLTP（on-line transaction processing）翻译为联机事务处理， OLAP（On-Line Analytical Processing）翻译为联机分析处理，从字面上来看OLTP是做事务处理，OLAP是做分析处理。<strong>从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询</strong>。</p><p><strong>OLTP方法的优点</strong>：<br>它管理组织的日常交易。 OLTP通过简化单个流程来扩大组织的客户基础。</p><p><strong>OLTP方法的缺点</strong>：<br>如果OLTP系统面临硬件故障，那么在线交易将受到严重影响。 OLTP系统允许多个用户同时访问和更改同一数据时，会造成混乱。</p><p><strong>使用OLAP服务的优点</strong>：<br>OLAP为所有类型的业务分析需求（包括计划，预算，预测和分析）创建一个平台。<br>OLAP的主要好处是信息和计算的一致性。 轻松对用户和对象施加安全限制，以符合法规并保护敏感数据。</p><p><strong>OLAP服务的缺点</strong>：<br>实施和维护依赖于IT专业人员，因为传统的OLAP工具需要复杂的建模过程。 OLAP工具需要各个部门人员之间的合作才能有，过程相对繁琐复杂。</p><h2 id="从应用上来看看OLTP与OLAP的区别"><a href="#从应用上来看看OLTP与OLAP的区别" class="headerlink" title="从应用上来看看OLTP与OLAP的区别"></a>从应用上来看看OLTP与OLAP的区别</h2><p>OLTP主要用来记录某类业务事件的发生，如购买行为，当行为产生后，系统会记录是谁在何时何地做了何事，这样的一行（或多行）数据会以增删改的方式在数据库中进行数据的更新处理操作，要求实时性高、稳定性强、确保数据及时更新成功，像公司常见的业务系统如ERP，CRM，OA等系统都属于OLTP。</p><p>当数据积累到一定的程度，我们需要对过去发生的事情做一个总结分析时，就需要把过去一段时间内产生的数据拿出来进行统计分析，从中获取我们想要的信息，为公司做决策提供支持，这时候就是在做OLAP了。</p><p>因为OLTP所产生的业务数据分散在不同的业务系统中，而OLAP往往需要将不同的业务数据集中到一起进行统一综合的分析，这时候就需要根据业务分析需求做对应的数据清洗后存储在数据仓库中，然后由数据仓库来统一提供OLAP分析。所以我们常说OLTP是数据库的应用，OLAP是数据仓库的应用，下面用一张图来简要对比。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/oltp-olap-1.jpg" alt></p><h2 id="使用图示"><a href="#使用图示" class="headerlink" title="使用图示"></a>使用图示</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/oltp-olap-2.jpg" alt></p><h3 id="操作型数据库（ODS）"><a href="#操作型数据库（ODS）" class="headerlink" title="操作型数据库（ODS）"></a>操作型数据库（ODS）</h3><p>操作型数据库（ODS），数据仓库（DW或EDW），数据集市（DM）是目前标准数仓结构的三个核心组件。</p><p>他们在数仓架构中差异点大致如下（以标准理论为准，实际设计中都会有越界和妥协现象）</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/oltp-olap-3.jpg" alt></p><h3 id="ODS和贴源层（缓冲区）"><a href="#ODS和贴源层（缓冲区）" class="headerlink" title="ODS和贴源层（缓冲区）"></a>ODS和贴源层（缓冲区）</h3><p><strong>贴源层</strong>的数据结构和数据内容是和源系统一模一样的，包括里面的垃圾数据，唯一不同的是，贴源层加了“时间戳”。</p><p><strong>ODS层</strong>，则要清洗掉垃圾数据，更改不能入库的格式为数仓支持的格式或优化后的格式，如nchar改为char或Varchar。</p><p>贴源层数据存放一般为一周左右，几乎不会超过一个月；而ODS则永久存放。</p><p>细节可以看：<a href="https://www.jianshu.com/p/72e395d8cb33" target="_blank" rel="noopener">https://www.jianshu.com/p/72e395d8cb33</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;OLTP（on-line transaction processing）翻译为联机事务处理， OLAP（On-Line Analytical
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据仓库" scheme="https://arthurjq.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Seata</title>
    <link href="https://arthurjq.com/2021/02/04/project/seata/"/>
    <id>https://arthurjq.com/2021/02/04/project/seata/</id>
    <published>2021-02-04T01:21:28.000Z</published>
    <updated>2021-02-07T14:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Seata-介绍"><a href="#Seata-介绍" class="headerlink" title="Seata 介绍"></a>Seata 介绍</h2><p>Seata 是从两段提交演变而来的一种分布式事务解决方案，提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 等事务模式，这里重点介绍 AT模式。</p><p>既然 Seata 是两段提交，那我们看看它在每个阶段都做了点啥？下边我们还以下单扣库存、扣余额举例。</p><p>部分介绍转载于seata官方文档等：<a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a>   |  <a href="https://zhuanlan.zhihu.com/p/344184343" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/344184343</a>   |    <a href="https://zhuanlan.zhihu.com/p/315164700" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/315164700</a></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-1.jpg" alt></p><p>先介绍Seata分布式事务的几种角色：</p><ol><li>Transaction Coordinator（TC）: 全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态， 驱动全局事务和各个分支事务的回滚或提交。</li><li>Transaction Manager（TM）: 事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。</li><li>Resource Manager（RM）: 资源管理者，一般指业务数据库代表了一个分支事务（Branch Transaction），管理分支事务与TC进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</li></ol><blockquote><p>Seata 实现分布式事务，设计了一个关键角色 <code>UNDO_LOG</code> （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p></blockquote><h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>比如：下边我们更新 <code>user</code> 表的 <code>name</code> 字段。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">'锦泉'</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'ArthurJQ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先 Seata 的 <code>JDBC</code> 数据源代理通过对业务 SQL 解析，提取 SQL 的元数据，也就是得到 SQL 的类型（UPDATE），表（user），条件（<code>where name = &#39;ArthurJQ&#39;</code>）等相关的信息。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-2.jpg" alt></p><p>先查询数据前镜像，根据解析得到的条件信息，生成查询语句，定位一条数据。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>  name <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'ArthurJQ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="center">ID</th><th align="center">NAME</th><th align="center">USER_ID</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">ArthurJQ</td><td align="center">9527</td></tr></tbody></table><p>紧接着执行业务 SQL，根据前镜像数据主键查询出后镜像数据</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> name <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="center">ID</th><th align="center">NAME</th><th align="center">USER_ID</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">锦泉</td><td align="center">9527</td></tr></tbody></table><p>把业务数据在更新前后的数据镜像组织成回滚日志，将业务数据的更新和回滚日志在同一个本地事务中提交，分别插入到业务表和 <code>UNDO_LOG</code> 表中。</p><p>回滚记录数据格式如下：包括 afterImage 前镜像、beforeImage 后镜像、 branchId 分支事务ID、xid 全局事务ID</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"branchId"</span><span class="token operator">:</span><span class="token number">641789253</span><span class="token punctuation">,</span>    <span class="token property">"xid"</span><span class="token operator">:</span><span class="token string">"xid:xxx"</span><span class="token punctuation">,</span>    <span class="token property">"undoItems"</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"afterImage"</span><span class="token operator">:</span><span class="token punctuation">{</span>                <span class="token property">"rows"</span><span class="token operator">:</span><span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                        <span class="token property">"fields"</span><span class="token operator">:</span><span class="token punctuation">[</span>                            <span class="token punctuation">{</span>                                <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"id"</span><span class="token punctuation">,</span>                                <span class="token property">"type"</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                                <span class="token property">"value"</span><span class="token operator">:</span><span class="token number">1</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token property">"tableName"</span><span class="token operator">:</span><span class="token string">"product"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"beforeImage"</span><span class="token operator">:</span><span class="token punctuation">{</span>                <span class="token property">"rows"</span><span class="token operator">:</span><span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                        <span class="token property">"fields"</span><span class="token operator">:</span><span class="token punctuation">[</span>                            <span class="token punctuation">{</span>                                <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"id"</span><span class="token punctuation">,</span>                                <span class="token property">"type"</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                                <span class="token property">"value"</span><span class="token operator">:</span><span class="token number">1</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token property">"tableName"</span><span class="token operator">:</span><span class="token string">"product"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"sqlType"</span><span class="token operator">:</span><span class="token string">"UPDATE"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以保证，任何提交的业务数据的更新一定有相应的回滚日志。</p><blockquote><p>在本地事务提交前，各分支事务需向 <code>全局事务协调者</code> TC 注册分支 ( <code>Branch Id</code>) ，为要修改的记录申请 <strong>全局锁</strong> ，要为这条数据加锁，利用 <code>SELECT FOR UPDATE</code> 语句。而如果一直拿不到锁那就需要回滚本地事务。TM 开启事务后会生成全局唯一的 <code>XID</code>，会在各个调用的服务间进行传递。</p></blockquote><p>有了这样的机制，本地事务分支（Branch Transaction）便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源。相比于传统的 XA 事务在第二阶段释放资源，Seata 降低了锁范围提高效率，即使第二阶段发生异常需要回滚，也可以快速 从<code>UNDO_LOG</code> 表中<strong>找到对应回滚数据并反解析成 SQL 来达到回滚补偿</strong>。</p><p>最后本地事务提交，业务数据的更新和前面生成的 UNDO LOG 数据一并提交，并将本地事务提交的结果上报给全局事务协调者 TC。</p><h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>第二阶段是根据各分支的决议做提交或回滚：</p><p>如果决议是全局提交，此时各分支事务已提交并成功，这时 全局事务协调者（TC） 会向分支发送第二阶段的请求。收到 TC 的分支提交请求，该<strong>请求会被放入一个异步任务队列</strong>中，并马上返回提交成功结果给 TC。异步队列中会异步和批量地根据 <code>Branch ID</code> 查找并删除相应 <code>UNDO LOG</code> 回滚记录。并把相关事务信息如：<strong>行锁删除</strong>，之后让因为在竞争锁被阻塞的事务顺利进行。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-3.jpg" alt></p><p>如果二阶段是回滚，过程比全局提交麻烦一点，</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jta-12.jpg" alt></p><p>首先在 Client 端收到 TC 告知的二阶段是回滚时，会去查到对应的事务的 undolog，取出后镜像，对比当前的数据（因为 SeataAT 是从业务应用层面进行保护分布式事务，如果此时在数据库层面直接修改了库内信息，这个时候 SeataAT 的行锁不起隔离性作用），如果出现了在全局事务以外的数据修改，此时判定为脏写，而 Seata 因为无法感知这个脏写如何发生，此时只能打印日志和触发异常通知，告知用户需要人工介入（规范修改数据入口可避免脏写）。</p><p>而如果没有发生脏写就比较简单了，拿出前镜像，众所皆知事务是需要有原子性的，要么一起发生，要么都不发生，此时前镜像记录了发生之前的数据，进行回滚后，就达到了类似本地事务那样的原子性效果。回滚后，再把事务相关信息，如 undolog，行锁进行删除。二阶段回滚算是告一段落了。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-4.jpg" alt></p><blockquote><p>注意：这里删除回滚日志记录操作，一定是在本地业务事务执行之后</p></blockquote><h3 id="AT-在-Seata-的分布式事务框架"><a href="#AT-在-Seata-的分布式事务框架" class="headerlink" title="AT 在 Seata 的分布式事务框架"></a>AT 在 Seata 的分布式事务框架</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jta-13.png" alt></p><p>可以看到，AT 与其它事务模式在 Seata 事务框架中，会多出一个 undolog 的表（相对其它模式的入侵点），但是除此之外，对业务来说，几乎是零入侵性，这也就是为什么 AT 模式在 Seata 中受众广泛的原因。</p><h3 id="写隔离"><a href="#写隔离" class="headerlink" title="写隔离"></a>写隔离</h3><ul><li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li><li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li><li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li></ul><p>以一个示例来说明：</p><p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p><p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-5.png" alt></p><p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-6.png" alt></p><p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p><p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p><p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p><h3 id="读隔离"><a href="#读隔离" class="headerlink" title="读隔离"></a>读隔离</h3><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-7.png" alt></p><p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p><p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p><h2 id="Seata-Server-搭建"><a href="#Seata-Server-搭建" class="headerlink" title="Seata Server 搭建"></a>Seata Server 搭建</h2><p>Seata 是一个需独立部署的中间件，所以先搭 Seata Server</p><p>seata下载：<a href="https://seata.io/zh-cn/blog/download.html" target="_blank" rel="noopener">https://seata.io/zh-cn/blog/download.html</a></p><p>seata源码和seata server两个都要下载，分别解压，如下：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-9.jpg" alt></p><h3 id="file-conf"><a href="#file-conf" class="headerlink" title="file.conf"></a>file.conf</h3><p><code>seata\conf\</code>目录下的file.conf 文件用于配置持久化事务日志的模式，目前提供 <code>file</code>、<code>db</code>、<code>redis</code> 三种方式。例如使用 db 方式修改file.conf如下：</p><pre class="line-numbers language-shell"><code class="language-shell">## transaction log store, only used in seata-serverstore {  ## store mode: file、db、redis  mode = "db"  ## database store property  db {    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp)/HikariDataSource(hikari) etc.    datasource = "druid"    ## mysql/oracle/postgresql/h2/oceanbase etc.    dbType = "mysql"    driverClassName = "com.mysql.cj.jdbc.Driver"    url = "jdbc:mysql://10.0.1.110:3308/seata?serverTimezone=Asia/Shanghai"    user = "mysql"    password = "mysql"    minConn = 5    maxConn = 100    globalTable = "global_table"    branchTable = "branch_table"    lockTable = "lock_table"    queryLimit = 100    maxWait = 5000  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：在选择 <code>db</code> 方式后，需要在对应数据库创建 globalTable（持久化全局事务）、branchTable（持久化各提交分支的事务）、 lockTable（持久化各分支锁定资源事务）三张表。</p><h3 id="seata-server数据库创建"><a href="#seata-server数据库创建" class="headerlink" title="seata server数据库创建"></a>seata server数据库创建</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-8.jpg" alt></p><p>里边有对应的 globalTable（持久化全局事务）、branchTable（持久化各提交分支的事务）、 lockTable（持久化各分支锁定资源事务）三张表，粘出来去对应的数据库创建就行了。比如mysql.sql：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- the table to store GlobalSession data</span><span class="token comment" spellcheck="true">-- 持久化全局事务</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>global_table<span class="token punctuation">`</span><span class="token punctuation">(</span>    <span class="token punctuation">`</span>xid<span class="token punctuation">`</span>                       <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span>            <span class="token keyword">BIGINT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span><span class="token keyword">status</span><span class="token punctuation">`</span>                    <span class="token keyword">TINYINT</span>      <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>application_id<span class="token punctuation">`</span>            <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>transaction_service_group<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>transaction_name<span class="token punctuation">`</span>          <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>timeout<span class="token punctuation">`</span>                   <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>begin_time<span class="token punctuation">`</span>                <span class="token keyword">BIGINT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>application_data<span class="token punctuation">`</span>          <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span>                <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span>              <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>xid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_gmt_modified_status<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token keyword">status</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_transaction_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- the table to store BranchSession data</span><span class="token comment" spellcheck="true">-- 持久化各提交分支的事务</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>branch_table<span class="token punctuation">`</span><span class="token punctuation">(</span>    <span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span>         <span class="token keyword">BIGINT</span>       <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>xid<span class="token punctuation">`</span>               <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span>    <span class="token keyword">BIGINT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>resource_group_id<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>resource_id<span class="token punctuation">`</span>       <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>branch_type<span class="token punctuation">`</span>       <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span><span class="token keyword">status</span><span class="token punctuation">`</span>            <span class="token keyword">TINYINT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>client_id<span class="token punctuation">`</span>         <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>application_data<span class="token punctuation">`</span>  <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span>        <span class="token keyword">DATETIME</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span>      <span class="token keyword">DATETIME</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_xid<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>xid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- the table to store lock data</span><span class="token comment" spellcheck="true">-- 持久化每个分支锁表事务</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>lock_table<span class="token punctuation">`</span><span class="token punctuation">(</span>    <span class="token punctuation">`</span>row_key<span class="token punctuation">`</span>        <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>xid<span class="token punctuation">`</span>            <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span> <span class="token keyword">BIGINT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span>      <span class="token keyword">BIGINT</span>       <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>resource_id<span class="token punctuation">`</span>    <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span>     <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>pk<span class="token punctuation">`</span>             <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span>     <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span>   <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>row_key<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_branch_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="seata-server配置文件推送到nacos"><a href="#seata-server配置文件推送到nacos" class="headerlink" title="seata server配置文件推送到nacos"></a>seata server配置文件推送到nacos</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-10.jpg" alt></p><p>打开config.txt文件，因为要推送到nacos（方便统一配置），把需要配置的参数保留就好，修改配置如下：</p><pre class="line-numbers language-text"><code class="language-text">service.vgroupMapping.my_test_tx_group=defaultstore.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.cj.jdbc.Driverstore.db.url=jdbc:mysql://10.0.1.110:3308/seata?serverTimezone=Asia/Shanghaistore.db.user=#你创建表的数据库登录的用户名store.db.password=#数据库登录密码store.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入nacos目录，git执行命令</p><pre class="line-numbers language-shell"><code class="language-shell">sh nacos-config.sh -h 10.0.1.104 -p 8848 -g SEATA_GROUP -t 6e802a92-d7a4-498f-8f14-5625988e1608 -u nacos -w nacos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面指令执行成功后nacos配置中心能看到推送过去的配置，如下</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-11.jpg" alt></p><h3 id="registry-conf"><a href="#registry-conf" class="headerlink" title="registry.conf"></a>registry.conf</h3><p>registry.conf 文件设置 注册中心 和 配置中心：</p><p>目前注册中心支持 <code>nacos</code> 、<code>eureka</code>、<code>redis</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code>、<code>sofa</code> 七种，这里我使用的 <code>nacos</code>作为注册中心 ； 配置中心支持 <code>nacos</code> 、<code>apollo</code>、<code>zk</code>、<code>consul</code>、<code>etcd3</code> 五种方式。</p><p>将seata server注册到nacos，打开<code>\seata\conf</code>目录下的<strong>registry.conf</strong>，修改部分配置如下：</p><pre class="line-numbers language-shell"><code class="language-shell">registry {  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  type = "nacos"  loadBalance = "RandomLoadBalance"  loadBalanceVirtualNodes = 10  nacos {    application = "seata-server"    serverAddr = "10.0.1.104:8848"    group = "SEATA_GROUP"    namespace = "" #nacos服务空间    cluster = "default"    username = "" #nacos用户名    password = "" #nacos密码  }}config {  # file、nacos 、apollo、zk、consul、etcd3  type = "nacos"  nacos {    serverAddr = "10.0.1.104:8848"    namespace = "" #nacos服务空间    group = "SEATA_GROUP"    username = "" #nacos用户名    password = "" #nacos密码  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完以后在 <code>\seata\bin</code> 目录下启动 <code>seata-server</code> 即可，到这 <code>Seata</code> 的服务端就搭建好了。</p><h2 id="Seata-Client"><a href="#Seata-Client" class="headerlink" title="Seata Client"></a>Seata Client</h2><p>Seata Server 环境搭建完，接下来我们新建三个服务 <code>order-server</code>（下单服务）、<code>storage-server</code>（扣减库存服务）、<code>account-server</code>（账户金额服务），分别服务注册到 nacos。</p><h3 id="应用接入Seata-Server"><a href="#应用接入Seata-Server" class="headerlink" title="应用接入Seata Server"></a>应用接入Seata Server</h3><p>添加seata依赖：</p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>framework-seata<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- alibaba-seata --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-seata<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.seata<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>seata-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- spring-boot-seata --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.seata<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>seata-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 指定项目编译时的java版本和编码方式 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${maven-compiler-plugin.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>${java.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>${java.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>${encoding}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个服务创建application.yml文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Seata 配置项，对应 SeataProperties 类</span><span class="token key atrule">seata</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tx-service-group</span><span class="token punctuation">:</span> my_test_tx_group <span class="token comment" spellcheck="true"># Seata 事务组编号，用于 TC 集群名</span>  <span class="token comment" spellcheck="true"># Seata 服务配置项，对应 ServiceProperties 类</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> nacos    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">group</span><span class="token punctuation">:</span> SEATA_GROUP      <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 09dd3d79<span class="token punctuation">-</span>92c0<span class="token punctuation">-</span>47fe<span class="token punctuation">-</span>bd1d<span class="token punctuation">-</span>0f1b7f8dc928      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 10.0.1.104<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">username</span><span class="token punctuation">:</span> <span class="token string">""</span>      <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token string">""</span>  <span class="token comment" spellcheck="true"># Seata 注册中心配置项，对应 RegistryProperties 类</span>  <span class="token key atrule">registry</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> nacos <span class="token comment" spellcheck="true"># 注册中心类型，默认为 file</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">application</span><span class="token punctuation">:</span> seata<span class="token punctuation">-</span>server <span class="token comment" spellcheck="true"># Nacos 服务名</span>      <span class="token key atrule">cluster</span><span class="token punctuation">:</span> default <span class="token comment" spellcheck="true"># 使用的 Nacos 机器名</span>      <span class="token key atrule">group</span><span class="token punctuation">:</span> SEATA_GROUP <span class="token comment" spellcheck="true"># Nacos 组</span>      <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 09dd3d79<span class="token punctuation">-</span>92c0<span class="token punctuation">-</span>47fe<span class="token punctuation">-</span>bd1d<span class="token punctuation">-</span>0f1b7f8dc928 <span class="token comment" spellcheck="true"># Nacos 命名空间</span>      <span class="token key atrule">serverAddr</span><span class="token punctuation">:</span> 10.0.1.104<span class="token punctuation">:</span><span class="token number">8848 </span><span class="token comment" spellcheck="true"># Nacos 服务地址</span>      <span class="token key atrule">username</span><span class="token punctuation">:</span> <span class="token string">""</span>      <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>业务大致流程：用户发起下单请求，本地 order 订单服务创建订单记录，并通过 <code>RPC</code> 远程调用 <code>storage</code> 扣减库存服务和 <code>account</code> 扣账户余额服务，只有三个服务同时执行成功，才是一个完整的下单流程。如果某个服执行失败，则其他服务全部回滚。</p><p>Seata 对业务代码的侵入性非常小，<strong>代码中使用只需用 @GlobalTransactional 注解开启一个全局事务即可</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@GlobalTransactional</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"create-order"</span><span class="token punctuation">,</span> rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String xid <span class="token operator">=</span> RootContext<span class="token punctuation">.</span><span class="token function">getXID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------->交易开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//本地方法</span>    orderDao<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//远程方法 扣减库存</span>    storageApi<span class="token punctuation">.</span><span class="token function">decrease</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getProductId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//远程方法 扣减账户余额</span>    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------->扣减账户开始order中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accountApi<span class="token punctuation">.</span><span class="token function">decrease</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------->扣减账户结束order中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------->交易结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"全局事务 xid： {}"</span><span class="token punctuation">,</span> xid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="seata-client-表创建"><a href="#seata-client-表创建" class="headerlink" title="seata client 表创建"></a>seata client 表创建</h3><p>进入都seata源码里，选择客户端，再选择at模式：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/seata-12.jpg" alt></p><p>打开mysql.sql（选择自己对应的数据库，我是用的mysql），前边说过 Seata AT 模式实现分布式事务，<strong>必须在相关的业务库中创建 undo_log 表来存数据回滚日志</strong>，表结构如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>undo_log<span class="token punctuation">`</span><span class="token punctuation">(</span>    <span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span>     <span class="token keyword">BIGINT</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>   <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'branch transaction id'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>xid<span class="token punctuation">`</span>           <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'global transaction id'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>context<span class="token punctuation">`</span>       <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'undo_log context,such as serialization'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>rollback_info<span class="token punctuation">`</span> <span class="token keyword">LONGBLOB</span>     <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'rollback info'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>log_status<span class="token punctuation">`</span>    <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>      <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'0:normal status,1:defense status'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>log_created<span class="token punctuation">`</span>   <span class="token keyword">DATETIME</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'create datetime'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>log_modified<span class="token punctuation">`</span>  <span class="token keyword">DATETIME</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'modify datetime'</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>ux_undo_log<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>xid<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span>  <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8 <span class="token keyword">COMMENT</span> <span class="token operator">=</span><span class="token string">'AT transaction mode undo table'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 <code>UNDO_LOG</code> 表中，以便业务异常能随时回滚。</p><h2 id="模块接入seata"><a href="#模块接入seata" class="headerlink" title="模块接入seata"></a>模块接入seata</h2><p>将上一步的操作，新建了一个模块framework-seata，所以其他业务模块想接入seata，只需要引入该模块即可（不要忘记每个client都需要新建undo_log表）。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.wisefly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>framework-seata<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${wisefly.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>开启分布式事务需要在入口方法加上@GlobalTransactional注解</li><li>不建议方法有try-catch，如果有需要在catch里面加上<code>GlobalTransactionContext.reload(RootContext.getXID()).rollback()</code>;</li><li>由于seata在一阶段提交的时候就commit，所以<strong>存在脏读可能</strong>。强烈建议在涉及分布式事务的查询语句后面加上for update</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Seata-介绍&quot;&gt;&lt;a href=&quot;#Seata-介绍&quot; class=&quot;headerlink&quot; title=&quot;Seata 介绍&quot;&gt;&lt;/a&gt;Seata 介绍&lt;/h2&gt;&lt;p&gt;Seata 是从两段提交演变而来的一种分布式事务解决方案，提供了 &lt;code&gt;AT&lt;/cod
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="分布式事务" scheme="https://arthurjq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="nacos" scheme="https://arthurjq.com/tags/nacos/"/>
    
      <category term="中间件" scheme="https://arthurjq.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库优化方法</title>
    <link href="https://arthurjq.com/2021/02/03/database/mysql-optimization/"/>
    <id>https://arthurjq.com/2021/02/03/database/mysql-optimization/</id>
    <published>2021-02-03T06:35:52.000Z</published>
    <updated>2021-02-07T15:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h2><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR（255）,显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR（6）就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p><strong>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。</p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，<strong>ENUM类型被当作数值型数据来处理</strong>，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h2 id="使用连接（JOIN）来代替子查询（Sub-Queries）"><a href="#使用连接（JOIN）来代替子查询（Sub-Queries）" class="headerlink" title="使用连接（JOIN）来代替子查询（Sub-Queries）"></a>使用连接（JOIN）来代替子查询（Sub-Queries）</h2><p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。</p><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> customerinfo<span class="token keyword">WHERE</span> CustomerID <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> CustomerID <span class="token keyword">FROM</span> salesinfo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。</p><p>例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customerinfo<span class="token keyword">WHERE</span> CustomerID <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>SELECTC ustomerID <span class="token keyword">FROM</span> salesinfo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>如果使用连接（JOIN）来完成这个查询工作，速度将会快很多</strong>。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customerinfo<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> salesinfo <span class="token keyword">ON</span> customerinfo<span class="token punctuation">.</span>CustomerID<span class="token operator">=</span>salesinfo<span class="token punctuation">.</span>CustomerID<span class="token keyword">WHERE</span> salesinfo<span class="token punctuation">.</span>CustomerID ISNULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>连接（JOIN）之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h2 id="使用联合（UNION）来代替手动创建的临时表"><a href="#使用联合（UNION）来代替手动创建的临时表" class="headerlink" title="使用联合（UNION）来代替手动创建的临时表"></a>使用联合（UNION）来代替手动创建的临时表</h2><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的<strong>查询会话结束的时候，临时表会被自动删除</strong>，从而保证数据库整齐、高效。</p><p>使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要<strong>注意的是所有select语句中的字段数目要相同</strong>。下面的例子就演示了一个使用UNION的查询。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span>Phone <span class="token keyword">FROM</span> client <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span>BirthDate <span class="token keyword">FROM</span> author <span class="token keyword">UNION</span><span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span>Supplier <span class="token keyword">FROM</span> product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。</p><p>设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。</p><p>换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> salesinfo <span class="token keyword">SET</span> CustomerID<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">;</span> <span class="token keyword">UPDATE</span> inventory <span class="token keyword">SET</span> Quantity<span class="token operator">=</span><span class="token number">11</span> <span class="token keyword">WHERE</span> item<span class="token operator">=</span><span class="token string">'book'</span><span class="token punctuation">;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p><h2 id="锁定表"><a href="#锁定表" class="headerlink" title="锁定表"></a>锁定表</h2><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</p><p>其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOCK</span> <span class="token keyword">TABLE</span> inventory <span class="token keyword">WRITE</span> <span class="token keyword">SELECT</span> Quantity <span class="token keyword">FROM</span> inventory <span class="token keyword">WHERE</span> Item<span class="token operator">=</span><span class="token string">'book'</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UPDATE</span> inventory <span class="token keyword">SET</span> Quantity<span class="token operator">=</span><span class="token number">11</span> <span class="token keyword">WHERE</span> Item<span class="token operator">=</span><span class="token string">'book'</span><span class="token punctuation">;</span> UNLOCKTABLES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCK TABLE语句可以保证在UNLOCK TABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。</p><h2 id="使用外键"><a href="#使用外键" class="headerlink" title="使用外键"></a>使用外键</h2><p><strong>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</strong></p><p>例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> customerinfo<span class="token punctuation">(</span> CustomerID <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> PRIMARYKEY<span class="token punctuation">(</span>CustomerID<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token keyword">TYPE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> salesinfo<span class="token punctuation">(</span> SalesID <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> CustomerIDINT <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>PRIMARYKEY<span class="token punctuation">(</span>CustomerID<span class="token punctuation">,</span>SalesID<span class="token punctuation">)</span><span class="token punctuation">,</span>FOREIGNKEY<span class="token punctuation">(</span>CustomerID<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> customerinfo<span class="token punctuation">(</span>CustomerID<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span><span class="token punctuation">)</span><span class="token keyword">TYPE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意例子中的参数“ON DELETE CASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。</p><p>如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。</p><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX（）,MIN（）和ORDER BY这些命令的时候，性能提高更为明显。</p><p>加索引的注意事项：</p><ol><li><p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDER BY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。如ENUM类型的字段会出现大量重复值</p></li><li><p>索引需要逐步优化</p></li><li><p>索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。</p></li><li><p>根据SQL实际解析的顺序，调整索引的顺序（最左前缀，保持索引的定义和使用的顺序一致性）</p><blockquote><p>sql解析顺序：from … on… join …where …group by …having …select dinstinct …order by … limit …</p></blockquote></li><li><p>范围查询 in 有时不会实现，所以将含In的范围查询 放到where条件的最后，防止失效。</p></li><li><p>对于多表查询，小表驱动大表</p></li><li><p>对于复合索引，where 和 order by 拼起来，不要跨列使用</p></li><li><p>此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p></li></ol><h2 id="优化的查询语句"><a href="#优化的查询语句" class="headerlink" title="优化的查询语句"></a>优化的查询语句</h2><p>绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。</p><p>下面是应该注意的几个方面。</p><ul><li><p>首先，最好是在相同类型的字段间进行比较的操作。</p></li><li><p>其次，在建有索引的字段上尽量不要<strong>计算、使用函数和类型转换</strong>进行操作。</p></li></ul><blockquote><p>例如，在一个DATE类型的字段上使用YEAE（）函数时，将会使索引不能发挥应有的作用。</p></blockquote><ul><li>第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。</li></ul><p>例如下面的查询将会比较表中的每一条记录。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>  <span class="token operator">*</span>  <span class="token keyword">FROM</span>  books  <span class="token keyword">WHERE</span>  name  <span class="token operator">like</span>  <span class="token string">"MySQL%"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>   <span class="token operator">*</span>  <span class="token keyword">FROM</span>  books<span class="token keyword">WHERE</span>  name＞<span class="token operator">=</span><span class="token string">"MySQL"</span>  <span class="token operator">and</span>  name  ＜<span class="token string">"MySQM"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>SQL优化，是一种概率层面的优化，这是因为sql语句在执行前要经过服务层的sql优化器（MySQL Query Optimizer）进行优化。至于是否实际使用了我们的优化，需要通过explain进行推测。</p></blockquote><p>索引失效的十大情况：<a href="http://arthurjq.com/2020/12/26/index-missing/">http://arthurjq.com/2020/12/26/index-missing/</a></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>就是将数据库分为主从库，一个主库（<strong>Master</strong>）用于写数据，多个从库（<strong>Slaver</strong>）进行轮询读取数据的过程，主从库之间通过某种通讯机制进行数据的同步，是一种常见的数据库架构。下面这张图就展示了 “一主二从” 的结构：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mysql-optimization-1.png" alt></p><h3 id="为什么要读写分离"><a href="#为什么要读写分离" class="headerlink" title="为什么要读写分离"></a>为什么要读写分离</h3><p>大多数互联网数据操作往往都是读多写少，随着数据的增长，数据库的“读”会首先成为瓶颈。如果我们希望能线性地提升数据库的读性能和写性能，就需要让读 写尽可能的不相互影响，各自为政。<strong>在使用读写分离之前我们应该考虑使用缓存能不能解决问题</strong>。然后再考虑对数据库按照 “读” 和 “写” 进行分组。读写分离意味着将一体的结构的进行分散，在数据量大、高并发的情景中要考虑以下这些问题：</p><ol><li>如何保证 <strong>Master</strong> 的高可用，故障转移，熔断限流等。</li><li>读写操作的区分规则，代码层面如何处理好读命令和写命令，尽量无感知无业务入侵。</li><li>数据一致性的容忍度。虽然是数据同步，但是由于网络的不确定性这仍然是一个不可忽视的问题。</li></ol><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p><strong>数据库垂直拆分、数据库水平拆分</strong> 统称 <strong>分库</strong>。是指按照特定的条条件和维度，将同一个数据库中的数据拆分到多个数据库（主机）上面以达到分散单库（主机）负载的效果。这样我们变相地降低了数据集的大小，以空间换时间来提升性能。</p><h3 id="数据库垂直拆分"><a href="#数据库垂直拆分" class="headerlink" title="数据库垂直拆分"></a>数据库垂直拆分</h3><p><strong>数据库垂直拆分</strong> 指的是按照业务对数据库中的表进行分组，同组的放到一个新的数据库（逻辑上，并非实例）中。需要从实际业务出发将大业务分割成小业务。</p><p>比如商城的整个业务中的 <strong>用户相关表，订单相关表，物流相关表</strong> 各自独立分类形成 <strong>用户系统数据库，订单系统数据库，物流系统数据库</strong> 如下图：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mysql-optimization-2.png" alt></p><p><strong>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。</strong></p><p>这样带来了一些好处： （a）业务清晰，职责单一 （b）易维护，易扩展 （c）数据服务化 </p><p>同时也有一些负面的作用：</p><p>（a）提高了整个应用的复杂度，而且会形成跨库事务 </p><p>（b）引发 “木桶效应”，任何一个短板有可能影响整个系统 </p><p>（c）部分表关系不能 join 只能通过服务相互调用来维系。甚至由于网络问题引发数据不一致。</p><p>在需要进行分库的情况下，通常可优先考虑垂直拆分。</p><h3 id="数据库水平拆分"><a href="#数据库水平拆分" class="headerlink" title="数据库水平拆分"></a>数据库水平拆分</h3><p>在数据库垂直拆分后遇到单机数据库性能瓶颈之后，就可以考虑数据库水平拆分了。 </p><p>之所以先垂直拆分才水平拆分，是因为垂直拆分后数据业务清晰而且单一，更加方便指定水平的标准。比如我们对商城业务垂直拆分后的 用户系统 进行水平拆分就比对整个商城业务进行水平拆分好找维度，我们可以根据用户注册时间的区间、用户的区域或者用户 ID 的范围、 hash 等条件，然后关联相关表的记录将数据进行拆分，如果放在整个商城业务上你是以用户为准还是以订单为准都不太好考虑。</p><p>我们按照每100万为区间对用户系统水平拆分如下（按照 id % 2 分也可以）：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mysql-optimization-3.png" alt></p><p><strong>水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</strong></p><p>这种拆分的好处在于： （a）单个库的容量可控 （b）单条记录保证了数据完整性 （c）数据关系可以通过 join 维持 （d） 避免了跨库事务 （e）稳定性体现在IO冲突减少，锁定减少，可用性指某个库出问题，部分可用；</p><p>缺点同样存在：（a）拆分规则对编码有一定的影响 （b）不同业务的分区交互需要统筹设计</p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>分表也分为 <strong>数据表垂直拆分</strong> 和 <strong>数据表水平拆分</strong> 。</p><h3 id="数据表垂直拆分"><a href="#数据表垂直拆分" class="headerlink" title="数据表垂直拆分"></a>数据表垂直拆分</h3><p>数据表垂直拆分就是纵向地把表中的列分成多个表，把表从“ 宽 ”变“ 窄 ”。一般遵循以下几个点进行拆分：</p><ol><li>冷热分离，把常用的列放在一个表，不常用的放在一个表</li><li>大字段列独立存放</li><li>关联关系的列紧密的放在一起</li></ol><p>我们把用户表中常用的和不常用的而且大字段分离成两张表：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mysql-optimization-4.png" alt></p><p><strong>垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段。</strong></p><p>它带来的提升是：</p><ol><li>为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响</li><li>充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。</li></ol><blockquote><p>为什么大字段IO效率低：第一是由于数据量本身大，需要更长的读取时间；第二是跨页，页是数据库存储单位，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好，而大字段占用空间大，单页内存储行数少，因此IO效率较低。第三，数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</p></blockquote><h3 id="数据表的水平拆分"><a href="#数据表的水平拆分" class="headerlink" title="数据表的水平拆分"></a>数据表的水平拆分</h3><p>表的水平拆分感觉跟库的水平拆分思想上都是一样的，只不过粒度不同。表结构维持不变。也就是说拆分后数据集的并集等于拆分前的数据集。理解了 数据库水平拆分 之后这个就没有什么可说的了。</p><p><strong>水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</strong></p><p>这里简单阐述了几个数据库优化概念，在实际操作中往往会组合使用。我们在实际操作之前要做好数据量的预估，这样能够根据预测未来数据的增量来进行选型。业务数据增长较小，常用于表的拆分。增长特别大达到上万级别则可以选择分库，比如一些资金积分流水，历史记录之类的。有些时候并不是拆分完就万事大吉了，比如我们按照地区拆分后，A地区业务增长很快业绩很好，而B地区推广不力竞争激烈业绩萧条，造成了数据倾斜。也会影响分库分表的期望效果。这需要建立长效的监控预测机制来应对，甚至根据实际情况及时调整策略。数据拆分还面临分布式的很多问题，分布式事务，高可用，数据一致性，全局唯一性都是应该考虑的问题。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>分库分表神器 Sharding-JDBC，几千万的数据你不搞一下？：<a href="https://zhuanlan.zhihu.com/p/301031380" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/301031380</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h2&gt;&lt;p&gt;MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它
      
    
    </summary>
    
      <category term="数据库" scheme="https://arthurjq.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://arthurjq.com/tags/mysql/"/>
    
      <category term="数据库优化" scheme="https://arthurjq.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
