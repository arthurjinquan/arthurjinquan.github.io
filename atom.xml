<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>锦泉^-^</title>
  
  <subtitle>JAVA工程师进阶之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arthurjq.com/"/>
  <updated>2021-03-30T12:52:54.176Z</updated>
  <id>https://arthurjq.com/</id>
  
  <author>
    <name>锦泉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯算法-N皇后</title>
    <link href="https://arthurjq.com/2021/03/30/nqueen/"/>
    <id>https://arthurjq.com/2021/03/30/nqueen/</id>
    <published>2021-03-30T10:41:23.000Z</published>
    <updated>2021-03-30T12:52:54.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后</a></h4><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都<strong>不能处于同一条横行、纵行或斜线上</strong>。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录Q放的位置，一维数组即可</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>queens<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录列的使用</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> col <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录正对角线的使用</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> diagonal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录斜对角线的使用</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> diagonal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>queens<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>diagonal1<span class="token punctuation">,</span>diagonal2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queens<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> row<span class="token punctuation">,</span>Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> col<span class="token punctuation">,</span>Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> diagonal1<span class="token punctuation">,</span>Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> diagonal2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token function">getString</span><span class="token punctuation">(</span>queens<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//i是列数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>col<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//正对角任意一行行列相减为同一个数</span>                <span class="token keyword">int</span> dia1 <span class="token operator">=</span> row <span class="token operator">-</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>diagonal1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>dia1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//斜对角任意一行行列相加为同一个数</span>                <span class="token keyword">int</span> dia2 <span class="token operator">=</span> row <span class="token operator">+</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>diagonal2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>dia2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//记录第row行i列放Q</span>                queens<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                col<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                diagonal1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dia1<span class="token punctuation">)</span><span class="token punctuation">;</span>                diagonal2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dia2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>queens<span class="token punctuation">,</span>n<span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>diagonal1<span class="token punctuation">,</span>diagonal2<span class="token punctuation">)</span><span class="token punctuation">;</span>                queens<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                col<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                diagonal1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>dia1<span class="token punctuation">)</span><span class="token punctuation">;</span>                diagonal2<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>dia2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queens<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//queens[i]才是列数</span>            row<span class="token punctuation">[</span>queens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;N皇后&quot;&gt;&lt;a href=&quot;#N皇后&quot; class=&quot;headerlink&quot; title=&quot;N皇后&quot;&gt;&lt;/a&gt;N皇后&lt;/h2&gt;&lt;h4 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N 皇
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://arthurjq.com/tags/leetcode/"/>
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数和为k</title>
    <link href="https://arthurjq.com/2021/03/30/sumabc/"/>
    <id>https://arthurjq.com/2021/03/30/sumabc/</id>
    <published>2021-03-30T04:08:12.000Z</published>
    <updated>2021-04-01T13:14:51.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数和为k"><a href="#两数和为k" class="headerlink" title="两数和为k"></a>两数和为k</h2><p>给定一个数组,试找出2个数a, b,使得a+b=k</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">task1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>        <span class="token function">sumAB</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sumAB</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>r<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token operator">--</span>r<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token operator">++</span>l<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token operator">--</span>r<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三数和为k"><a href="#三数和为k" class="headerlink" title="三数和为k"></a>三数和为k</h2><p>给定一个数组,试找出3个数a, b, c,使得a+b+c=k</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">threeSumCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threeSumCore</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//避免1，1，2，3情况</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//避免0，0，0情况</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">++</span>l<span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">--</span>r<span class="token punctuation">;</span>                    <span class="token operator">++</span>l<span class="token punctuation">;</span>                    <span class="token operator">--</span>r<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token operator">++</span>l<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token operator">--</span>r<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两数和为k&quot;&gt;&lt;a href=&quot;#两数和为k&quot; class=&quot;headerlink&quot; title=&quot;两数和为k&quot;&gt;&lt;/a&gt;两数和为k&lt;/h2&gt;&lt;p&gt;给定一个数组,试找出2个数a, b,使得a+b=k&lt;/p&gt;
&lt;pre class=&quot;line-numbers lan
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="https://arthurjq.com/2021/03/27/netty/"/>
    <id>https://arthurjq.com/2021/03/27/netty/</id>
    <published>2021-03-27T03:28:34.000Z</published>
    <updated>2021-03-27T14:26:30.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-7.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-1.jpg" alt="NIO流程"></p><h3 id="Epoll函数详解"><a href="#Epoll函数详解" class="headerlink" title="Epoll函数详解"></a>Epoll函数详解</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-2.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-4.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-5.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-6.jpg" alt></p><p>epoll_create：创建epoll实例</p><p>epoll_ctl：添加socketchannel到epoll实例并关联事件</p><p>epoll_wait：socketchannel没有事件发生就阻塞，有事件发生时服务器的OS中断处理响应，添加到就绪事件rdlist并跳出阻塞处理事件</p><p>可以在liunx通过man命令查看手册说明，比如man epoll_ctl：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-nio-3.jpg" alt></p><h2 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h2><p>在操作系统层面上的零拷贝是指避免在用户态与内核态之间来回拷贝数据的技术。 Netty中的零拷贝与操作系统层面上的零拷贝不完全一样, Netty的零拷贝完全是在用户态（Java层面）的，更多是数据操作的优化。</p><ol><li><p>Netty的接收和发送ByteBuffer使用<strong>直接内存</strong>（NIO中ByteBuffer.allocateDirect方法，返回一个地址。netty中通过byteBuf = allocHandle.allocate（allocator）→ ioBuffer中return directBuffer（initialCapactiy））进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li><li><p>Netty的文件传输调用FileRegion包装的transferTo方法，可以<strong>直接将文件缓冲区的数据发送到目标Channel</strong>，避免通过循环write方式导致的内存拷贝问题。</p></li><li><p>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</p></li><li><p>通过wrap操作, 我们可以将byte[ ]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。</p></li><li><p>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</p></li></ol><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-1.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/netty-2.jpg" alt></p><h3 id="通过FileRegion实现零拷贝"><a href="#通过FileRegion实现零拷贝" class="headerlink" title="通过FileRegion实现零拷贝"></a>通过FileRegion实现零拷贝</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    RandomAccessFile raf <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 通过 RandomAccessFile 打开一个文件.</span>        raf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        length <span class="token operator">=</span> raf<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token string">"ERR: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> raf <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            raf<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"OK: "</span> <span class="token operator">+</span> raf<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>SslHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SSL not enabled - can use zero-copy file transfer.</span>        <span class="token comment" spellcheck="true">// 2. 调用 raf.getChannel() 获取一个 FileChannel</span>        <span class="token comment" spellcheck="true">// 3. 将 FileChannel 封装成一个 DefaultFileRegion</span>        ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultFileRegion</span><span class="token punctuation">(</span>raf<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SSL enabled - cannot use zero-copy file transfer.</span>        ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChunkedFile</span><span class="token punctuation">(</span>raf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>缓冲区重用机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/arthurjq/blogimage/raw/master/img/pic/
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="netty" scheme="https://arthurjq.com/tags/netty/"/>
    
      <category term="网络通信框架" scheme="https://arthurjq.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>线程池源码理解</title>
    <link href="https://arthurjq.com/2021/03/26/java/threadpool/"/>
    <id>https://arthurjq.com/2021/03/26/java/threadpool/</id>
    <published>2021-03-26T06:53:21.000Z</published>
    <updated>2021-03-26T09:59:52.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//核心线程数，最大线程数，超时等待时间，超时等待单位，阻塞队列，线程工厂，拒绝策略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/threadpool-2.jpg" alt="参数配置"></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/threadpool-1.jpg" alt="线程池流程"></p><p>提交优先级：core thread &gt; queue &gt; other thread</p><p>执行优先级：core thread &gt; other thread &gt; queue</p><h2 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h2><p>ThreadPoolExecutor有一个AtomicInteger变量，叫ctl（control的简写），一共32位，</p><p>高3位为线程池的状态runstatus（Running,Shutdown,Stop,Tidying,Terminate），</p><p><strong>低29位存当前有效线程数</strong>workerCount</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/threadpool-3.jpg" alt="提交流程"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//COUNT_BITS=29</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程容量</span>    <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//111</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//000</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//001</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//010</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//011</span>    <span class="token comment" spellcheck="true">//返回状态，上边那5种之一</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//返回工作线程数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断工作线程数小于核心线程数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//执行addworker，创建一个核心线程，创建失败重新获取ctl</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果工作线程数大于核心线程数，判断线程池的状态是否为running，并且可以添加进队列</span>    <span class="token comment" spellcheck="true">//如果线程池不是running状态，则执行拒绝策略，（还是会调用一次addworker）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//再次获取ctl，进行双重检索</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果线程池是不是处于RUNNING的状态，那么就会将任务从队列中移除， </span>        <span class="token comment" spellcheck="true">//如果移除失败，则会判断工作线程是否为0 ，如果过为0 就创建一个非核心线程 </span>        <span class="token comment" spellcheck="true">//如果移除成功，就执行拒绝策略，因为线程池已经不可用了；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//线程池挂了或者大于最大线程数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h2><p>其实做了两件事：</p><ol><li>才用循环CAS操作来将线程数加1；</li><li>新建一个线程并启用。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//（1）循环CAS操作，将线程池中的线程数+1.</span>        retry<span class="token operator">:</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                   firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                   <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//core true代表是往核心线程池中增加线程 false代表往最大线程池中增加线程</span>                <span class="token comment" spellcheck="true">//线程数超标，不能再添加了，直接返回</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                    wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//CAS修改ctl的值+1，在线程池中为将要添加的线程流出空间，成功退出cas循环，失败继续</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span> retry<span class="token punctuation">;</span>                c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>                <span class="token comment" spellcheck="true">//如果线程池的状态发生了变化回到retry外层循环</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                    <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//(2)新建线程，并加入到线程池workers中。</span>        <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//对workers操作要通过加锁来实现</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//细化锁的力度，防止临界区过大，浪费时间</span>                mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                    <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                    <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//判断线程池的状态</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                        <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//判断添加的任务状态,如果已经开始丢出异常</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//将新建的线程加入到线程池中</span>                        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//修正largestPoolSize的值</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                        workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//线程添加线程池成功，则开启新创建的线程</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(3)</span>                    workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数，</span>            <span class="token comment" spellcheck="true">//如果添加成功则需要移除，并回复clt的值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>                <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker类继承自AQS，实现了Runnable接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程池中正真运行的线程。通过我们指定的线程工厂创建而来</span>        <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//线程包装的任务。thread 在run时主要调用了该任务的run方法</span>        Runnable firstTask<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录当前线程完成的任务数</span>        <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>        <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//利用我们指定的线程工厂创建一个线程</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://blog.csdn.net/varyall/article/details/82392048" target="_blank" rel="noopener">https://blog.csdn.net/varyall/article/details/82392048</a></p><h2 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h2><p>从中可以看出workQueue的优先级是最低的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//task = getTask()中workQueue.poll，所有队列执行的优先级是最低的</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态。</span>            <span class="token comment" spellcheck="true">//但是当前线程没有中断，则发出中断请求</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//开始执行任务前的Hook，类似回调函数</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//执行任务</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//任务执行后的Hook，类似回调函数</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//执行完毕后task重置，completedTasks计数器++，解锁</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//线程空闲达到我们设定的值时，Worker退出销毁。</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="回收线程方法"><a href="#回收线程方法" class="headerlink" title="回收线程方法"></a>回收线程方法</h2><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If abrupt, then workerCount wasn't adjusted</span>            <span class="token comment" spellcheck="true">//如果是意外退出的话，那么就需要把WorkerCount--</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//Worker移除</span>            workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//判断当前的线程池是否处于SHUTDOWN状态，判断是否要终止线程</span>        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果当前线程池状态比STOP大的话，就不处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//allowCoreThreadTimeOut=true的话，核心线程超时也会被销毁</span>                <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//Queue不为空的话至少留一个</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//当前线程大于最小的话直接返回</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// replacement not needed</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果当前运行的Worker数比当前所需要的Worker数少的话，调用addWorker</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池参数&quot;&gt;&lt;a href=&quot;#线程池参数&quot; class=&quot;headerlink&quot; title=&quot;线程池参数&quot;&gt;&lt;/a&gt;线程池参数&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-java&quot;&gt;&lt;code class=&quot;language
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="thread" scheme="https://arthurjq.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>字符串求最长不重复子串</title>
    <link href="https://arthurjq.com/2021/03/22/algorithm/substring/"/>
    <id>https://arthurjq.com/2021/03/22/algorithm/substring/</id>
    <published>2021-03-22T02:23:38.000Z</published>
    <updated>2021-03-26T12:26:32.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串，要求返回最长的子串，子串中字符不能重复。</p><blockquote><p>leetcode上是返回子串的长度，题目是要返回子串。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">maxSubstring</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">maxSubstring</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//map存放字符在字符串中的位置</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//maxLength数组存放以字符string.charAt(i)结尾的最长子字符串的长度</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxLength <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maxLength<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//maxLength[i-1] + 1是前一个位置断掉，i - map.get(str.charAt(i))是自己断了</span>                maxLength<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                maxLength<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxLength<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>maxLength<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//不管重复不重复都要存最新的位置</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>max <span class="token operator">==</span> maxLength<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">-</span>max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串，要求返回最长的子串，子串中字符不能重复。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;leetcode上是返回子串的长度，题目是
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="string" scheme="https://arthurjq.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>MQ消息队列</title>
    <link href="https://arthurjq.com/2021/03/20/project/mq/"/>
    <id>https://arthurjq.com/2021/03/20/project/mq/</id>
    <published>2021-03-20T09:02:42.000Z</published>
    <updated>2021-03-20T11:52:22.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ的作用"><a href="#MQ的作用" class="headerlink" title="MQ的作用"></a>MQ的作用</h2><ol><li>异步，如快递。快递员→菜鸟驿站→客户。提高系统的响应速度和吞吐量。</li><li>解耦，如java引用别的语言的功能。提高系统稳定性和可拓展性；可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。</li><li>削峰，如 长江涨水→三峡大坝。以稳定的系统资源对突发的流量冲击。</li></ol><p>缺点：</p><ol><li>系统可用性降低：一旦MQ宕机，整个业务都会产生影响。高可用</li><li>系统的复杂度提高：要保证消息不丢失，消息不会重复调用，保证消息顺序性</li><li>数据一致性</li></ol><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><h3 id="哪些环节会造成消息丢失"><a href="#哪些环节会造成消息丢失" class="headerlink" title="哪些环节会造成消息丢失"></a>哪些环节会造成消息丢失</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mq-1.jpg" alt="照成丢失的四种情况"></p><h3 id="怎么防止消息丢失"><a href="#怎么防止消息丢失" class="headerlink" title="怎么防止消息丢失"></a>怎么防止消息丢失</h3><h4 id="生产者发送消息不丢失"><a href="#生产者发送消息不丢失" class="headerlink" title="生产者发送消息不丢失"></a>生产者发送消息不丢失</h4><p>kafka：消息发送 + 回调</p><p>RocketMQ：1、消息发送 + 回调。 2、事务消息。（保证生产者发送消息和执行本地事务的原子性）</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mq-2.jpg" alt="事务消息"></p><p>现实生活中5min内要完成支付，就可以用事务消息保证。</p><p>RabbitMQ：1、消息发送 + 回调</p><p>2、手动事务：channel.txSelect（）开启事务，channel.txCommit（）提交事务，channel.txRollback（）回滚事务。这种方式channel会产生阻塞，吞吐量低。</p><p>3、Publisher Confirm。流程跟RocketMQ的事务消息基本一样。</p><h4 id="MQ主从消息同步不丢失"><a href="#MQ主从消息同步不丢失" class="headerlink" title="MQ主从消息同步不丢失"></a>MQ主从消息同步不丢失</h4><p><strong>RocketMQ</strong></p><ol><li>同步同步，异步同步</li><li>两阶段提交</li></ol><p><strong>RabbitMQ</strong></p><ol><li>普通集群：消息时分散存储的，节点之间不会主动进行消息同步，可能丢消息。</li><li>镜像集群：会在节点之间主动进行数据同步，这样数据安全性得到提高。</li></ol><p><strong>Kafka</strong>：通常都是用在允许消息少量丢失的场景（acks，0，1，all）</p><h4 id="MQ消息存盘不丢失"><a href="#MQ消息存盘不丢失" class="headerlink" title="MQ消息存盘不丢失"></a>MQ消息存盘不丢失</h4><p>RocketMQ：同步刷盘，异步刷盘：异步刷盘效率更高，但是可能丢消息。</p><p>RabbitMQ：将队列配置成持久化队列。新增的Quorum队列，采用Raft协议来进行消息同步。</p><h4 id="MQ消费者消费信息不丢失"><a href="#MQ消费者消费信息不丢失" class="headerlink" title="MQ消费者消费信息不丢失"></a>MQ消费者消费信息不丢失</h4><p>RocketMQ：使用默认方式就行，不采用异步方式。</p><p>RabbitMQ：autoCommit → 手动提交offset</p><p>Kafka：手动提交offset</p><h2 id="如何保证消息的顺序"><a href="#如何保证消息的顺序" class="headerlink" title="如何保证消息的顺序"></a>如何保证消息的顺序</h2><p>全局有序和局部有序：MQ只需要保证局部有序，不保证全局有序。</p><p><a href="https://rocketmq.apache.org/docs/order-example/" target="_blank" rel="noopener">https://rocketmq.apache.org/docs/order-example/</a></p><p>对于一个队列来说总是有序的。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/mq-3.jpg" alt="局部有序"></p><p><strong>生产者把一组有序的消息放到同一个队列当中，而消费者一次消费整个队列当中的消息</strong>。</p><p>RocketMQ中有完整的设计，但是在RabbitMQ和Kafka当中需要自己设计。</p><p>RabbitMQ：要保证目标exchange只对应一个队列。并且一个队列只对应一个消费者。</p><p>Kafka：生产者通过定制partition分配规则，将消息分配到同一个partition，Topic下只对应一个消费者。</p><h2 id="产品选择"><a href="#产品选择" class="headerlink" title="产品选择"></a>产品选择</h2><p><strong>Kafka</strong></p><p>优点：吞吐量非常大，性能非常好，集群高可用。</p><p>缺点：会丢数据，功能单一。</p><p>使用场景：日志分析、大数据采集</p><p><strong>RabbitMQ</strong></p><p>优点：消息可靠性高，功能全面</p><p>缺点：吞吐量比较低，消息积累会严重影响性能，erlang语言不好定制。</p><p>使用场景：小规模场景。</p><p><strong>RocketMQ</strong></p><p>优点：高吞吐，高性能，高可以，功能非常全面。</p><p>缺点：开源版功能不如云上商业版，官方文档和周边生态不够成熟。客户端只支持java。</p><p>使用场景：几乎全场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MQ的作用&quot;&gt;&lt;a href=&quot;#MQ的作用&quot; class=&quot;headerlink&quot; title=&quot;MQ的作用&quot;&gt;&lt;/a&gt;MQ的作用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;异步，如快递。快递员→菜鸟驿站→客户。提高系统的响应速度和吞吐量。&lt;/li&gt;
&lt;li&gt;解耦，如java引
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="中间件" scheme="https://arthurjq.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="rabbitmq" scheme="https://arthurjq.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://arthurjq.com/2021/03/19/dynamic-programming/"/>
    <id>https://arthurjq.com/2021/03/19/dynamic-programming/</id>
    <published>2021-03-19T12:56:44.000Z</published>
    <updated>2021-03-31T09:42:34.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划的核心是穷举"><a href="#动态规划的核心是穷举" class="headerlink" title="动态规划的核心是穷举"></a>动态规划的核心是穷举</h2><p>转载：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti</a></p><p>动态规划问题的一般形式就是<strong>求最值</strong></p><ol><li><strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</li><li>具备「最优子结构」</li><li>写出<strong>「状态转移方程」</strong>：</li></ol><p>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</p><p><strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。</p><p><strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。</p><pre class="line-numbers language-java"><code class="language-java"># 初始化 base <span class="token keyword">case</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> base# 进行状态转移<span class="token keyword">for</span> 状态<span class="token number">1</span> in 状态<span class="token number">1</span>的所有取值：    <span class="token keyword">for</span> 状态<span class="token number">2</span> in 状态<span class="token number">2</span>的所有取值：        <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            dp<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token operator">=</span> 求最值<span class="token punctuation">(</span>选择<span class="token number">1</span>，选择<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="熟悉套路"><a href="#熟悉套路" class="headerlink" title="熟悉套路"></a>熟悉套路</h2><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//自顶向下</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span>memo<span class="token punctuation">,</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">,</span><span class="token keyword">int</span> amount<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//备忘录里有的话直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//穷举状态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> subProblem <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span>memo<span class="token punctuation">,</span>amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>subProblem <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//选择</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>subProblem <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//看看金额amount能不能凑出来</span>        memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//因为选择取最小，dp全部初始化为比最大值大</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//base case</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//置底向上遍历</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> coin<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><p><code>dp[i][j]</code>代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数</p><p>所以，</p><p>当 word1[i] == word2[j]，<code>dp[i][j] = dp[i-1][j-1]</code>；</p><p>当 word1[i] != word2[j]，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></p><p>其中，<code>dp[i-1][j-1]</code>表示替换操作，<code>dp[i-1][j]</code>表示删除操作，<code>dp[i][j-1]</code>表示插入操作。</p><p>注意，针对第一行，第一列要单独考虑，我们引入 ‘ ‘ 下图所示：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/Dynamic-Programming-1.jpg" alt></p><p>第一行，是 word1 为空变成 word2 最少步数，就是插入操作</p><p>第一列，是 word2 为空，需要的最少步数，就是删除操作</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//base case</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//穷举状态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> len2<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//选择</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h4><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/Dynamic-Programming-2.jpg" alt></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化对角线为1，base case</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态规划的核心是穷举&quot;&gt;&lt;a href=&quot;#动态规划的核心是穷举&quot; class=&quot;headerlink&quot; title=&quot;动态规划的核心是穷举&quot;&gt;&lt;/a&gt;动态规划的核心是穷举&lt;/h2&gt;&lt;p&gt;转载：&lt;a href=&quot;https://labuladong.gitbook
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://arthurjq.com/tags/leetcode/"/>
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://arthurjq.com/2021/03/19/algorithm/binary-tree-traversal/"/>
    <id>https://arthurjq.com/2021/03/19/algorithm/binary-tree-traversal/</id>
    <published>2021-03-19T03:53:23.000Z</published>
    <updated>2021-03-19T06:20:03.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h4><p>做选择题做过，其实是一个思路。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">preSort</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token number">-1</span><span class="token punctuation">,</span>inorder<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">preSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span><span class="token keyword">int</span> pl<span class="token punctuation">,</span><span class="token keyword">int</span> pr<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span><span class="token keyword">int</span> il<span class="token punctuation">,</span><span class="token keyword">int</span> ir<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pl<span class="token operator">></span>pr<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>pl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> preorder<span class="token punctuation">[</span>pl<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> il<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ir<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> i<span class="token operator">-</span>il<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">preSort</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span>pl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pl<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>il<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">preSort</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span>pl<span class="token operator">+</span>len<span class="token punctuation">,</span>pr<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>ir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这题就是参数多了点。</p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p> <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" title="LeetCode 99. 恢复二叉搜索树" target="_blank" rel="noopener">LeetCode 99. 恢复二叉搜索树</a></p><p>一开始我是这样写的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">midFunc</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">midFunc</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">midFunc</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&lt;</span>pre<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">,</span>pre<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token function">midFunc</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑的还是太片面了，下面这种情况就没办法通过：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/binary-tree-traversal-1.jpg" alt></p><p>思考一下，第一步是比较3和2的大小，然后2和3交换，然后就是3和1的比较，发现1&lt;3，又交换。问题就出现了，它不会比较根节点和跟节点的左节点！！！整个结果都是错的。</p><p>所以说不能只记录前一个节点，不能只考虑两个节点的关系，要考虑三个节点：<strong>前一个元素 &lt; 当前元素 &lt; 后一个元素</strong></p><p>如下图所示，中序遍历顺序是 <code>4,2,3,1</code>，我们只要找到节点 <code>4</code> 和节点 <code>1</code> 交换顺序即可</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/binary-tree-traversal-2.png" alt></p><p>这里我们有个规律发现这两个节点：</p><ol><li>第一个节点，是第一个按照中序遍历时候前一个节点大于后一个节点，我们选取前一个节点，这里指节点 4</li><li>第二个节点，是在第一个节点找到之后，后面出现前一个节点大于后一个节点，我们选择后一个节点，这里指节点 1</li></ol><blockquote><p><strong>注意审题</strong>：该树中的两个节点被错误地交换，只有两个节点错了！！！</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//记录那两个节点</span>    TreeNode firstNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    TreeNode secondNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    TreeNode preNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">in_order</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> firstNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        firstNode<span class="token punctuation">.</span>val <span class="token operator">=</span> secondNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        secondNode<span class="token punctuation">.</span>val <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">in_order</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">in_order</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录第一个错误节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstNode <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>             firstNode <span class="token operator">=</span> preNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记录第二个错误节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstNode <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>             secondNode <span class="token operator">=</span> root<span class="token punctuation">;</span>        preNode <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token function">in_order</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以后换回Java写了。</p></blockquote><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//最大路径和</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//比0小的话直接抛弃</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">fun</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">fun</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">+</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//路径只能左右中选其一</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token operator">+</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h2&gt;&lt;h4 id=&quot;从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#从前序与中序遍历序列构造二叉树&quot; class=&quot;header
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://arthurjq.com/tags/leetcode/"/>
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序单边循环</title>
    <link href="https://arthurjq.com/2021/03/17/algorithm/quicksort/"/>
    <id>https://arthurjq.com/2021/03/17/algorithm/quicksort/</id>
    <published>2021-03-17T14:30:38.000Z</published>
    <updated>2021-03-26T07:12:51.199Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a></p><h2 id="双边循环写法"><a href="#双边循环写法" class="headerlink" title="双边循环写法"></a>双边循环写法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">quickCore</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> base<span class="token punctuation">)</span><span class="token operator">--</span>r<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>                nums<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> base<span class="token punctuation">)</span><span class="token operator">++</span>l<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>                nums<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>l<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单边循环快排"><a href="#单边循环快排" class="headerlink" title="单边循环快排"></a>单边循环快排</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//运行时间20ms</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">quickCore</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跟以前一样左边第一个为基准</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果小于基准值，m加1，然后跟m位置交换（其实就是把比base小的数换到左边）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> base<span class="token punctuation">)</span><span class="token punctuation">{</span>                m<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//把base换到空缺的位置（这时候num[m]肯定小于等于num[left]）</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickCore</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot; title=&quot;LeetCode 912. 排序数组&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 912. 排序数组&lt;/
      
    
    </summary>
    
      <category term="编程算法" scheme="https://arthurjq.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://arthurjq.com/tags/leetcode/"/>
    
      <category term="算法" scheme="https://arthurjq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="https://arthurjq.com/2021/03/17/java/jvm-gc/"/>
    <id>https://arthurjq.com/2021/03/17/java/jvm-gc/</id>
    <published>2021-03-17T09:15:22.000Z</published>
    <updated>2021-03-21T08:21:10.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么判断那些对象应该回收"><a href="#怎么判断那些对象应该回收" class="headerlink" title="怎么判断那些对象应该回收"></a>怎么判断那些对象应该回收</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>问题：不能解决循环依赖，<strong>对象1和对象2相互引用的话不会被回收</strong>，比如下面代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> Object instance<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">ReferenceCountingGC</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ReferenceCountingGC a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token string">"objA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ReferenceCountingGC b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token string">"objB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> null<span class="token punctuation">;</span>    b <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>根对象作为起始节点集合，从根节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots间没有任何引用链相连就可以被回收。</p><p>GCRoots的对象包括下面几种：</p><ol><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ol><blockquote><p>被判定不可达对象，不是一定会被回收：经过第一次标记后的对象，根据 此对象是否有必要执行finalize（）方法 进行筛选，随后会由收集器对<code>F-Queue</code>中的对象进行第二次小规模的标记</p></blockquote><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><ol><li>白色：表示对象尚未被垃圾回收器访问过。若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li>黑色：表示对象已经被垃圾回收器访问过，且<strong>这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li>灰色：表示对象已经被垃圾回收器访问过，但这个对象<strong>至少存在一个引用还没有被扫描过</strong>。</li></ol><h3 id="为什么会产生浮动垃圾"><a href="#为什么会产生浮动垃圾" class="headerlink" title="为什么会产生浮动垃圾"></a>为什么会产生浮动垃圾</h3><ul><li>一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。</li><li>一种是把<strong>原本存活的对象错误的标记为已消亡</strong>，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。</li></ul><blockquote><p>原来应该是黑色的对象被误标为了白色的两个必要条件：</p><p>条件一：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。</p><p>条件二：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p><p>于是产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</p></blockquote><p>在HotSpot虚拟机中，CMS是基于<strong>增量更新</strong>来做并发标记的，G1则采用的是<strong>原始快照</strong>的方式。</p><h3 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h3><p>增量更新要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用），当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p><p>可以简化的理解为：<strong>黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象</strong>。</p><h3 id="原始快照（SATB）"><a href="#原始快照（SATB）" class="headerlink" title="原始快照（SATB）"></a>原始快照（SATB）</h3><p>原始快照（Snapshot At the Begining）要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用），当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p><p>这个可以简化理解为：<strong>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索</strong>。</p><p>增量更新用的是写后屏障（Post-Write Barrier），<strong>记录了所有新增的引用关系</strong>。</p><p>原始快照用的是写前屏障（Pre-Write Barrier），<strong>将所有即将被删除的引用关系的旧引用记录下来</strong>。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法MarkSweep"><a href="#标记-清除算法MarkSweep" class="headerlink" title="标记-清除算法MarkSweep"></a>标记-清除算法MarkSweep</h3><p>先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。会<strong>产生内存碎片</strong>。</p><h3 id="复制算法Copying"><a href="#复制算法Copying" class="headerlink" title="复制算法Copying"></a>复制算法Copying</h3><p>它将可用内存<strong>按容量划分为大小相等的两块，每次只使用其中的一块</strong>。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><h3 id="标记-整理算法MarkCompact"><a href="#标记-整理算法MarkCompact" class="headerlink" title="标记-整理算法MarkCompact"></a>标记-整理算法MarkCompact</h3><p>与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清理算法</strong>或者<strong>标记-整理算法</strong>来进行回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h3><p><strong>单线程</strong>收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是<strong>Copying算法</strong>，Serial Old收集器是针对老年代的收集器，采用的是<strong>Mark-Compact算法</strong>。它的优点是实现简单高效，但是缺点是会给用户带来<strong>停顿</strong>。</p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>ParNew收集器是Serial收集器的<strong>多线程</strong>版本，使用多个线程进行垃圾收集。</p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>新生代的多线程收集器（并行收集器），它在回收期间<strong>不需要暂停</strong>其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>Concurrent Mark Sweep：将STW打散， 让一部分GC线程和用户线程并发执行。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-1.jpg" alt="CMS"></p><ol><li>初始标记：STW，只标记出GC Roots直接引用的对象。</li><li>并发标记：继续标记其他对象，并发执行。</li><li>重新标记：STW，对并发执行阶段的对象进行重新标记。</li><li>并发清除：并发将产生的垃圾清除。</li></ol><p><strong>安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。</p><h3 id="G1-Garbage-First-垃圾优先"><a href="#G1-Garbage-First-垃圾优先" class="headerlink" title="G1 Garbage First  垃圾优先"></a>G1 Garbage First  垃圾优先</h3><p>对堆内存不在分old和eden，而是划分为一个一个小内存块Region。每个Region可以隶属于不同的年代。</p><p><strong>G1不会产生内存碎片</strong></p><p><strong>新生代和老年代不再是物理隔离</strong>。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region。</p><p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>初始标记：STW，标记出GC Roots直接引用的Region。</li><li>标记Region：通过RSet标记出初始标记的Region引用的Old区Region。</li><li>并发标记：跟CMS差不多，只需遍历第二步标记出的Region。</li><li>最终标记：STW，跟CMS差不多。</li><li>筛选回收：跟CMS不同，G1可以采用拷贝算法。这个阶段G1只选择垃圾较多的Region清理。</li></ol><p>使用了Remembered Set来<strong>避免全堆扫描</strong>，G1中每个Region都有一个与之对应的RememberedSet ，在各个 Region 上记录自家的对象被外面对象引用的情况。当进行内存回收时，在GC根节点的枚举范围中加入RememberedSet 即可保证不对全堆扫描也不会有遗漏。</p><h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>在进行Minor GC的时候，我们可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p><p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p><p><strong>卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率</strong>。</p><h3 id="CMS和G1的对比"><a href="#CMS和G1的对比" class="headerlink" title="CMS和G1的对比"></a>CMS和G1的对比</h3><table><thead><tr><th></th><th><strong>CMS</strong></th><th><strong>G1</strong></th></tr></thead><tbody><tr><td><strong>JDK版本</strong></td><td>1.6以上</td><td>1.7以上</td></tr><tr><td><strong>回收算法</strong></td><td>标记——清除</td><td>标记——整理</td></tr><tr><td><strong>运行环境</strong></td><td>针对70G以内的堆内存</td><td>可针好几百G的大内存</td></tr><tr><td><strong>回收区域</strong></td><td>老年代</td><td>新生代和老年代</td></tr><tr><td><strong>内存布局</strong></td><td>传统连续的新生代和老年代区域</td><td>Region（将新生代和老年代切分成Region，默认一个Region 1 M,默认2048块）</td></tr><tr><td><strong>浮动垃圾</strong></td><td>是</td><td>否</td></tr><tr><td><strong>内存碎片</strong></td><td>是</td><td>否</td></tr><tr><td><strong>全堆扫描</strong></td><td>是</td><td>否</td></tr><tr><td><strong>回收时间可控</strong></td><td>否</td><td>是</td></tr><tr><td><strong>对象进入老年代的年龄</strong></td><td>6</td><td>15</td></tr><tr><td><strong>空间动态调整</strong></td><td>否</td><td>是（新生代5%-60%动态调整，一般不需求指定）</td></tr><tr><td><strong>调优参数</strong></td><td>多（近百个）</td><td>少（十几个）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;怎么判断那些对象应该回收&quot;&gt;&lt;a href=&quot;#怎么判断那些对象应该回收&quot; class=&quot;headerlink&quot; title=&quot;怎么判断那些对象应该回收&quot;&gt;&lt;/a&gt;怎么判断那些对象应该回收&lt;/h2&gt;&lt;h3 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="jvm" scheme="https://arthurjq.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM 调优</title>
    <link href="https://arthurjq.com/2021/03/16/java/jvm-tuning/"/>
    <id>https://arthurjq.com/2021/03/16/java/jvm-tuning/</id>
    <published>2021-03-16T09:31:34.000Z</published>
    <updated>2021-03-21T07:09:36.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-4.jpg" alt="JMM"></p><h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-1.jpg" alt="栈结构"></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-3.jpg" alt></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-2.jpg" alt></p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>在cmd输入jvisualvm回车就会打开可视化界面。</p><h2 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h2><p>官网下载arthas的jar包。</p><pre class="line-numbers language-shell"><code class="language-shell">java -jar arthas-boot.jar//会看到存在的java进程，输入序号进入进程dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-4.jpg" alt></p><p>看到线程0占用了90%的cpu，明显有问题。输入thread+id号进入线程：</p><pre class="line-numbers language-shell"><code class="language-shell">thread 8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-5.jpg" alt></p><p>然后去代码里找第39行：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-6.jpg" alt></p><p>反编译：</p><pre class="line-numbers language-shell"><code class="language-shell">jad com.tuling.jvm.ArthasTest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="调优案例"><a href="#调优案例" class="headerlink" title="调优案例"></a>调优案例</h2><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><p>比如如下设置：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-7.jpg" alt></p><p>60MB对象放入幸存者区触发动态对象年龄判定，直接进入老年代，导致频繁full gc。</p><p>解决方法如下，把年轻代调大：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/jvm-tuning-8.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/arthurjq/blogimage/raw/master/img/pic/
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="jvm" scheme="https://arthurjq.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://arthurjq.com/2021/03/16/java/singleton/"/>
    <id>https://arthurjq.com/2021/03/16/java/singleton/</id>
    <published>2021-03-16T05:49:35.000Z</published>
    <updated>2021-03-16T05:56:20.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要有单例模式"><a href="#为什么要有单例模式" class="headerlink" title="为什么要有单例模式"></a>为什么要有单例模式</h2><p>实际编程应用场景中，有一些对象其实我们只需要一个，比如线程池对象、缓存、系统全局配置对象等。这样可以就保证一个在全局使用的类不被频繁地创建与销毁，节省系统资源。</p><p>转载：<a href="https://www.cnblogs.com/happyone/p/11221157.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyone/p/11221157.html</a></p><h2 id="实现单例模式的几个要点"><a href="#实现单例模式的几个要点" class="headerlink" title="实现单例模式的几个要点"></a>实现单例模式的几个要点</h2><ol><li>首先要确保全局只有一个类的实例。<br>要保证这一点，至少类的构造器要私有化。</li><li>单例的类只能自己创建自己的实例。<br>因为，构造器私有了，但是还要有一个实例，只能自己创建咯！</li><li>单例类必须能够提供自己的唯一实例给其他类<br>就是要有一个公共的方法能返回该单例类的唯一实例。</li></ol><h2 id="饿汉式—静态常量方式（线程安全）"><a href="#饿汉式—静态常量方式（线程安全）" class="headerlink" title="饿汉式—静态常量方式（线程安全）"></a>饿汉式—静态常量方式（线程安全）</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类加载时就初始化实例，避免了多线程同步问题。天然线程安全。</p><h2 id="懒汉式（线程安全，方法上加同步锁）"><a href="#懒汉式（线程安全，方法上加同步锁）" class="headerlink" title="懒汉式（线程安全，方法上加同步锁）"></a>懒汉式（线程安全，方法上加同步锁）</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和上面 懒汉式（线程不安全）实现上唯一不同是：获取实例的getInstance()方法上加了同步锁。保证了多线程场景下的单例。但是效率会有所折损，不过还好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要有单例模式&quot;&gt;&lt;a href=&quot;#为什么要有单例模式&quot; class=&quot;headerlink&quot; title=&quot;为什么要有单例模式&quot;&gt;&lt;/a&gt;为什么要有单例模式&lt;/h2&gt;&lt;p&gt;实际编程应用场景中，有一些对象其实我们只需要一个，比如线程池对象、缓存、系统全局配置
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="设计模式" scheme="https://arthurjq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://arthurjq.com/2021/03/15/java/hashmap/"/>
    <id>https://arthurjq.com/2021/03/15/java/hashmap/</id>
    <published>2021-03-15T10:45:35.000Z</published>
    <updated>2021-03-16T05:51:35.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap扩容源码（JDK1-7）"><a href="#HashMap扩容源码（JDK1-7）" class="headerlink" title="HashMap扩容源码（JDK1.7）"></a>HashMap扩容源码（JDK1.7）</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//扩容后重新计算插入的位置下标</span>            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//把元素放入HashMap的桶的对应位置</span>        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建元素  </span>    <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//获取待插入位置元素</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//这里执行链接操作，使得新插入的元素指向原有元素，头插法</span>        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//将老的表中的数据转移到新的结构中</span>        <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//转移完后旧表指向新表</span>        table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>        threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//将老的表中的数据转移到新的结构中  </span>    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//遍历数组</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//遍历数组上的链表</span>                <span class="token comment" spellcheck="true">//记住下一个要转移的元素</span>                Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//重新hash</span>                    e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token comment" spellcheck="true">//定位放入新数组的位置</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//元素指向新数组第i位</span>                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//新数组第i位指向新插入元素，完成头插法</span>                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//拿到下一个要转移的元素</span>                e <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="jdk1-7多线程出现循环链表的栗子"><a href="#jdk1-7多线程出现循环链表的栗子" class="headerlink" title="jdk1.7多线程出现循环链表的栗子"></a>jdk1.7多线程出现循环链表的栗子</h2><p>要扩容的旧的hashmap：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-1.jpg" alt></p><p>根据resize方法中的<code>Entry[] newTable = new Entry[newCapacity];</code>，多线程的情况下有多少线程就生成多少个新表，假设有线程A和线程B分别生成了newTableA和newTableB。</p><p>又假设两个线程同时走到了transfer方法，线程A的参数为e1、next1，线程B的参数为e2、next2。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-2.jpg" alt></p><p>然后线程B在if（rehash）判断上阻塞了，线程A用头插法走完了三个元素的转移，就变成了这样：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-3.jpg" alt></p><p>这时候就发现问题了，因为插入用的是头插法，元素的顺序颠倒了，之前e2.next=next2的，现在变成了next2.next = e2了。</p><p>然后线程B不阻塞了，开始执行：</p><pre class="line-numbers language-java"><code class="language-java">e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头插法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-4.jpg" alt></p><p>然后执行<code>e = next;</code>，就是说e2指向2，和next2指向一个元素。然后开始第二次循环：</p><pre class="line-numbers language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//next2指向3</span>e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//本来就指向3，不变</span>newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头插法</span>e <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//e2和next2都指向3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-5.jpg" alt></p><p>然后开始第三次循环：</p><pre class="line-numbers language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//next2指向null</span>e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3的next指向2，形成循环链表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/hashmap-6.jpg" alt></p><h2 id="jdk8扩容源码（尾插法）"><a href="#jdk8扩容源码（尾插法）" class="headerlink" title="jdk8扩容源码（尾插法）"></a>jdk8扩容源码（尾插法）</h2><p>jdk1.6中，HashMap中有个内置Entry类，它实现了Map.Entry接口；</p><p>jdk1.8中，这个Entry类不见了，变成了Node类，也实现了Map.Entry接口，与jdk1.6中的Entry是等价的。</p><p>结构：Node数组+链表+红黑树</p><blockquote><ol><li>oldTab：为数组类型，代表扩容之前HashMap中的数组，也就是所有的桶；</li><li>oldCap：为int类型代表扩容之前总桶数量；</li><li>oldThr：为int类型代表扩容之前下次扩容的阈值；</li><li>newCap：为int类型代表这次扩容之后总桶数量；</li><li>newThr：为int类型代表这次扩容之后下次扩容的阈值；</li><li>newTab：为数组类型，代表扩容之后HashMap中的数组。</li></ol></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//首次初始化后table为Null</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认构造器的情况下为0</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//table扩容过</span>             <span class="token comment" spellcheck="true">//当前table容量大于最大值得时候返回当前table</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//table的容量乘以2，threshold的值也乘以2           </span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        <span class="token comment" spellcheck="true">//使用带有初始容量的构造器时，table容量为初始化得到的threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//默认构造器下进行扩容  </span>             <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用带有初始容量的构造器在此处进行扩容</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// help gc</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">// 当前index没有发生hash冲突，直接对2取模，即移位运算hash &amp;（2^n -1）</span>                        <span class="token comment" spellcheck="true">// 扩容都是按照2的幂次方扩容，因此newCap = 2^n</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>TreeNode</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">// 当前index对应的节点为红黑树，这里篇幅比较长且需要了解其数据结构跟算法，因此不进行详解，当树的个数小于等于UNTREEIFY_THRESHOLD则转成链表</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>HashMap<span class="token punctuation">.</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                        <span class="token comment" spellcheck="true">// 把当前index对应的链表分成两个链表，减少扩容的迁移量</span>                        HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token punctuation">{</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 扩容后不需要移动的链表</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 扩容后需要移动的链表</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// help gc</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// help gc</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 扩容长度为当前index位置+旧的容量</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意扩容前桶中的结点分为两种，一种是依旧在之前那个桶对应的下标的桶中，另一种是之前所在的桶的下标+oldCap</strong>，因为&lt;&lt;1表示容量翻倍，其实就是前面多了一位二进制，要么是0要么是1，是0的话就不变，是1的话就＋oldCap。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap扩容源码（JDK1-7）&quot;&gt;&lt;a href=&quot;#HashMap扩容源码（JDK1-7）&quot; class=&quot;headerlink&quot; title=&quot;HashMap扩容源码（JDK1.7）&quot;&gt;&lt;/a&gt;HashMap扩容源码（JDK1.7）&lt;/h2&gt;&lt;pre 
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的集合类</title>
    <link href="https://arthurjq.com/2021/03/14/java-collection/"/>
    <id>https://arthurjq.com/2021/03/14/java-collection/</id>
    <published>2021-03-14T13:51:24.000Z</published>
    <updated>2021-03-15T09:23:42.008Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的集合主要分为以下集合类：<strong>Map、List、Set、Queue和concurrent</strong>包里面供多线程环境下使用的以上几种集合类。</p><p>转载：<a href="https://zhuanlan.zhihu.com/p/112829710" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112829710</a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>java.util</code>包中提供的常见Map类包括以下几种。这里乱入了个<code>ConcurrentHashMap</code>，放到下面和其他<code>concurrent</code>包的集合一起讲。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-1.jpg" alt></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 是老生常谈的集合了，学习 HashMap 主要关注点是<strong>哈希算法、rehash、数据存储、扩容方式、性能区别</strong>和结合ConcurrentHashMap 了解为什么线程不安全，后者怎么解决线程安全问题。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//JDK8中 hashCode 的生成方式</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到，key 不是 null 的情况下，都是取<code>key.hashCode()</code>之后无符号右移16位，然后取异或。这里的<code>key.hashCode()</code>是 native 方法，直接在 JVM 中返回 int 型散列值。</p><blockquote><p>无符号右移&gt;&gt;&gt; ：不管正负标志位为0还是1，将该数的二进制码（补码）整体右移，左边部分总是以0填充，右边部分舍弃。</p><p><code>&gt;&gt;</code>表示右移，如果该数为正，则高位补0，若为负数，则高位补1。</p></blockquote><p>为什么要这么做？</p><p>如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从<code>-2147483648</code>到<code>2147483648</code>。前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p><p>但问题是<strong>一个 40 亿长度的数组，内存是放不下的</strong>。你想，HashMap 扩容之前的数组<strong>初始大小才 16</strong>。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>这也正好解释了为什么 HashMap 的数组长度要取 2 的整次幂。因为这样（数组长度 -1）正好相当于一个“<strong>低位掩码</strong>”。<strong>“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问</strong>。以初始长度 16 为例，16-1=15。2 进制表示是<code>00000000 00000000 00001111</code>。和某散列值做“与”操作如下，结果就是截取了最低的四位值。即</p><pre class="line-numbers language-text"><code class="language-text">      10100101 11000100 00100101&     00000000 00000000 00001111-------------------------------------------------      00000000 00000000 00000101    //高位全部归零，只保留末四位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。</p><p>这时候“<strong>扰动函数</strong>”的价值就体现出来了。看下面这个图:</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-2.jpg" alt></p><p>右位移 16 位，正好是 32bit 的一半，<strong>自己的高半区和低半区做异或</strong>，就是为了混合原始哈希码的高位和低位，以此来<strong>加大低位的随机性</strong>。而且混合后的低位<strong>掺杂了高位的部分特征</strong>，这样高位的信息也被变相保留下来。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>HashMap两个关键的初始化参数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前者是初始化容量 16，即新建一个 HashMap 的时候，如果不指定长度，则容量为 16。</p><p>后者是<strong>加载因子</strong>，即当实际长度除以容量高于该因子的时候，进行扩容操作。默认为 0.75，所以 HashMap 空间占用大于 3/4 的时候就开始扩容了。扩容后的容量是原来的两倍。</p><p>HashMap 的 resize 不是简单的把长度扩大，而是有下面两个步骤：</p><ol><li>扩容：<strong>创建一个新的 Entry 空数组</strong>，长度是原数组的2倍。</li><li>reash：遍历原 Entry 数组，把所有的 Entry <strong>重新 hash</strong> 到新数组。为什么要重新 hash ？因为<strong>长度扩大以后，hash 的规则也随之改变</strong>。</li></ol><p>让我们回顾一下 hash 公式：</p><p><code>index = hashCode(key) &amp; (length - 1)</code></p><p>当原数组长度为 8 时，hash 运算是和<code>111B</code>做与运算；新数组长度为 16，hash 运算是和<code>1111B</code>做与运算。hash 结果显然不同。</p><p>那么这里为什么要用 map 容量减去 1 这个数字？好处有两个：分布均匀、速度更快</p><p>在 HashMap 的源码中。<code>get</code>和<code>put</code>方法会根据 key 的 hash 值找到这个 entry 在 hash 表数组中的位置，源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按照我们理想的状况，hashMap 的存取就是 O（1），也就是直接根据 hashcode 就可以找到它，每个 bucket 只存储一个节点，链表指向都是<code>null</code>，这样就比较开心了，不要出现一个链表很长的情况。</p><p>所以我们希望它能分布的均匀一点，如果让我们设计的话，我们肯定是直接对长度取模：<code>hashcode % length</code>，但 HashMap 的设计者却不是这样写的，它写成了 2 进制运算，因为当容量一定是<code>2^n</code>时，<code>h &amp; (length - 1) == h % length</code>，并且<strong>位运算的速度要高于取模</strong>。</p><p>另外，元素在重新计算 hash 之后，因为 n 变为 2 倍，新的 index 的二进制就是在前面多了一位，比如原来的容量为 8 的时候，元素下标为 5，扩容到 16 之后，根据多的那一位是 0 还是 1，元素下标只需要 +8 或者在原位置就可以了，也就是说 resize 操作也会更快。</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>HashMap 实际是一种“数组+链表”数据结构。在 put 操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称 hash 冲突，链表结构出现的实际意义也就是为了解决 hash 冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。</p><p>在 JDK1.8 中，链表元素数量大于等于 8 将会重组该链表结构形成为“红黑树结构”，这种结构使得在 hash 冲突碰撞过多情况下，<code>get</code>效率比链表的效率高很多。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>在没有哈希冲突的情况下，HashMap 存取元素的时间复杂度是 O（1），但是这只是理想情况。当冲突不多的时候，重复元素以链表形式存储，时间复杂度是 O（N），当数据量大的时候，链表转换为红黑树，时间复杂度变成 O（LogN）</p><h4 id="线程安全和其他局限"><a href="#线程安全和其他局限" class="headerlink" title="线程安全和其他局限"></a>线程安全和其他局限</h4><p>HashMap 不是线程安全的，另外如果 HashMap 的 key 是自定义类，需要重写<code>hashCode()</code>方法，并且由于 HashMap 的效率高度依赖<code>hashCode()</code>，需要保证散列分布尽量均匀。</p><p>哪些环节导致了他线程不安全？</p><p>1、<strong>插入</strong>数据的时候</p><pre class="line-numbers language-java"><code class="language-java">java tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如 A 线程和 B 线程同时添加元素，然后计算出了相同的哈希值对应了相同的数组位置，因为此时该位置还没数据，然后对同一个数组位置添加，B 的写入操作就会覆盖 A 的写入操作造成 A 的写入操作丢失。</p><p>2、<strong>修改</strong>数据跟上边一样</p><p>3、<strong>扩容</strong>的时候</p><p>线程1执行<code>put</code>时，因为元素个数超出<code>threshold</code>而导致 rehash，线程2此时执行<code>get</code>，有可能导致这个问题。</p><p>因为在 resize 的时候，是计算新的容量和<code>threshold</code>，在创建一个新 hash 表，最后将旧 hash 表中元素 rehash 到新的 hash 表中。如果在这个期间，另一个线程执行读取操作，有可能<code>get</code>到<code>null</code>。</p><p>HashMap在resize时候如果多个线程并发操作如何导致<strong>死锁</strong>的。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是继承自HashMap的，跟HashMap最大的区别是，他是基于Hash表和链表的实现，并且<strong>依靠着双向链表保证了迭代顺序是插入的顺序</strong>。</p><p>LinkedHashMap 其实就是可以看成 HashMap 的基础上，多了一个双向链表来维持顺序。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-3.jpg" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-4.jpg" alt></p><p>可以用 LinkedHashMap <strong>实现最近访问算法</strong>，即最近访问过的元素在最前面， LinkedHashMap 有这么一个构造方法。</p><p><code>public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder)</code></p><p><code>accessOrder</code>为<code>true</code>的时候按照元素最后访问时间排序（LRU算法：最近最久使用），为<code>false</code>则是按照插入顺序排序，默认为<code>false</code>.</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 是基于<strong>红黑树</strong>的实现，具有如下特点：</p><ol><li><strong>不允许出现重复的 key</strong>；</li><li>可以插入<code>null</code>键，<code>null</code>值；</li><li>可以对元素进行排序；</li><li><strong>无序</strong>集合（插入和遍历顺序不一致）；</li></ol><p>由于是基于红黑树，TreeMap 在插入、删除、搜索的时候，时间复杂度都是O（LogN）。红黑树的结构单独另外说明，这里就不赘述。</p><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 是专门为<strong>枚举类型</strong>量身定做的Map实现。虽然使用其它的 Map 实现（如HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用<strong>数组</strong>来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。EnumMap 在内部使用枚举类型的<code>ordinal()</code>得到当前实例的声明次序，并使用这个次序维护枚举类型实例对应值在数组的位置。</p><p>在 key 是枚举类的时候，EnumMap 可以用来代替 HashMap，并且由于是数组实现，性能更好。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h4 id="Hashtable-与-HashMap-的简单比较"><a href="#Hashtable-与-HashMap-的简单比较" class="headerlink" title="Hashtable 与 HashMap 的简单比较"></a>Hashtable 与 HashMap 的简单比较</h4><ol><li><strong>HashTable 基于 Dictionary 类</strong>，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li><li>HashMap 的 key 和 value 都允许为<code>null</code>，而 <strong>Hashtable 的 key 和 value 都不允许为<code>null</code></strong>。HashMap 遇到 key 为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对 value 没有处理；Hashtable遇到<code>null</code>，直接返回<code>NullPointerException</code>。</li><li>Hashtable 方法是<strong>同步</strong>，而HashMap则不是。Hashtable 中的几乎所有的 public 的方法都是<code>synchronized</code>的，而有些方法也是在内部通过<code>synchronized</code>代码块来实现。在 Collections 类中存在一个静态方法：<code>synchronizedMap()</code>，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</li><li>HashMap的初始容量为 16，Hashtable<strong>初始容量为 11</strong>，两者的填充因子默认都是0.75。</li><li>两者计算 hash 的方法不同</li></ol><p>Hashtable 计算 hash 是直接使用 key 的 hashcode 对 table 数组的长度直接进行取模</p><pre class="line-numbers language-java"><code class="language-java">java <span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HashMap 计算 hash 对 key 的 hashcode 的前后16为进行了<strong>异或操作</strong>，以获得更好的散列值，然后对table数组长度取模（实际上是<strong>位操作</strong>，增加效率）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> h<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>IdentityHashMap 是一致性哈希表，<strong>使用引用相等</strong>，而不是<code>equals</code>方法来比较两个对象的相等性。因此，IdentityHashMap 中，如果存在两个键 key1 和 key2，当且仅当<code>key1==key2</code>时，两个键相等，而其他大部分的哈希表，当且仅当<code>k1 == null ? k2 == null : k1.equals(k2)</code>时，两个键才认为是相等的。</p><p>IdentityHashMap 使用<code>System.identityHashCode</code>来确定对象的哈希码，<strong>该方法返回对象的地址</strong>。</p><p>HashMap 是通过数组+拉链法存储元素并解决哈希冲突的。IdentityHashMap <strong>将所有的 key 和 value 都存储到<code>Object[]</code>数组 table</strong> 中，并且 key 和 value 相邻存储，当出现哈希冲突时，会往下遍历数组，直到找到一个空闲的位置。注意，数组第一个位置存储的是 key，第二个位置存储的是 value。因此<strong>奇数位置处存储的是 key，偶数位置处存储的是 value</strong>。</p><p>IdentityHashMap 同样允许空的键和值，但是不保证 map 中的顺序，尤其是不保证顺序会恒定不变。</p><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>和 HashMap 一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对（key-value）映射，而且键和值都可以是<code>null</code>。不过 WeakHashMap 的键是“弱键”。</p><p>当弱引用指向的对象只能通过弱引用（没有强引用或弱引用）访问时，GC会清理掉该对象，之后，引用对象会被放到ReferenceQueue中。在 Entry 的构造函数中可以得知，通过<code>super(key, queue)</code>将 key 保存为弱引用，通过<code>this.value = value</code>将 value 保存为强引用。当 key 中的引用被 gc 掉之后，在下次访问 WeakHashMap（调用<code>expungeStaleEntries</code>函数）时相应的 entry 也会自动被移除。</p><p>WeakHashMap 并不是你什么也不干它就能自动释放内部不用的对象的，而是在你<strong>访问它的内容的时候释放内部不用的对象</strong>。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-5.jpg" alt></p><p>LinkedList 和 ArrayList 有什么共同点和区别？</p><p>共同点：</p><ol><li>二者都是继承自 AbstractList 抽象类，AbstractList 实现了 List 接口中除了<code>size()</code>、<code>get(int location)</code>之外的方法。</li><li>二者<strong>都是线程不安全</strong>的。</li></ol><p>区别：</p><ol><li>ArrayList 是实现了<strong>基于动态数组</strong>的数据结构，而 LinkedList 是<strong>基于链表</strong>的数据结构；</li><li>数据更新和查找时，ArrayList 可以直接通过数组下标访问，所以效率更高。</li><li>数据增加和删除的时候，ArrayList 需要移动其他元素的位置，而 LinkedList 只需要修改一个指针，所以后者效率更高。</li></ol><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector 是同样继承于AbstractList的一个列表，而它是线程安全的，实现方式是对所有数据操作的方法添加了 synchronized 关键字。其与 ArrayList 的差别如下：</p><ol><li>构造函数，ArrayList 比 Vector 稍有深度，Vector 默认数组长度为 10，创建是设置。</li><li>扩容方法 <code>grow()</code>，ArrayList 通过位运算进行扩容，而 Vector 则通过增长系数（创建是设置，如果过为空，则增长一倍）</li><li>Vector 方法调用是线程安全的。</li><li>成员变量有所不同</li></ol><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</p><p>他的方法很简单，只有<code>empty()</code>、<code>peek()</code>、<code>pop()</code>、<code>push(Object element)</code>、<code>search(object element)</code>这几个。其中 peek 和 pop 的返回值都是堆栈顶部的对象，但是前者只是查看，后者是移除。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-6.jpg" alt></p><p><strong>其实就是把 HashMap 封装了一层</strong>，从 HashSet 的构造方法可以看出，就是维护了一个 HashMap，数据的增删改查也是调用的 HashMap 的方法。</p><p>TreeSet 也是一样，其实就是 TreeMap 套了个皮。</p><p>EnumSet 就不一样了，跟 EnumMap 其实没有什么关系。EnumSet 是一个 Set 集合的抽象类，其有两个实现类 JumboEnumSet 和 RegularEnumSet，在使用的时候放入的必须是枚举类型，<strong>其特点是速度非常快。</strong></p><p>EnumSet 的默认子类 RegularEnumSet 和 JumboEnumSet 实现原理都是基于位运算向量，位运算向量的原理就是用一个位表示一个元素的状态（元素的状态只有两种），用一组位表示一个集合的状态，每个位对应一个元素，譬如一个枚举类 DemoEnum 有6个枚举值，则 EnumSet 集合就可以通过一个 byte 字节从右到左（二进制低到高位）来表示，不用的位上用 0 填充，用的位上每个 bit 位代表一个枚举值，1 表示包含该枚举值，0 表示不含该枚举值。因此位向量能表示的枚举值个数与向量长度有关，上面例子中一个 byte 类型最多能表示 8 个枚举值，所以 EnumSet 抽象类的两个实现类 RegularEnumSet 和 JumboEnumSet 分别定义了不同的向量长度。RegularEnumSet 使用 64 位的 long 类型变量作为位向量，而 JumboEnumSet 使用一个 long 类型数组作为向量（数组内存连续），故当我们通过 EnumSet 的工厂方法创建 EnumSet 集合时 EnumSet 会通过判断枚举类的枚举值数量决定使用两个子类的哪一个，如果枚举值个数小于等于 64 就用 RegularEnumSet，大于 64 就用 JumboEnumSet。</p><p>简单来说 EnumSet 就是一个高效的枚举类集合。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-7.jpg" alt></p><p>队列（Queue）可以当做一种特殊的线性表，遵循先进先出原则。而双向队列（Deque）,是 Queue 的一个子接口，双向队列是指该队列两端的元素既能入队（offer）也能出队（poll）,如果将 Deque 限制为只能从一端入队和出队，则可实现栈的数据结构。</p><p>PriorityQueue 有一种特殊的队列，叫做<strong>优先队列</strong>。优先队列的作用是能保证每次取出的元素都是队列中权值最小的<strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，</strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。</p><p>Java 中 PriorityQueue 实现了 Queue 接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现。</p><p>最小堆的完全二叉树有一个特性是根节点必定是最小节点，子女节点一定大于其父节点。还有一个特性是叶子节点数量=全部非叶子节点数量+1。</p><p><strong>每次增删元素都有可能对树结构进行调整，所以 PriorityQueue 队列不适合进场出队入队的频繁操作</strong>，但是他的优先级特性非常适合一些对顺序有要求的数据处理场合。</p><h2 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>上面 HashMap 已经说到了 HashMap 在多个线程同时存取或者触发扩容的时候，都有可能出现错误，导致操作被覆盖或者丢失，那么怎么解决这个问题呐？</p><p>第一反应当然是加锁，HashTable 就是这么做的，使用了<code>synchronized</code>关键字。虽然解决了并发访问的安全性问题，但是性能不怎么样。HashTable 中的增删改、甚至<code>equals</code>、<code>toString</code>方法等等都是方法级的锁，所以同时只能一个线程去操作，导致效率问题。</p><p>在JDK1.7及之前版本，ConcurrentHashMap 采用的是 <strong>Segment 分段锁</strong>，即将数据分为一段一段的存储，然后给每一段数据加一把锁。当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>在JDK1.8以后，ConcurrentHashMap <strong>取消了 Segment 分段锁，采用 CAS 和<code>synchronized</code></strong>来保证并发安全。 数据结构与 HashMap 1.8 的结构类似，数组+链表/红黑二叉树（链表长度&gt;8 时，转换为红黑树）。</p><p>通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p><ol><li>加入多个分段锁浪费内存空间。</li><li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li><li>为了提高 GC 的效率。</li></ol><p>在 JDK11 下对 HashMap 和 ConcurrentHashMap 进行了简单测试，生成 5000 万条随机数然后插入，分别消耗 16348 毫秒和 19194 毫秒。其中包括随机数生成、插入和扩容的时间消耗，可见两者之间性能差距不大。</p><p>然后使用 HashTable 在单线程下插入，同样的数据量时间在 17 秒左右，跟 HashMap 差别不大，可以当做是误差范围内。然后使用 20 个线程插入，消耗时间在 15 秒左右，提升并不明显。奇怪的是 ConcurrentHashMap 却使用了 45 秒。然后缩小数据量，在 1000 万以下的时候，ConcurrentHashMap 的插入速度又好于 HashTable 了。这个现象很有意思，有空了详细研究一下产生这个问题的原因。</p><p>ConcurrentHashMap 的<strong>整体性能</strong>要优于 HashTable，但是某些场景不能替代 HashTable，例如<strong>强一致性</strong>的场景，ConcurrentHashMap 的<code>get</code>、<code>size</code>等方法都<strong>没有加锁</strong>，ConcurrentHashMap 是<strong>弱一致性</strong>的。</p><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表。内部是 SkipList（跳表）结构实现，在理论上能够在 O（logN） 时间内完成查找、插入、删除操作。</p><p>ConcurrentHashMap 与 ConcurrentSkipListMap 性能测试 在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是 ConcurrentSkipListMap 的4倍左右。</p><p>但 ConcurrentSkipListMap 有几个 ConcurrentHashMap 不能比拟的优点：</p><p>1、ConcurrentSkipListMap 的 <strong>key 是有序</strong>的。</p><p>2、ConcurrentSkipListMap <strong>支持更高的并发</strong>。ConcurrentSkipListMap 的存取时间是 log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多， ConcurrentSkipListMap 越能体现出他的优势。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>先讲一下什么是<code>Copy-On-Write</code>，通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种<strong>读写分离</strong>的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，<strong>放弃数据实时性达到数据的最终一致性</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> es <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> es<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            es <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            es<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>es<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> es <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            E oldValue <span class="token operator">=</span> <span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>                es <span class="token operator">=</span> es<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                es<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>                <span class="token function">setArray</span><span class="token punctuation">(</span>es<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CopyOnWriteArrayList 的实现也不复杂，对有并发风险的操作加了锁。注意这里的内部数组是<code>volatile</code>修饰的，<strong>写线程对数组引用的修改对读线程是可见的</strong>。由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-collection-8.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的集合主要分为以下集合类：&lt;strong&gt;Map、List、Set、Queue和concurrent&lt;/strong&gt;包里面供多线程环境下使用的以上几种集合类。&lt;/p&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/112
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://arthurjq.com/2021/03/13/kafka/"/>
    <id>https://arthurjq.com/2021/03/13/kafka/</id>
    <published>2021-03-13T13:57:38.000Z</published>
    <updated>2021-03-20T12:44:37.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka架构设计"><a href="#kafka架构设计" class="headerlink" title="kafka架构设计"></a>kafka架构设计</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/kafka-1.jpg" alt></p><p><strong>Consumer Group</strong>：消费者组，消费者组内每个消费者负责消费不同分区的数据，提高消费能力。<strong>逻辑上的一个订阅者</strong>。</p><p><strong>Topic</strong>：可以理解为一个<strong>队列</strong>，Topic将消息分类，<strong>生产者和消费者面向的同一个Topic</strong>，也就是生产者往Topic发，消费者从Topic拿。</p><p><strong>Partition</strong>：为了实现扩展性，提高并发能力，<strong>一个Topic以多个Partition的方式分布到多个Broker上</strong>，每个Partition是一个<strong>有序</strong>的队列。一个Topic的每个Partition都有若干个副本（Replica），一个Leader和若干个Follower。生产者发送数据的对象，以及消费者消费数据的对象，都是Leader。Follower负责实时从Leader中同步数据，保持和Leader数据的同步。Leader发生故障时，某个Follower还会成为新的Leader。</p><p>Offset：消费者消费的位置信息，监控数据消费到什么位置，用于<strong>数据恢复</strong>。</p><p>Zookeeper：Kafka集群能够正常工作，依赖于Zookeeper，<strong>Zookeeper帮助Kafka存储和管理集群信息</strong>，broker的注册（临时节点），注册Topic，重新选举，存储Offset，消费者组中的消费者注册，保证一条消息只被一个消费者组的其中一个消费者消费，消息消费的配置等。</p><h3 id="zk的作用"><a href="#zk的作用" class="headerlink" title="zk的作用"></a>zk的作用</h3><p><strong>/brokers/ids</strong>：临时节点，保存所有broker节点信息，存储broker的物理地址，版本信息，启动时间等，节点名称为brokerID，broker定时发送心跳到zk，如果断开则该brokerID会被删除</p><p><strong>/brokers/topics</strong>：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固定的partitions节点，patitions的子节点就是topic的分区，每个分区下保存一个<strong>state节点，保存着当前leader分区和ISR的brokerID</strong>，<strong>state节点由leader创建</strong>，若leader宕机该节点会被删除，直到有新的leader选举产生，重新生成state节点</p><p>/consumers/[group_id]/<strong>owners</strong>/[topic]/[broker_id-partition_id]：维护消费者和分区的<strong>注册关系</strong></p><p>/consumers/[group_id]/<strong>offset</strong>/[topic]/[broker_id-partition_id]：分区信息的消费进度Offset</p><p>client通过topic找到topic树下的state节点获得leader的brokerID，到broker树中找到broker的物理地址，但是<strong>client不会直连zk</strong>，而是通过配置的broker获取zk中的消息</p><h2 id="消息丢失的场景和解决方案"><a href="#消息丢失的场景和解决方案" class="headerlink" title="消息丢失的场景和解决方案"></a>消息丢失的场景和解决方案</h2><h3 id="消息发送时丢失"><a href="#消息发送时丢失" class="headerlink" title="消息发送时丢失"></a>消息发送时丢失</h3><ol><li><p>ack=0，不重试，producer发送信息完，不管效果，如果发送失败就丢失。</p></li><li><p>ack=1，leader crash，producer发送消息完，只等待lead写入成功就返回，leader crash了，这时如果follower没来得及同步，消息丢失。</p></li><li><p>unclean.leader.election.enable 配置 true</p><p>允许选举ISR以外的副本为leader，会导致数据丢失，默认为false。producer发送异步消息完，只等待lead写入成功就返回了，leader crash了，这时ISR中没有follower，leader从OSR中选举，因为OSR中本来落后于leader造成消息丢失。</p></li></ol><h3 id="消息发送解决方案"><a href="#消息发送解决方案" class="headerlink" title="消息发送解决方案"></a>消息发送解决方案</h3><ol><li><p>配置 <strong>ack = all</strong> / -1（指的是ISR中的所有从节点），tries &gt; 1，unclean.leader.election.enable ：false（不允许选举ISR以外的副本为leader）</p><p>producer发送消息完，等待follower同步完再返回，如果异常则重试，但副本数量影响吞吐量</p></li><li><p>配置 <strong>min.insync.replicas &gt; 1</strong>（同步副本数量指的是ISR中的从节点，<strong>只有ack=all时才会生效</strong>）</p><p>副本指定必须确认写操作成功的最小副本数量。如果不满足这个最小值，则生产者将引发一个异常（NotEnoughReplicas，NotEnoughReplicasAfterAppend）。min.insync.replicas 和 ack 持久性保证，确保如果大多数副本没有收到写操作，则生产者引发异常。</p></li><li><p>失败地offset单独记录</p><p>producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存单独处理。</p></li></ol><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>先commit再处理消息，如果出现异常，但是offset已经提交，消息对于消费者来说丢失了。</p><h3 id="broker的刷盘"><a href="#broker的刷盘" class="headerlink" title="broker的刷盘"></a>broker的刷盘</h3><p>减小刷盘间隔（往pagecache中刷盘的时间）</p><h2 id="Consumer是pull还是push"><a href="#Consumer是pull还是push" class="headerlink" title="Consumer是pull还是push"></a>Consumer是pull还是push</h2><h3 id="pull模式"><a href="#pull模式" class="headerlink" title="pull模式"></a>pull模式</h3><ol><li>根据consumer的消费能力进行数据拉取，可以控制速率</li><li>可以批量拉取或单条拉取</li><li>可以设置不同的提交方式，实现不同的传输语义</li></ol><p>缺点：如果kafka没有数据，会导致consumer<strong>空循环</strong>，消耗资源</p><p>解决：通过参数设置，consumer拉取数据为空或没达到一定数量时阻塞</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>不会导致consumer循环等待</p><p>缺点：速率固定，忽略consumer的消费能力，可能导致拒绝服务或网络拥塞等</p><h2 id="Kafka中高性能的原因"><a href="#Kafka中高性能的原因" class="headerlink" title="Kafka中高性能的原因"></a>Kafka中高性能的原因</h2><p>kafka不基于内存，而是硬盘存储，因此<strong>消息堆积能力更强</strong></p><p><strong>顺序写</strong>：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过 批量操作 节省写入次数，<strong>partition物理上分为多个segment存储，方便删除</strong></p><p>传统和<strong>零拷贝</strong>：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/kafka-2.PNG" alt></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/kafka-3.PNG" alt></p><pre class="line-numbers language-shell"><code class="language-shell">buf = mmap(diskfd, len);write(sockfd, buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>应用程序调用<code>mmap()</code>，磁盘上的数据会通过<code>DMA</code>被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就<strong>不需要把内核缓冲区的内容往用户空间拷贝</strong>。应用程序再调用<code>write()</code>,操作系统直接将内核缓冲区的内容拷贝到<code>socket</code>缓冲区中，这一切都发生在内核态，最后，<code>socket</code>缓冲区再把数据发到网卡去。</p><blockquote><p>kafka不太依赖jvm（存储数据不依赖堆内存），靠OS的pageCache，如果生产者和消费者速率相当，则直接用pageCache交换数据，不需要经过磁盘IO</p></blockquote><h2 id="Rebalance机制"><a href="#Rebalance机制" class="headerlink" title="Rebalance机制"></a>Rebalance机制</h2><p>consumer group中的消费者与topic下的partition重新匹配的过程</p><p>何时会产生rebalance：</p><ol><li>consumer group中的成员个数发生变化</li><li>consumer消费超时</li><li>group订阅的topic个数发生变化</li><li>group订阅的topic的partition数变化</li></ol><p><strong>coordinator</strong>：通常是partition的leader节点所在的broker，负责监控group中consumer的存活，consumer维持到coordinator的心跳来判断consumer的消费超时</p><ol><li>coordinator<strong>通过心跳</strong>返回通知consumer进行rebalance</li><li>consumer请求coordinator加入组，coordinator<strong>选举</strong>产生leader consumer</li><li>leader consumer从coordinator获取获取所有的consumer，<strong>发送syncGroup</strong>（分配信息）给到coordinator</li><li>coordinator通过心跳机制将syncGroup下发给consumer，完成rebalance</li></ol><p>topic或者patition数量发生变化coordinator是不知道的，此时<strong>leader consumer监控topic的变化</strong>，通知coordinator触发rebalance</p><h3 id="rebalance问题"><a href="#rebalance问题" class="headerlink" title="rebalance问题"></a>rebalance问题</h3><p>如果C1消费者消息超时，触发rebalance，重新分配，该消息被其他消费者消费，此时C1消费完成提交offset导致错误</p><p>解决：coordinator每次rebalance，会<strong>标记一个Generation</strong>给到consumer，每次rebalance该Generation会+1，consumer提交offset时，coordinator会比对Generation，不一致则拒绝</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>待补充</p><h2 id="如何保证分布式事务的最终一致性"><a href="#如何保证分布式事务的最终一致性" class="headerlink" title="如何保证分布式事务的最终一致性"></a>如何保证分布式事务的最终一致性</h2><p>分布式事务：业务相关的多个操作，保证同时commit或rollback</p><ol><li>生产者要保证100%的消息投递（事务消息机制，服务质量Quality of Service）</li><li>消费者这端保证幂等性（唯一ID+业务自己实现幂等） </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kafka架构设计&quot;&gt;&lt;a href=&quot;#kafka架构设计&quot; class=&quot;headerlink&quot; title=&quot;kafka架构设计&quot;&gt;&lt;/a&gt;kafka架构设计&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/arthurjq/blogi
      
    
    </summary>
    
      <category term="项目" scheme="https://arthurjq.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="中间件" scheme="https://arthurjq.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo的整体架构设计及分层</title>
    <link href="https://arthurjq.com/2021/03/12/java/dubbo/"/>
    <id>https://arthurjq.com/2021/03/12/java/dubbo/</id>
    <published>2021-03-12T11:59:32.000Z</published>
    <updated>2021-03-13T13:19:06.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五个角色"><a href="#五个角色" class="headerlink" title="五个角色"></a>五个角色</h2><p>注册中心registry：服务注册与发现</p><p>服务提供者provider：暴露服务</p><p>服务消费者consumer：调用远程服务</p><p>监控中心monitor：统计服务的调用次数和调用时间</p><p>容器container：服务允许容器，装载provider</p><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><ol><li>container容器负责启动、加载、运行provider</li><li>provider在启动时，向regisitry中心注册自己提供的服务，基于心跳机制的长连接</li><li>consumer在启动时，向registry中心订阅自己所需的服务</li><li>consumer返回服务提供者列表给consumer，如果有变更，registry将基于<strong>长连接</strong>推送变更数据给consumer</li><li>consumer调用provider服务，基于负载均衡算法调用</li><li>consumer调用provider的统计，基于短链接定时每分钟一次统计到monitor</li></ol><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>接口服务层（Service）：面向开发者，业务代码，接口，实现等</p><p>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为配置中心去加载我们的配置和维护我们的配置，当有变化时通常使用Zookeeper去通知客户端</p><p>服务代理层（Proxy）：对于生产者和消费者、dubbo都会<strong>产生一个代理类封装调用细节</strong>，业务层对远程调用无感</p><p>服务注册层（Registry）：封装服务地址的注册和发现，以URL为中心，通常使用ZK</p><p>路由层（Monitor）：封装多个提供者的路由和负载均衡，并桥接注册中心</p><p>监控层（Monitor）：RPC调用次数和调用时间监控</p><p>远程调用层（Protocal）：封装RPC调用（基于TCP）</p><p>信息交换层（Exchange）：封装请求响应模式，同步转异步</p><p>网络传输层（Transport）：抽象mina 和 netty 为统一接口，<strong>统一网络传输接口</strong></p><p>数据序列化层（Serialize）：数据传输的序列化和反序列化</p><p><strong>没有解决服务熔断，服务降级</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;五个角色&quot;&gt;&lt;a href=&quot;#五个角色&quot; class=&quot;headerlink&quot; title=&quot;五个角色&quot;&gt;&lt;/a&gt;五个角色&lt;/h2&gt;&lt;p&gt;注册中心registry：服务注册与发现&lt;/p&gt;
&lt;p&gt;服务提供者provider：暴露服务&lt;/p&gt;
&lt;p&gt;服务消费者con
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java进阶</title>
    <link href="https://arthurjq.com/2021/03/10/java-advance/"/>
    <id>https://arthurjq.com/2021/03/10/java-advance/</id>
    <published>2021-03-10T11:21:38.000Z</published>
    <updated>2021-03-29T02:39:02.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前或之后额外做一些事情。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>实际上就是个<strong>map（key，value）</strong>，里面存各种对象（在xml里配置的bean节点、@Component、@Controller），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放进map里、扫描到注解的类还是通过反射创建对象放到map。</p><p> 在代码需要用到里面对象时，再通过DI注入（autowired、resource等，xml里bean节点内的ref属性，项目启动时会读取xml节点ref属性根据id注入，也会扫描这些注解根据类型或id注入，id就是对象名）。</p><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>当A运行到需要B时，IOC容器会主动创建一个B注入到对象A需要的地方。对象A获得依赖对象B的过程，由<strong>主动行为变为了被动行为</strong>。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>实现IOC的方法</strong>，IOC容器在运行期间，动态地将某种依赖关系注入到对象中。</p><h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><p><strong>ApplicationContext是BeanFactory的子接口</strong>，提供了更完整的功能：</p><ol><li>继承MessageSource，因此<strong>支持国际化</strong>，比如可以用MessageSource实现资源文件的读取（MessageSource接口中的getMessage方法）</li><li>统一的资源文件访问方式</li><li>提供在监听器中注册bean的事件（疑惑）</li><li>同时加载多个配置文件</li><li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><p>不同点：</p><ol><li>BeanFactory延迟加载注入Bean，而ApplicationContext在容器启动时一次性创建所以的Bean，这样<strong>有利于检查所依赖属性是否注入</strong>，无需等待，不足是占用内存空间</li><li>BeanFactory通常以编程方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li><li>他们都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，区别：BeanFactory需要手动注册，而ApplicationContext则是自动注册</li></ol><blockquote><p>BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改。</p><p>BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。</p></blockquote><h2 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h2><p>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</p><p>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</p><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p><p><a href="https://arthurjq.com/2020/12/29/java/spring-bean-life-cycle/">https://arthurjq.com/2020/12/29/java/spring-bean-life-cycle/</a></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-7.jpg" alt></p><p>三级缓存（解决循环依赖）：</p><p>一级：singletonObjects map&lt;beanName，Object&gt; （单例池）</p><p>二级：earlySingletonObjects map&lt;beanName，Object&gt; （提前AOP）</p><p>三级：singletonFactories （放了个lambda）</p><p>earlyProxyReferences ConcurrentHashMap&lt;beanName，bean的原始对象&gt;（循环引用时记录是否提前生成了代理对象）</p><p>creatingSet （）</p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>假设Aservice和Bservice互相依赖，当Aservice出现循环依赖的话会提前AOP</p><ol><li>creatingSet.add（Aservice）</li><li>class→实例化得到Aservice原始对象→singletonFactories map&lt;beanName，lambda（beanName，BeanDefinition，Aservice原始对象）&gt;</li><li>给Bservice属性赋值→从单例池找Bservice→找不到→创建Bservice的bean<ol><li>class→实例化得到Bservice原始对象</li><li>给Aservice属性赋值→从单例池找Aservice→找不到→creatingSet→Aservice出现循环→earlySingletonObjects→singletonFactories→lambda→AOP→Aservice代理对象→放入二级缓存（调用getEarlyBeanReference（）提前生成代理对象）</li><li>给其他属性赋值</li><li>其余AOP</li><li>将对象放入单例池</li></ol></li><li>给其他属性赋值</li><li>其余事情AOP→Aservice代理对象→postProcessAfterInitialization（）（看earlyProxyReferences有没有提前生成代理对象）</li><li>earlySingletonObjects.get（Aservice）</li><li>creatingSet.remove（Aservice）</li><li>将对象放入单例池</li></ol><h2 id="Spring-Bean作用域"><a href="#Spring-Bean作用域" class="headerlink" title="Spring Bean作用域"></a>Spring Bean作用域</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-1.jpg" alt></p><h2 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p><p>BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建根据具体情况来定。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>实现了FactoryBean接口的bean，spring会在使用getBean（）调用获得该bea n时，会自动调用该bean的getObject（）方法，所以返回的不是factory这个bean，而是这个bean.getObject（）方法的返回值。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>Spring提供了全局的访问点BeanFactory，但是没有从构造器级别时控制单例，这是因为spring管理的是任意的java对象。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>Spring定义了一个适配接口，使每一种Controller有一种对应的适配器实现类（SpringMVC中HandlerAdapter），让适配器代替Controller执行相应的方法（Handler）。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>动态地给一个对象添加一些额外的职责。增加功能比生成子类更加灵活。</p><p>Spring中用到的装饰器模式在类名上有两种表现：1、类名中含有wrapper；2、类名中含有Decorator；3、InputStream，outputStream</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>切面在应用运行的时候被织入。在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。</p><p>在一个方法上加了@Transactional（申明式事务）注解后，Spring会<strong>基于这个类生成一个代理对象</strong>，Autowired后getBean从AOP容器中取得代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，代理逻辑会先把事务的自动提交设置为false。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Spring的事件驱动模型使用的是观察者模式，ApplicationContext事件机制是观察者模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>Spring框架的资源访问Resource接口，该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Resource</span> <span class="token keyword">extends</span> <span class="token class-name">InputStreamSource</span> <span class="token punctuation">{</span> <span class="token keyword">boolean</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">boolean</span> <span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> URL <span class="token function">getURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> URI <span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> File <span class="token function">getFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> <span class="token keyword">long</span> <span class="token function">contentLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> <span class="token keyword">long</span> <span class="token function">lastModified</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> Resource <span class="token function">createRelative</span><span class="token punctuation">(</span>String relativePath<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span> String <span class="token function">getFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h2><h3 id="autowire属性五种装配方式"><a href="#autowire属性五种装配方式" class="headerlink" title="autowire属性五种装配方式"></a>autowire属性五种装配方式</h3><h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>缺省情况下，自动配置时通过“ref”属性手动设定。</p><p>手动装配：以value或ref的方式明确指定属性值</p><h4 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h4><p>根据bean的属性名称进行自动装配</p><p>Customer的属性名称为person，Spring会将bean id为person的bean通过setter方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h4><p>根据bean的类型进行自动装配</p><p>Customer的属性person的类型为Person，Spring会将Person类型通过setter方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型相同，则进行自动装配，否则导致异常。</p><p>Customer构造函数的参数person的类型为Person，Spring会将Person类型通过构造方法进行自动装配</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>customer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>constructor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="autodetect"><a href="#autodetect" class="headerlink" title="autodetect"></a>autodetect</h4><p>如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配</p><h4 id="Autowired自动装配bean"><a href="#Autowired自动装配bean" class="headerlink" title="@Autowired自动装配bean"></a>@Autowired自动装配bean</h4><p>可在<strong>字段，setter方法，构造函数</strong>上使用。</p><h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。（Map&lt; url , handler &gt;，其中url可以是bean id、@RequestMapping、key）</li><li>HandlerMapping找到具体的处理器（可以根据xml配置、注解进行查找），生成handler及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器（Controller接口定义整个类为一个Handler、@RequestMapping定义方法、Servlet三种方法都有各自的适配器，support方法遍历适配器，找到后执行handle调用真正的handler）</li><li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet把ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图（将模型数据填充至视图中，比如JSP）</li><li>DispatcherServlet响应用户</li></ol><h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-2.jpg" alt></p><h2 id="和"><a href="#和" class="headerlink" title="#{ }和${ }"></a>#{ }和${ }</h2><p>#{ }是预编译处理，是占位符，${ }是字符串替换，是拼接符</p><ol><li>Mybatis在处理#{ }时，会将sql中的#{ }替换为 ？号，调用PreparedStatement来赋值（会自动加单引号）；</li><li>在处理${ }时，就是替换成变量值，调用Statement来赋值；</li></ol><blockquote><p><strong>绝大多数需求为单条记录查询时可以选择哈希索引</strong></p><p><strong>定义有外键的数据列一定要建立索引</strong></p></blockquote><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><ol><li>是否load了额外的数据</li><li>锁</li><li>刷新脏页redo log在持久化</li><li>是否走索引</li><li>从库在执行sql</li><li>横向或纵向分表</li></ol><h2 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h2><ol><li><p>A由<strong>undo log</strong>日志保证，它记录了<strong>需要回滚的日志信息</strong>，事务回滚时撤销已经执行成功的sql</p></li><li><p>C由其他三大特性保证，<strong>程序代码</strong>要保证业务上的一致性</p></li><li><p>I由<strong>MVCC</strong>来保证</p></li><li><p>D由<strong>内存 + redo log</strong>来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复。redo log记录了<strong>数据修改的状态</strong></p><blockquote><p>InnoDB redo log写盘，InnoDB 事务进入prepare 状态。</p><p>如果前面 prepare成功，binlog 写盘，再继续将事务日志持久化到binlog。如果持久化成功，那么InnoDB事务则进入commit状态（在 redo log里面写一个commit记录）</p><p>所以说如果redo log中由commit，说明binlog持久化成功</p></blockquote><p>redo log的刷盘会在系统空闲时进行。（Mysql的主从同步（复制）通过binlog来同步）</p></li></ol><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><strong>多版本并发控制</strong>（Multi-Version Concurrency Control）：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p><p>MVCC只在 READ COMMITED 和REPEATABLE READ 下工作。因为READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而serializable则会对所有读取的行都加锁。</p><p>聚簇索引记录中有两个必要的隐藏列：</p><ol><li><strong>trx_id</strong>：用来存储每次对某条聚簇索引记录进行修改的时候的事务id</li><li><strong>roll_pointer</strong>：每次对聚簇索引修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了个<strong>指针</strong>，指向<strong>索引记录的上一个版本</strong>的位置。（注意插入操作的undo日志没有这个属性，因为它没有老版本）</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-3.jpg" alt></p><h2 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-2.png" alt="mysql主从复制"></p><p>主要由三个线程：master（binlog dump thread）、slave（I / O thread、SQL thread）</p><ol><li>主节点binlog，主从复制的基础是<strong>主库记录数据库的所有变更记录到binlog</strong>。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li><li>主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。</li><li>从节点I /O 线程接受binlog 内容，并将其写入到relay log 文件中。（relay log在从节点）</li><li>从节点的SQL线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库一致性。</li></ol><p>注：主从节点使用 <strong>binlog文件 + position</strong> 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置同步。</p><p>mysql默认的复制方式是异步的，主库把日志发送给从库不关心从库是否已经处理。有一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库，日志丢失了。</p><p><strong>全同步复制</strong>：主库写入binlog后强制同步日志到从库，<strong>所有</strong>从库执行完才返回客户端。</p><p><strong>半同步复制</strong>：从库写入日志成功后返回ACK确认给主库，主库<strong>收到至少一个</strong>从库的确认就认为完成。</p><h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><p>DNS方式实现负载均衡</p><p>硬件负载均衡：F5和A10</p><p>软件负载均衡：</p><ol><li><strong>Nginx</strong>：七层负载均衡，支持HTTP、E-mail协议，同时也支持4层负载均衡（解析url，与客户端和服务端都要保持长连接，性能损耗）</li><li><strong>HAproxy</strong>：支持七层规则，性能不错。OpenStack 默认使用</li><li><strong>LVS</strong>：运行在内核态，性能最高，严格说工作在第三层（ip——&gt;Server）</li></ol><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ol><li>轮询法：按顺序轮流分配</li><li>加权轮询：按照权重分配到后端</li><li>随机法</li><li>加权随机法</li><li>ip_hash法，解决session共享问题</li><li>最小连接数法，看谁最空闲</li></ol><h2 id="分布式下Session共享方案"><a href="#分布式下Session共享方案" class="headerlink" title="分布式下Session共享方案"></a>分布式下Session共享方案</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-4.jpg" alt></p><h2 id="分布式锁解决方案"><a href="#分布式锁解决方案" class="headerlink" title="分布式锁解决方案"></a>分布式锁解决方案</h2><p>需要这个锁独立于每一个服务之外，而不是在服务里面。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>利用<strong>主键冲突</strong>控制一次只有一个线程能获取锁，非阻塞（要自己写阻塞代码）、不可重入（递归不支持，要自己实现AQS）、单点、不支持失效时间（要自己写定时器）</p><p>比如在数据库中建张表，采用唯一约束，要获得锁就往数据库中插入同一个key的记录放到唯一键上面，如果放进去了就是拿到锁了。</p><h3 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h3><p>zk通过Znode解决<strong>死锁</strong>问题，一旦客户端获取锁后突然挂掉，这个临时节点会自动删除，其他客户端自动获取锁。</p><p>临时顺序节点解决<strong>惊群效应</strong>（所有处于阻塞状态的线程去争抢资源获取锁）。</p><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>setNX命令，<strong>单线程处理网络请求</strong>，不需要考虑并发安全性。</p><p>Redis是个第三方中间件，在集群中很方便地实现分布式锁，所有服务节点设置相同地key，返回0则获取锁失败，T1申请到key后T2肯定申请不到。</p><h4 id="setNX问题"><a href="#setNX问题" class="headerlink" title="setNX问题"></a>setNX问题</h4><ol><li>早期版本<strong>没有超时参数</strong>，需要单独设置，存在死锁问题（key不会超时）</li><li>后期版本提供加锁和设置时间原子操作（set（NX，timeout）），但是存在任务超时，锁自动释放，导致<strong>并发问题</strong>，加锁和释放锁不是同一线程问题（假如T1获得锁要执行15s，锁失效时间为10s，在这5s内T2获得了锁，T1执行完了要把锁释放掉，结果把T2的锁释放了，解决方法可以在value中存上线程的唯一标识或者uuid）</li></ol><p>删除锁：<strong>判断线程唯一标识再删除</strong></p><p>可重入性及<strong>锁续期</strong>没有实现，通过redisson解决（类似AQS实现（count计数），看门狗监听机制（设置一个监听器监听任务，任务没有执行完就延长过期时间））</p><p><strong>redlock</strong>：以上的机制都只操作单节点，即使Redis通过Sentinel保证高可用，如果这个master节点由于某些发生了主从切换，那么就会出现锁丢失的情况（主从节点间是异步通信，Redis同步设置可能数据丢失）。redlock从多个节点申请锁，当一半以上节点获取成功才算成功，redisson有相应的实现</p><h2 id="SpringCloud和Dubbo区别"><a href="#SpringCloud和Dubbo区别" class="headerlink" title="SpringCloud和Dubbo区别"></a>SpringCloud和Dubbo区别</h2><p>底层协议：springcloud基于http协议，dubbo基于tcp协议</p><p>注册中心：springcloud使用eureka，dubbo推荐使用zookeeper</p><p>模型定义：dubbo将<strong>一个接口定义为一个服务</strong>，springcloud将一个应用定义为一个服务</p><p>springcloud是一个生态，而dubbo是springcloud生态中关于服务调用一种解决方案（服务治理）</p><h2 id="Hystrix实现机制"><a href="#Hystrix实现机制" class="headerlink" title="Hystrix实现机制"></a>Hystrix实现机制</h2><p>分布式容错框架：熔断降级监控</p><h3 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h3><ol><li>线程隔离：Hystrix会给每个Command分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响</li><li>信号量隔离：客户端向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，当并发量超过信号量个数时，后续的请求都会直接拒绝，进入fallback流程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。</li></ol><h3 id="熔断和降级"><a href="#熔断和降级" class="headerlink" title="熔断和降级"></a>熔断和降级</h3><p>调用服务失败后快速失败</p><p>熔断：为了防止异常不扩散，保证系统的稳定性</p><p>降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不至于直接报错，只是服务水平下降</p><ol><li>通过HystrixCommand或者HystrixObservableCommand将所有的外部系统（依赖）包装起来，整个包装对象是单独运行在一个线程之中（这是典型的命令模式）。</li><li>超时请求应该超过你定义的<strong>阈值</strong></li><li><strong>为每个依赖关系维护一个小的线程池</strong>（或信号量）；如果它满了，那么依赖关系的请求将立即被拒绝，而不是排队等待。</li><li>统计成功，失败（由客户端抛出的异常），超时和线程拒绝。</li><li>打开<strong>断路器</strong>可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，手动或自动地关闭断路器。</li><li><strong>当请求被拒绝、连接超时或者断路器打开，直接执行fallback</strong>。</li><li>近乎实时监控指标和配置变化。</li></ol><h2 id="RabbitMQ如何保证消息发送接收？"><a href="#RabbitMQ如何保证消息发送接收？" class="headerlink" title="RabbitMQ如何保证消息发送接收？"></a>RabbitMQ如何保证消息发送接收？</h2><h3 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h3><p>信道需要设置为confirm模式，则所有在信道上发布的消息都会<strong>分配一个唯一 ID</strong>。</p><p>一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一ID）。</p><p>如果RabbitMQ 发生内部错误从而导致消息丢失，会发送一条nack（未确认）消息给生产者。</p><p>所有被发送的消息都将被confirm（即 ack）或者被nack一次。但是<strong>没有对消息被confirm的快慢做任何保证</strong>，并且同一条消息不会即被confirm又被nack。</p><p>发送方确认模式是<strong>异步</strong>的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者，生产者的回调方法会被触发。</p><blockquote><p>ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调，其中的confirm（ID）方法返回给生产者</p><p>ReturnCallback接口：消息失败返回时回调</p></blockquote><h3 id="消费者的确认"><a href="#消费者的确认" class="headerlink" title="消费者的确认"></a>消费者的确认</h3><p>消费者在声明队列时，可以指定noAck参数，当noAck = false时，RabbitMQ会等待消费者显式发回ack信号后才从内存（或者硬盘，持久化消息）中移除（手动提交），否则，消息被消费后立即删除。</p><p>如果noAck = false，消费者接受每一条消息后都必须确认，只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。</p><p>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这样设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长（也起到<strong>限流</strong>的作用），保证数据的最终一致性。<strong>因为如果消费者不返回ack的话，RabbitMQ也不知道消费者是否处理完了没有，擅自把消息发给其他消费者或者删除都会导致数据不一致</strong>。</p><p>如果消费者返回ack之前断开了链接。RabbitMQ会重新发送给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要业务方保持数据一致，幂等性）</p><h2 id="RabbitMQ事务消息"><a href="#RabbitMQ事务消息" class="headerlink" title="RabbitMQ事务消息"></a>RabbitMQ事务消息</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-5.jpg" alt></p><h2 id="RabbitMQ死信队列和延时队列"><a href="#RabbitMQ死信队列和延时队列" class="headerlink" title="RabbitMQ死信队列和延时队列"></a>RabbitMQ死信队列和延时队列</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h2&gt;&lt;p&gt;将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java的守护线程</title>
    <link href="https://arthurjq.com/2021/03/09/java/daemon-thread/"/>
    <id>https://arthurjq.com/2021/03/09/java/daemon-thread/</id>
    <published>2021-03-09T06:56:38.000Z</published>
    <updated>2021-03-10T02:14:37.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>用户线程</strong>即运行在前台的线程，而<strong>守护线程</strong>是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，比如垃圾回收线程就是一个守护线程。</p><p>其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以Daemon Thread也就退出了。</p><p>简单的讲就是<strong>JVM的退出不用考虑守护线程的退出，而必须考虑用户线程的退出</strong>。</p><p>用户也可以<strong>自行的设定守护线程</strong>，方法：<code>public final void setDaemon(boolean on)</code> ；但是有几点需要注意：</p><ol><li>thread.setDaemon（true）必须在thread.start（）之前设置，否则会跑出一个IllegalThreadStateException异常。<strong>你不能把正在运行的常规线程设置为守护线程</strong>。 （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</li><li>在Daemon线程中产生的新线程也是Daemon的。 （这一点又是有着本质的区别了：守护进程fork（）出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</li><li>守护线程<strong>不能用于去访问固有资源</strong>，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了</li><li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li></ol><p>转载：<a href="https://blog.csdn.net/lc1010078424/article/details/79613348" target="_blank" rel="noopener">https://blog.csdn.net/lc1010078424/article/details/79613348</a></p><h2 id="Daemon-Thread实际应用"><a href="#Daemon-Thread实际应用" class="headerlink" title="Daemon Thread实际应用"></a>Daemon Thread实际应用</h2><h3 id="web服务器中的Servlet"><a href="#web服务器中的Servlet" class="headerlink" title="web服务器中的Servlet"></a>web服务器中的Servlet</h3><p>web服务器中的Servlet，容器启动时后台初始化一个服务线程，即调度线程，负责处理http请求；</p><p>每个请求过来调度线程从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。</p><h3 id="Java的Timer"><a href="#Java的Timer" class="headerlink" title="Java的Timer"></a>Java的Timer</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Calendar<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Timer<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimerTaskRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统当前时间："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calendar<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上写法任务虽然运行完了，但进程还未销毁，为什么会出现这种情况呢？</p><p>可以看一下Timer的源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"Timer-"</span> <span class="token operator">+</span> <span class="token function">serialNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出<strong>每创建一个Timer就是启动一个新的线程，那么启动的线程不是守护线程，所以一直运行</strong>。那我们该如何将 新创建的的Timer 改成守护线程呢？更改如上的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimerTaskRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统当前时间："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calendar<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>SECOND<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//设置Timer为true</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果只想执行一次等待执行完之后调用timer.cancel（）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用户线程&lt;/strong&gt;即运行在前台的线程，而&lt;strong&gt;守护线程&lt;/strong&gt;是运行在后台的线程。 守护线程作用
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
      <category term="thread" scheme="https://arthurjq.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="https://arthurjq.com/2021/03/09/interview/"/>
    <id>https://arthurjq.com/2021/03/09/interview/</id>
    <published>2021-03-09T05:38:38.000Z</published>
    <updated>2021-04-01T13:14:58.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是高效的面试"><a href="#什么是高效的面试" class="headerlink" title="什么是高效的面试"></a>什么是高效的面试</h2><p><strong>自信</strong></p><h2 id="要怎么准备"><a href="#要怎么准备" class="headerlink" title="要怎么准备"></a>要怎么准备</h2><p><strong>拉伸知识的广度</strong>：了解互联网的主要技术栈，形成知识网络</p><p><strong>提升知识的深度</strong>：由浅入深，由点到面，对每个技术栈形成梯度，整理梳理。每个梯度都要准备1到2个由代表性的高频面试题。（种子）</p><h2 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h2><p><strong>一、Java如何开启线程？怎么保证线程安全？</strong></p><p>线程和进程的区别：进程是操作系统进行<strong>资源分配</strong>的最小单元。线程是操作系统进行<strong>任务分配</strong>的最小单元，线程隶属于进程。</p><p>如何开启线程？1、继承Thread类，重写run方法。2、实现Runnable接口，实现run方法。3、实现Callable接口，实现call方法。通过FutureTask创建一个线程，获取到线程执行的返回值。4、通过线程池开启线程。</p><p>JVM的Synchronized和JDK提供的Lock</p><p><strong>二、volatile和Synchronized？volatile能不能保证线程安全？DCL（Double Check Lock）单例模式为什么要加volatile？</strong></p><p>1、Synchronized用来加锁。volatile只能保证变量的线程可见性和有序性。通常用于一个线程写，多个线程读的情况。</p><p>2、不能，volatile不保证原子性。</p><p>3、volatile防止指令重排序。在DCL中，防止高并发情况下，指令重排造成的线程安全问题。（int i= 1；分三步1，分配内存2，对象初始化3，建立指针关系）</p><p><strong>三、java线程锁机制？偏向锁，轻量级锁，重量级锁？如何升级</strong></p><p>1、就是在对象头第一个字节后三位中记录一个<strong>锁状态</strong>。1位是否偏向，2位锁标志</p><p>2、java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</p><p><strong>四、AQS（AbstractQueuedSynchronizer）？AQS如何实现可重入锁</strong></p><p>1、AQS是一个java<strong>线程同步框架</strong>，是jdk中很多锁工具的核心实现框架。</p><p>2、维护了state信号量和一个线程组成的双向链表队列，这个线程队列用来给线程排队的。</p><p><strong>五、</strong>CountDownLatch（模拟高并发），CylicBarrier（满足个数才走），Semaphore（给排队的线程一个权重，交错执行）</p><h2 id="网络通信篇"><a href="#网络通信篇" class="headerlink" title="网络通信篇"></a>网络通信篇</h2><p><strong>一、TCP和UDP</strong></p><p>Transfer Control Protocol 面向连接，可靠的传输层协议</p><p>close_wait，time_wait 2MSL最长报文段寿命</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-6.jpg" alt></p><p>User Datagram Protocol 无连接，不可靠的传输层协议</p><p>Ø 同步：客户端在发送请求之后必须等到服务器回应之后才可以发送下一条请求。串行运行</p><p>Ø 异步：客户端请求之后，不必等到服务器回应之后就可以发送下一条请求。并行运行</p><p><strong>二、NIO、AIO</strong></p><p>同步非阻塞，解决了BIO中线程太多的问题，引入了Selector，不过还是要检查有没有处理完</p><blockquote><p><strong>异步是针对请求，阻塞、非阻塞是针对客户端</strong></p></blockquote><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-7.jpg" alt></p><p>AIO：后端有一个异步请求队列，服务端处理完之后放入队列，通过队列把响应推给客户端，解决了服务端一直守着线程的问题</p><p>然而异步通知的过程服务是没法做的，需要操作系统的支持，因为服务是不稳定的。</p><p><strong>三、NIO的组件</strong></p><p>client→<strong>Buffer→Channel→Selector</strong>→Thread</p><p>Channel类似于“流”。每个Channel对应一个Buffer缓冲区。Channel会注册到selector。</p><p>Selector会根据Channel上发生的读写事件，将请求交由某个空闲的线程处理。底层是epoll实现，有两个集合，socketchannel集合和就绪事件集合</p><p>buffer和channel都是<strong>全双工</strong></p><p><strong>四、select、poll和epoll（API）</strong></p><p>他们是NIO中多路复用的三种实现机制，由LinuxOS提供。</p><p><strong>文件描述符</strong> File Descriptor（FD）：形式上是个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开或创建一个文件时，内核就会向进程返回一个FD。</p><ol><li>Select机制：会维护一个FD的<strong>数组</strong> fd_set。将fd_set从用户空间复制到内核空间，激活socket。最大为2048</li><li>Poll机制：和select机制差不多，把fd_set结构进行优化换成了<strong>链表</strong>实现，FD集合的大小突破了OS的限制</li><li>EPoll（<strong>红黑树</strong>）：Event Poll，epoll不再扫描所有的FD，只将用户关心的FD事件放到内核的一个事件表中。减少用户空间和内核空间之间需要拷贝的数据</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-8.jpg" alt></p><p><strong>五、http和https</strong></p><ol><li>https要<strong>ca证书</strong>，要钱</li><li>传输协议不同，https443端口，而http80端口</li><li>http的连接是简单无状态的，https的数据传输时经过证书加密的</li></ol><h2 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h2><p><strong>一、JVM内存模型</strong></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-4.jpg" alt="JMM"></p><p><strong>二、类加载过程，双亲委派，一个对象从加载到JVM，到被GC清除经历了什么过程？</strong></p><p><strong>类加载过程</strong>：加载→验证→准备→解析→初始化</p><p>加载：把Java的字节码数据加载到JVM内存（方法区）中，并映射成JVM认可的数据结构。</p><p>验证：检查加载到的字节信息是否符合JVM规范。（比如.class字节码文件开头的CA FE BA BE）</p><p>准备：创建<strong>类或接口</strong>的静态变量，并赋初始值，<strong>半初始化</strong>状态（在堆中初始化，classpoint指向元空间的class）</p><p>解析：把符号引用转为直接引用（在栈里初始化指针，指向堆里面的内存）</p><p>初始化：执行类构造器clinit方法，静态变量赋值和静态代码块，如果类构造器方法中触发了对象初始化（init方法），会执行init方法之后回来继续执行clinit方法。</p><p><strong>类加载器</strong>：AppClassloader→ExtClassloader→BootStrap Classloader（在Java中不是继承关系）</p><p>每个类加载器对他加载过的类，都有一个缓存</p><p>双亲委派：<strong>向上委托查找，向下委托加载</strong></p><p><strong>一个对象的一生</strong>：</p><ol><li>用户创建了一个对象，JVM首先需要到方法区去找对象的类型信息。然后再创建对象。</li><li>JVM实例化一个对象，首先要在堆中创建一个对象。→半初始化状态</li><li>对象首先会分配在堆中的Eden，然后经过一次Minor GC，对象如果存活就进入S区。在后续的每次GC中如果对象一直存活，就会在S区来回拷贝，每移动一次年龄加一（4bit）。超过一定年龄后对象转入老年代。</li><li>当方法执行结束后，<strong>栈中指针先移除</strong></li><li>堆中的对象，经过Full GC，就会被标记为垃圾被GC线程清除。</li></ol><p><strong>三、确定垃圾，GC root</strong></p><p>引用计数：给堆内存中的每个对象记录一个引用计数。无法解决循环引用</p><p>可达性分析：从GC root向下一直找引用，找不到就是垃圾。</p><p>GC Root：Stack→JVM Stack，Native Stack，方法区→static，Class类，常量池</p><p><strong>四、垃圾回收算法</strong></p><p>MarkSweep 标记清除</p><p>Copying 复制</p><p>MarkCompact 标记压缩</p><p><strong>五、垃圾回收器，STW发生在哪些阶段，三色标记，如何解决错标和漏标？为什么设计这么多垃圾收集器？</strong></p><p>Serial 串行：只有一个线程在GC</p><p>Parallel 并行：多线程GC，PS+PO是JDK1.8默认的垃圾回收器</p><p>Concurrent Mark Sweep：将STW打散， 让一部分GC线程和用户线程并发执行。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-1.jpg" alt="CMS"></p><ol><li>初始标记：STW，只标记出GC Roots直接引用的对象。</li><li>并发标记：继续标记其他对象，并发执行。</li><li>重新标记：STW，对并发执行阶段的对象进行重新标记。</li><li>并发清除：并发将产生的垃圾清除。</li></ol><p>G1 Garbage First 垃圾优先</p><p>对堆内存不在分old和eden，而是划分为一个一个小内存块Region。每个Region可以隶属于不同的年代。</p><ol><li>初始标记：STW，标记出GC Roots直接引用的Region。</li><li>标记Region：通过RSet标记出初始标记的Region引用的Old区Region。</li><li>并发标记：跟CMS差不多，只需遍历第二步标记出的Region。</li><li>最终标记：STW，跟CMS差不多。</li><li>筛选回收：跟CMS不同，G1可以采用<strong>拷贝算法</strong>。这个阶段G1只选择垃圾较多的Region清理。</li></ol><p>CMS核心算法就是三色标记。</p><p>CMS通过增量标记 increment update 方式来解决漏标问题</p><p>G1通过SATB（Snapshot at the Beginning）将所有即将被删除的引用关系的旧引用记录下来。</p><p><strong>六、如何JVM调优？JVM参数，怎么查看JAVA进程的JVM参数，谈谈你了解的jvm参数。一个java程序每运行一段时间后都变得非常卡顿，如何优化？</strong></p><p>通过定制JVM运行参数来提高JAVA应用程度的运行。</p><p>JVM参数大致分为三类：</p><ol><li>标注指令：-开头，所有HotSpot都支持的指令。java -help</li><li>非标准指令：-X开头，跟特定的HotSpot版本对应。java -X</li><li>不稳定指令：-XX开头，变化大。如java -XX:+PrintCommandLineFlags：查看当前命令的不稳定指令。java -XX:+PrintFlagsInitial：查看所有不稳定指令的默认值。java -XX:+PrintFlagsFinal：查看所有不稳定指令最终生效的实际值。</li></ol><p><a href="https://arthurjq.com/2021/03/16/java/jvm-tuning/">https://arthurjq.com/2021/03/16/java/jvm-tuning/</a></p><h2 id="缓存篇"><a href="#缓存篇" class="headerlink" title="缓存篇"></a>缓存篇</h2><p><strong>一、为什么使用缓存</strong></p><p>高性能、高并发</p><p><strong>二、缓存击穿，缓存雪崩，缓存穿透</strong></p><p>并发查同一条数据，同一时间大面积失效，并发查不存在的数据</p><p><strong>三、如何保证redis和数据库的一致性</strong></p><ol><li>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</li><li>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li></ol><p>没有什么方案是完美的，先更新数据库，然后删除缓存，删除缓存时，把key放到消息队列，直到删除成功。</p><p><strong>四、如何设计一个分布式锁，如何对锁性能优化</strong></p><p>数据库利用<strong>主键冲突</strong>控制一次只有一个线程能获取锁，非阻塞（要自己写阻塞代码）、不可重入（递归不支持，要自己实现AQS）、单点、不支持失效时间（要自己写定时器）</p><p>zk通过Znode解决<strong>死锁</strong>问题，一旦客户端获取锁后突然挂掉，这个临时节点会自动删除，其他客户端自动获取锁。临时顺序节点解决惊群效应。</p><p>setNX命令，单线程处理网络请求，不需要考虑并发安全性。</p><p>setNX问题：</p><ol><li>早期版本<strong>没有超时参数</strong>，需要单独设置，存在死锁问题（key不会超时）</li><li>后期版本提供加锁和设置时间原子操作（set（NX，timeout）），但是存在任务超时，锁自动释放，导致<strong>并发问题</strong>，加锁和释放锁不是同一线程问题（假如T1获得锁要执行15s，锁失效时间为10s，在这5s内T2获得了锁，T1执行完了要把锁释放掉，结果把T2的锁释放了，解决方法可以在value中存上线程的唯一标识或者uuid，删除锁：<strong>判断线程唯一标识再删除</strong>）</li></ol><p>可重入性及<strong>锁续期</strong>没有实现，通过redisson解决（类似AQS实现（count计数），看门狗监听机制（设置一个监听器监听任务，任务没有执行完就延长过期时间））</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-9.jpg" alt></p><p><strong>redlock</strong>：以上的机制都只操作单节点，即使Redis通过Sentinel保证高可用，如果这个master节点由于某些发生了主从切换，那么就会出现锁丢失的情况（主从节点间是异步通信，Redis同步设置可能数据丢失）。redlock从多个节点申请锁，当一半以上节点获取成功才算成功，redisson有相应的实现</p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/redis-7.jpg" style="zoom:50%;"><p><strong>五、redis如何配置key的过期时间？实现原理</strong></p><p>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间的某个键的指针，value是该键的毫秒精度的unix时间戳表示的过期时间，键空间是指向该redis集群中保存的所有键。</p><p><strong>六、海量数据快速查询</strong></p><h2 id="微服务篇"><a href="#微服务篇" class="headerlink" title="微服务篇"></a>微服务篇</h2><p><strong>一、微服务的理解，优点</strong></p><p>去中心化，独立数据库</p><p>建module→改pom→写yml→主启动→业务类</p><p><strong>二、SpringCloud和SpringCloudAlibaba组件？都解决了什么问题</strong></p><p>gateway：统一服务对外入口，鉴权，过滤拦截（Gateway Handler Mapping→Gateway Web Handler， http请求断言，发送代理请求前后的Filter链），webflux→Reactor模式的netty</p><p>hystrix：熔断：防止异常扩散，降级：断路器打开，调用失败的补救，只是服务水平下降，监控</p><p>Ribbon：客户端负载均衡</p><p>Feign/OpenFeign：RESTful的http服务客户端，定义一个服务接口添加注解</p><p>sleuth-zipkin：每个请求都会形成一条复杂的分布式服务调用链路，链路中任何一环出现高延时或错误都会引起整个请求最后的失败</p><p>nacos：集成ribbon，项目初始化时先从配置中心拉取配置</p><p>sentinel：@SentinelResourse，熔断，降级（异常比例或异常数），限流（QPS，线程数快速失败，预热，排队等待）组件可以单独独立出来，界面化的细粒度统一配置，信号量隔离</p><p>seata：</p><ol><li>事务管理器TM（事务的发起方）向事务协调者TC申请开启事务，全局事务创建成功并生成一个全局唯一XID</li><li>XID在多个TM和RM中传播</li><li>RM向TC注册分支事务（<strong>branch_id</strong>），将其纳入XID管辖</li><li>TM向TC发起针对XID的全局提交或回滚</li><li>TC协调XID下全部事务分支完成提交或回滚</li></ol><p><strong>三、分布式事务如何处理？怎么保证事务一致性</strong></p><p>2PC：1、准备阶段，协调者向参与者发送pre，询问参与者是否能够提交事务；参与者收到pre后进行本地事务的预处理但不提交。2、提交阶段，如果协调者收到参与者失败就rollback，所有的参与者都返回ready就都发送commit回去。</p><p>2PC问题：单点故障，事务管理器一旦故障参与者就被阻塞。同步阻塞，数据不一致</p><p>3PC：把2PC的准备阶段再次拆分，引入参与者超时机制，解决了协调者故障后参与者阻塞问题。解决了单点故障问题。</p><ol><li>canCommit：协调者问参与者，是否具备执行事务的条件</li><li>preCommit：协调者通知参与者进行事务的预提交</li><li>doCommit：协调者根据preCommit参与者反馈结果通知参与者commit or rollback</li></ol><p>TCC（业务层次）：校验、资源锁定、补偿，对每个操作（Try）都提供确认（Confirm）和取消（cancel）的操作</p><p>TCC问题：<strong>业务服务需要提供try、confirm、cancel三种方法来支持</strong>，业务侵入性强。Confirm / Cancel要做幂等性设计</p><p>Sage：与TCC不同的是Saga不需要Try，而是直接进行confirm、cancel操作，适合长流程的业务。事件驱动模式，参与者可异步执行，高吞吐，成本低，但是无法保证隔离性</p><p>AT：无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本（sql都由框架托管统一执行，会存在脏写问题）</p><ol><li>保存before image→业务sql→保存after image→生成行锁，业务sql和undo log/redo log在同一个本地事务提交，释放本地锁和连接资源</li><li>提交异步，回滚通过一阶段的回滚日志反向补偿（<strong>校验脏写</strong>→还原数据），成功或回滚都要删除前后快照和行锁</li></ol><p><a href="https://arthurjq.com/2021/03/20/mq/">https://arthurjq.com/2021/03/20/mq/</a></p><p><strong>四、怎么拆分微服务？怎么设计出高内聚低耦合的微服务？DDD领域驱动设计？中台？中台和微服务的关系</strong></p><ol><li>基于<strong>工作流</strong>拆分服务：服务的拆分法则，基于工作流拆分服务，确保该工作流运行在一个实例中。</li><li>服务器即是服务池：所有物理机应该是一个服务池，根据我们的需求，可以将它部署成任何服务。</li></ol><p>比如：用户 —&gt; 商品中心（浏览）—&gt; 搜索中心（过滤）—&gt; 用户中心（添加购物车）—&gt; 物流中心 （物流方式） —&gt; 结算中心（支付结算/扣积分）—&gt; 商品中心（扣库存）—&gt; 用户中心 （完成）</p><p><strong>五、你的项目中是怎么保证微服务敏捷开发的？微服务链路追踪，持续集成，AB发布要怎么做？</strong></p><h2 id="Spring底层篇"><a href="#Spring底层篇" class="headerlink" title="Spring底层篇"></a>Spring底层篇</h2><p><strong>一、什么是Spring，IOC和AOP</strong></p><p>装java bean的容器框架</p><p>IOC：</p><ol><li>容器：实际上就是个map存各种对象，在代码需要用到里面对象时，再通过DI注入</li><li>控制反转：解耦，获得依赖对象的过程由主动变为被动</li><li>依赖注入：实现IOC的方法，动态地注入依赖关系</li></ol><p>AOP：</p><p>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前或之后额外做一些事情。</p><p><strong>二、Spring容器启动流程</strong></p><ol><li>初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中</li><li>将用户配置类的BeanDefinition注册到容器中</li><li>调用refresh方法刷新容器</li></ol><p><strong>三、Bean的创建流程</strong></p><p>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</p><p>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</p><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-7.jpg" alt></p><p><strong>四、Spring中Bean是线程安全的么？如何处理</strong></p><p>单例无状态Bean是线程安全的，有状态的Bean通过<strong>ThreadLocal</strong>解决，因为ThreadLocal每个线程私有</p><p><strong>五、Spring如何处理循环依赖</strong></p><p>三级缓存（解决循环依赖）：</p><p>一级：singletonObjects map&lt;beanName，Object&gt; （单例池）</p><p>二级：earlySingletonObjects map&lt;beanName，Object&gt; （提前AOP）</p><p>三级：singletonFactories （放了个lambda）</p><p>earlyProxyReferences ConcurrentHashMap&lt;beanName，bean的原始对象&gt;（循环引用时记录是否提前生成了代理对象）</p><p>creatingSet （）</p><p><strong>流程</strong>：假设Aservice和Bservice互相依赖，当Aservice出现循环依赖的话会提前AOP</p><ol><li>creatingSet.add（Aservice）</li><li>class→实例化得到Aservice原始对象→singletonFactories map&lt;beanName，lambda（beanName，BeanDefinition，Aservice原始对象）&gt;</li><li>给Bservice属性赋值→从单例池找Bservice→找不到→创建Bservice的bean<ol><li>class→实例化得到Bservice原始对象</li><li>给Aservice属性赋值→从单例池找Aservice→找不到→creatingSet→Aservice出现循环→earlySingletonObjects→singletonFactories→lambda→AOP→Aservice代理对象→放入二级缓存（调用getEarlyBeanReference（）提前生成代理对象）</li><li>给其他属性赋值</li><li>其余AOP</li><li>将对象放入单例池</li></ol></li><li>给其他属性赋值</li><li>其余事情AOP→Aservice代理对象→postProcessAfterInitialization（）（看earlyProxyReferences有没有提前生成代理对象）</li><li>earlySingletonObjects.get（Aservice）</li><li>creatingSet.remove（Aservice）</li><li>将对象放入单例池</li></ol><p><strong>六、Spring如何处理事务</strong></p><p>编程式事务：通过编码方式实现事务，使用TransactionTemplate或PlatformTrasactionManager</p><p>声明式事务：注解，AOP，本质就是在目标方法执行前后进行拦截</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/spring%20transaction-9.png" alt></p><p><strong>七、SpringMVC中控制器如何保证线程安全</strong></p><p>默认单例，在Controller中使用ThreadLocal变量或scope=”prototype”</p><h2 id="Mysql篇"><a href="#Mysql篇" class="headerlink" title="Mysql篇"></a>Mysql篇</h2><p><strong>一、数据存储引擎，区别</strong></p><p>MyISAM：</p><ol><li>不支持事务，但是每次查询都是<strong>原子</strong>的</li><li>支持表级锁</li><li><strong>存储表的总行数</strong></li><li>一个MyISAM表有三个文件：表结构文件，索引文件，数据文件</li><li>采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不保证唯一性</li></ol><p>InnoDB</p><ol><li>支持ACID事务，支持四种隔离级别</li><li>支持行级锁及外键约束，因此可以<strong>支持写并发</strong></li><li>不存储总行数，算行数要全表扫描</li><li>一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也可能多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G）</li><li>主键索引采用聚簇索引，辅索引的数据域存储主键的值；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li></ol><p><strong>二、脏读，不可重复读，幻读，如何处理</strong></p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/spring%20transaction-7.png" alt></p><p>为了防止脏读，每次写入前，数据库都会记住旧值，当前事务尚未提交时，其他事务的读取都会拿到旧值。当前事务提交后，其他事务才能读取到新值。</p><p>原子写，for update锁行，CAS</p><p><strong>三、事务的基本特性和隔离级别</strong></p><p><a href="https://arthurjq.com/2020/12/25/database/isolation/">https://arthurjq.com/2020/12/25/database/isolation/</a></p><p><strong>四、Mysql的锁有哪些，间隙锁</strong></p><p>操作类型：共享锁，互斥锁</p><p>操作范围：表锁，行锁（记录锁+间隙锁=临建锁），页锁</p><p>间隙锁（Gap Lock）：属于行锁的一种，是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现间隙则会形成一个区间，遵循左开右闭原则。只会出现在重复读的事务级别中。</p><p><strong>五、Mysql的索引结构是什么？</strong></p><p>B+ Tree</p><p><strong>六、Mysql的集群如何搭建，读写分离怎么做</strong></p><p>让master来响应事务性操作，让slave来响应select非事务性操作，然后再采用主从复制来把master上的事务性操作同步到slave数据库中。实现简单的负载均衡。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-2.png" alt="mysql主从复制"></p><p>主要由三个线程：master（binlog dump thread）、slave（I / O thread、SQL thread）</p><ol><li>主节点binlog，主从复制的基础是<strong>主库记录数据库的所有变更记录到binlog</strong>。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li><li>主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。</li><li>从节点I /O 线程接受binlog 内容，并将其写入到relay log 文件中。（relay log在从节点）</li><li>从节点的SQL线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库一致性。</li></ol><p><strong>七、分库分表，多大数据量需要分库分表，分库分表方式和分片策略，分库分表后sql的执行流程？</strong></p><p>1，2000w</p><p>垂直分库：指按照业务将表进行分类，分布到不同的数据库上面，专库专用</p><p>水平分库：把同一个表的数据按一定规则拆到不同的数据库中，如id%2</p><p>垂直分表：将一个表按照字段分成多表，每个表存储其中一部分字段</p><p>水平分表：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中，跟水平分库类似</p><p>分片策略：地理，id，用户，时间，取决于你的应用</p><p> 经过Sharding-JDBC，源码没看</p><h2 id="搜索引擎篇"><a href="#搜索引擎篇" class="headerlink" title="搜索引擎篇"></a>搜索引擎篇</h2><p><strong>一、倒排索引？有什么好处</strong></p><p>记录每个词条出现在那些文档，及文档中的位置，快速定位到包含这个词条的文档和出现的位置</p><p>倒排本质上就是基于term的反向列表，基于FST形成一个有向无环图，FST定位到倒排链后，然后倒排链的合并</p><p>为了能够快速查找docid，SkipList本质上是在有序的链表上实现实现二分查找，空间换时间</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-7.jpg" alt></p><p><strong>二、ES？说说你们公司的es集群架构</strong></p><p>动态映射，不需要定义Mapping映射</p><p>ES 集群架构 3 个节点，索引根据通道不同共 10+索引，根据日期，每日递增 10+，索引：默认5 分片，replica默认1对1，每日递增3GB数据</p><p>默认混合部署，Data Node 和 Transport Node，Node中会持有一个全局的路由表，缺点就是多种类型的请求会相互影响，不能支持集群的热更新</p><p><strong>三、如何进行中文分词？用过哪些分词器</strong></p><p>ik_smart、ik_max_word</p><p><strong>四、es写入数据的工作原理？</strong></p><ol><li>客户端通过hash选择一个node发送请求，这个node被称做coordinating node（协调节点）</li><li>协调节点对document进行路由，将请求转发给到对应的primary shard</li><li>primary shard 处理请求，将数据同步到所有的replica shard</li><li>此时协调节点，发现primary shard 和所有的replica shard都处理完之后，就反馈给客户端。</li></ol><p><strong>五、es查询数据的工作原理</strong></p><ol><li>客户端发送get请求到任意一个node节点，然后这个节点就称为协调节点，</li><li>协调节点对document进行路由，将请求转发到对应的node，此时会使用随机轮询算法，在primary shard 和replica shard中随机选择一个，让读取请求负载均衡，</li><li>接收请求的node返回document给协调节点</li><li>协调节点，返回document给到客户端</li></ol><p><strong>六、es部署时如何优化</strong></p><p>1、根据业务增量需求，采取<strong>基于日期</strong>模板<strong>创建索引</strong>，通过 roll over API 滚动索引；</p><p>2、使用别名进行索引管理；</p><p>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；</p><p>4、采取<strong>冷热分离</strong>机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink</p><p>5、采取 curator 进行索引的生命周期管理；</p><p>6、仅针对需要分词的字段，<strong>合理的设置分词器</strong>；</p><p>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p><h2 id="安全验证篇"><a href="#安全验证篇" class="headerlink" title="安全验证篇"></a>安全验证篇</h2><p><strong>一、什么是认证和授权？如何设计一个权限认证框架？</strong></p><p>认证：验证您的身份。授权发生在系统成功验证您的身份后，最终会授予您访问资源的完全权限。</p><p>用户←多对多→角色←多对多→权限</p><p><strong>二、Cookie和Session区别</strong></p><p>Session在服务端保存，用来跟踪用户的状态</p><p>Cookie客户端保存，用来记录用户的一些信息</p><p><strong>三、如果没有Cookie，Session还能进行身份验证么</strong></p><p>Cookie中存有SessionID</p><p><strong>四、CSRF攻击，如何防止</strong></p><p>Cross-site request forgery, 跨站请求伪造</p><ul><li>添加并验证 token</li><li>添加自定义 http 请求头</li><li>敏感操作<strong>添加验证码</strong></li></ul><p><strong>五、OAuth2.0协议？有几种认证方式？JWT令牌？和普通令牌的区别</strong></p><p>向第三方应用颁发令牌</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p>session随着认证用户的增多，服务端的开销会明显增大</p><p>JWT：header.payload.signature</p><p>头部声明类型，加密算法</p><p>载荷就是存放有效信息的地方</p><p>签证由HMACSHA256（base64UrlEncode（header） + ‘.’ + base64UrlEncode（payload）, ‘secret’）</p><p>secret是保存在服务器端的私钥，JWT可以跨语言支持</p><p>token需要查库验证token 是否有效，而JWT<strong>不用查库</strong>或者少查库，直接在服务端进行校验，并且不用查库</p><h2 id="self-introduction"><a href="#self-introduction" class="headerlink" title="self-introduction"></a>self-introduction</h2><p>面试官角度：最希望知道的是你能否胜任你面试的岗位工作；</p><p>所有你可以在介绍的时候，最好是加入你最擅长的专业技能、对哪块知识比较深的理解、你项目中曾经完成了哪个模块功能、项目中让你感觉最有收获的事。</p><p>STAR：Situation什么情况下，Task你要干什么，Action你采用了什么样的行动和努力，Result得到什么样的结果</p><p>要有细节，要有感情，要有思考，总结得失</p><p>项目贡献了多少代码，解决了多少问题，修复了多少bug</p><h3 id="范文"><a href="#范文" class="headerlink" title="范文"></a>范文</h3><p>您好，我叫吴锦泉，就读于华南理工大学，软件工程专业，曾经在广州慧扬健康参与过两个项目，分别是吴川市人民医院的互联网医院和茂名市妇幼保健院、吴川市人民医院的消毒供应室系统。使用的技术大多是SpringBoot、SpringCloud、 Netty、elasticsearch、Mysql和Redis等。</p><p>在互联网医院项目中用了SpringBoot，nacos服务发现治理配置中心，gateway网关服务负载均衡和服务路由，Netty，kafka，elasticsearch，redis，mysql。移动端线上问诊开药平台，类似于好大夫，核心功能是基于nettyws的im即时通讯服务的在线问诊，此外还有预约挂号，智能导诊和复诊开药功能。</p><p>通信流程大概是这样的：上边是客户端，下边为多个WS服务器，服务器要往nacos里边注册。</p><ol><li>客户端携带授权token（jwt请求头加token）向服务集群发起connect请求，请求会被网关转发都具体的某一个ws节点</li><li>ws服务针对connect进行鉴权，并且将该连接会话缓存在服务内，返回连接成功</li><li>客户端定时向服务端发送ws心跳，服务端返回ping报文</li><li>客户端需要发送消息时，通过ws发送报文。对应的ws节点收到报文信息后，直接发布到kafka的topic中</li><li>所有ws服务器监听消息队列topic，收到topic信息后根据busiCode类型，toUserId，groupId等寻找对应的用户id。再通过用户id获取到session，通过session进行消息推送</li><li>redis负责缓存用户信息和实现分布式锁，作为服务端和mysql数据库的中间件</li><li>elk负责持久化kafka信息，提供http get接口进行历史信息模糊查询</li></ol><p>我在项目中负责在线问诊和复诊开药流程的开发，elk的搭建和相关需求开发。</p><p>nacos：集成ribbon，项目初始化时先从配置中心拉取配置。</p><p>gateway：统一服务对外入口，鉴权，过滤拦截（Gateway Handler Mapping→Gateway Web Handler， http请求断言，发送代理请求前后的Filter链），webflux→Reactor模式的netty</p><h2 id="Zookeeper（CP）"><a href="#Zookeeper（CP）" class="headerlink" title="Zookeeper（CP）"></a>Zookeeper（CP）</h2><p>Znode兼具<strong>文件和目录</strong>两种特点，具有原子性操作</p><p>watch机制实现实时监听znode，不告知事件内容</p><p>ZAB：1、消息广播：第一步是广播事务操作，第二步时广播提交操作，其中过半数指的是<strong>反馈节点数 &gt;= N/2 + 1</strong>。</p><p>2、崩溃恢复：开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，<strong>强一致性</strong></p><p>Zxid，事务编号，高32位代表每代Leader的唯一性，低32位代表了每代Leader中事务的唯一性</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>三主三从，随机需要遍历所有redis服务器，hash取模的话如果服务器变动所有缓存都改变，不易拓展</p><p>使用饿汉模式进行管理。只有在读时才缓存加载，其他操作删除相关缓存。<br>缓存时间设置不宜过长，5分钟内为宜（因为现在业务没什么对数据库压力特别大）<br>不同Key的缓存失效时间尽量随机<br>考虑缓存穿透问题<br>不要使用redis事务<br>先进行数据库操作，再操作缓存<br>数据粒度要很大时，借助定时任务定期刷新内存<br>缓存中找不到时，应该去查找数据库中是否存在，记得用一定策略保证击穿问题得到解决<br>用service屏蔽缓存的直接操作，避免造成缓存管理困难（因为service的操作一定可以反映到数据库上，直接操作缓存不一定能落到数据库）</p><p><strong>key定义的规范</strong>，这个是用的时候比较容易出错的，重名，和系统关键字冲突，长度等，都需要给出规范来</p><p>value上，应该<strong>控制数据的长度</strong>，比如防止一些大数据类型，redis本来是提速的，不要因为数据长度影响了自身性能，另外就是合理的使用数据类型，节省存储提升性能，比如能整型的就不要字符串型</p><p>一致性hash，对2的32方取模，服务器iphash，keyHash后沿环顺时针查找直到遇到服务器，容错性和可拓展性高（只需重定位环空间中的一小部分数据），数据倾斜问题用虚拟节点解决。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li>从节点执行slaveof masterIp port保存主节点信息</li><li>从节点中的定时任务发现主节点信息，建立和主节点socket连接</li><li>建立连接后，主节点将所有数据发送给从节点</li><li>完成数据同步后，主节点就会持续的把写命令发送给从节点，保证主从数据一致</li></ol><p>runId：每个redis节点启动都会生成唯一的uuid</p><p>offset：主从节点各自维护自己的偏移量</p><p>repl_backlog_size：保存在主节点的一个固定长度的FIFO队列，默认1MB</p><p><strong>全量复制</strong></p><ol><li>从节点发送psync命令，psync runid offset（第一次runid为？，offset为-1）</li><li>主节点返回 FULLRESYNC runid offset</li><li>主节点启动bgsave命令fork子进程进行RDB持久化</li><li>主节点将RDB文件发送给从节点，到从节点加载数据完成之前，写命令写入缓存区</li><li>从节点清理本地数据并加载RDB，如果开启AOF会重新AOF</li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/redis-2.jpg" alt></p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-3.jpg" alt></p><ol><li>Netty抽象出两组线程池BossGroup专门负责接收客户端连接，WorkerGroup专门负责网络的读写</li><li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li><li>NidEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是NioEventLoop</li><li>NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector用于监听绑定在其上的socket的网络通讯</li><li>每个BossEventLoopGroup的NioEventLoop循环执行：<ol><li>轮询accept事件</li><li>处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker的NioEventLoop上的selector</li><li>处理taskQueue的任务，即 runAllTasks</li></ol></li><li>每个Worker-NioEventLoop 循环执行：<ol><li>轮询 read、write 事件</li><li>处理异步 i / o事件（ChannelFuture接口实现异步），即read，write 事件，在对应的NioSocketChannel处理（每个NioSocketChannel都绑定一个自己的全新的ChannelPipeline）</li><li>处理任务队列的任务，即 runAllTasks</li></ol></li><li>每个Worker的NioEventLoop 处理业务时，会使用pipeline，pipeline中包含了 channel，即通过pipeline可以获得对应通道，管道中维护了很多 handler。</li></ol><p>NioEventLoop内部串行化，消息在多个handler中读取→解码→处理→编码→发送</p><p>ChannelInboundHandler / ChannelOutboundHandler 入站（server→client） / 出站io</p><p>ChannelPipeline是一个ChannelHandler集合链，负责处理和拦截inbound或者outbound事件和操作</p><p>ChannelHandlerContext：上下文对象，含具体的事件管理器ChannelHandler，含pipeline，channel，地址</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-4.jpg" alt></p><p>每添加一个handler都会创建一个关联的Context，调用addLast方法将Context追加到链表</p><p>tail是inbound类型的handler，head既是inbound又是outbound类型的handler。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-5.jpg" alt></p><ol><li>pipeline首先调用ctx的pipeline的静态方法fireXXX（如fireChannelRead），并传入head</li><li>静态方法调用ctx的invoke方法，invoke方法内部调用该ctx所包含的Handler的真正方法，调用结束传递给下一个ctx</li></ol><p><a href="https://arthurjq.com/2021/01/21/project/netty-pipeline/">https://arthurjq.com/2021/01/21/project/netty-pipeline/</a></p><blockquote><p>http+json      tcp+protobuf</p><p>TCP粘包拆包解决：要求客户端发送5个message，每次发送一个，服务端每收到一个回复一个message对象</p></blockquote><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p>调整堆内存最少2g -Xms2g -Xmx2g</p><p>通过ElasticsearchRepository接口自定义基本查询</p><p>模糊查询：restHighLevelClient→boolQueryBuilder.filter（queryBuilder.multiMatchQuery（id，fromUserId，toUserId））→boolQueryBuilder.must（queryBuilder.matchQuery（key，content））</p><h3 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h3><ol><li>禁用 wildcard</li><li>禁用批量 terms</li><li>充分利用倒排索引机制，能 keyword 类型尽量 keyword</li><li>数据量大时候，可以先基于时间敲定索引再检索</li><li>设置合理的路由机制</li></ol><h2 id="ssd定时任务"><a href="#ssd定时任务" class="headerlink" title="ssd定时任务"></a>ssd定时任务</h2><p>@Scheduled（cron = “0 0 0 <em> </em> ?”）</p><p>没有开关，项目启动总会启动一个线程</p><p>使用Java的timer，这个设置开关即可自由的控制，关闭的时候，不会启动线程；</p><p>Java的timer也需要找到一个启动类，可以放到main函数里面启动，这样的话，代码的耦合性太高了，而使用PostConstruct是很干净的。</p><p><a href="https://arthurjq.com/2020/12/28/web/servlet/">https://arthurjq.com/2020/12/28/web/servlet/</a></p><h2 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h2><pre class="line-numbers language-shell"><code class="language-shell">docker builddocker push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编写deployment.yaml部署文件（容器名，端口号）</p><p>发布部署<code>kubectl apply -f helloworld-deployment.yaml</code></p><p>查看是否部署成功</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写service.yaml部署文件</p><p>查看服务端口绑定到物理节点的端口<code>kubectl get svc</code></p><h2 id="尖锐的问题"><a href="#尖锐的问题" class="headerlink" title="尖锐的问题"></a>尖锐的问题</h2><h3 id="答不出来的问题"><a href="#答不出来的问题" class="headerlink" title="答不出来的问题"></a>答不出来的问题</h3><p>不要放弃，让面试官看到你的思考，如果不懂可以追问，但回去要努力补课</p><h3 id="你有什么缺点"><a href="#你有什么缺点" class="headerlink" title="你有什么缺点"></a>你有什么缺点</h3><p>表达能力需提高，直，学技术喜欢深挖，可能会对别人不好</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>我想解决问题，想成为技术专家，成为团队里的核心，学习基础知识，做项目，向大佬学习，跟leader学习，让他帮助我成长</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是高效的面试&quot;&gt;&lt;a href=&quot;#什么是高效的面试&quot; class=&quot;headerlink&quot; title=&quot;什么是高效的面试&quot;&gt;&lt;/a&gt;什么是高效的面试&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;自信&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;要怎么准备&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://arthurjq.com/2021/03/08/java-basis/"/>
    <id>https://arthurjq.com/2021/03/08/java-basis/</id>
    <published>2021-03-08T02:23:24.000Z</published>
    <updated>2021-03-24T12:40:43.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点： 性能比面向过程低</p><h2 id="Java和C"><a href="#Java和C" class="headerlink" title="Java和C++"></a>Java和C++</h2><ol><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ol><h2 id="构造器-Constructor-是否可被-override？"><a href="#构造器-Constructor-是否可被-override？" class="headerlink" title="构造器 Constructor 是否可被 override？"></a>构造器 Constructor 是否可被 override？</h2><p>父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="overload和override"><a href="#overload和override" class="headerlink" title="overload和override"></a>overload和override</h2><p>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><p>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法</p><blockquote><p>方法重载跟返回值类型和修饰符无关</p></blockquote><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在<strong>程序运行期间</strong>才确定。</p><p>两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同一方法）</p><p>条件：1.继承 2.方法的override 3.父类引用指向子类对象</p><h2 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h2><ol><li>操作少量的数据 →String</li><li>单线程操作字符串缓冲区下操作大量数据 →StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据 →StringBuffer</li></ol><h2 id="静态方法内调用一个非静态成员"><a href="#静态方法内调用一个非静态成员" class="headerlink" title="静态方法内调用一个非静态成员"></a>静态方法内调用一个非静态成员</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>一、静态方法只能访问静态方法和静态成员。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//加入static关键字，变成静态方法</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> result<span class="token operator">=</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//静态方法调用静态方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result="</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、非静态方法要被实例化才能被静态方法调用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Test test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化类</span>        <span class="token keyword">int</span> result<span class="token operator">=</span>test<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用非静态方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result="</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无参构造的作用"><a href="#无参构造的作用" class="headerlink" title="无参构造的作用"></a>无参构造的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 super（）来调用父类特定的构造方法，则会调用父类中的无参构造。</p><p>在调用子类构造方法之前会先调用父类无参构造方法，是为了帮助子类做<strong>初始化工作</strong>。</p><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种<strong>行为的规范</strong></li></ol><h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><ol><li>从语法形式上，成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而<strong>局部变量则不会自动赋值</strong></li></ol><h2 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h2><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li><li>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ol><h2 id="equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h2><p>因为两个对象有相同的 hashcode 值，它们也不一定是相等的</p><blockquote><p>hashCode 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h2 id="类中所有的-private-方法都隐式地指定为-final"><a href="#类中所有的-private-方法都隐式地指定为-final" class="headerlink" title="类中所有的 private 方法都隐式地指定为 final"></a>类中所有的 private 方法都隐式地指定为 final</h2><h2 id="not-in和not-exists"><a href="#not-in和not-exists" class="headerlink" title="not in和not exists"></a>not in和not exists</h2><p>查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引，而not extsts 的子查询依然能用到表上的索引。所以无论哪个表大，<strong>用not exists都比not in要快</strong>。</p><h2 id="sleep，wait，join，yield"><a href="#sleep，wait，join，yield" class="headerlink" title="sleep，wait，join，yield"></a>sleep，wait，join，yield</h2><p>锁池：所有需要竞争同步锁的线程都会放到锁池中。</p><p>等待池：当调用wait方法后线程会放到等待池中，等待池不会竞争同步锁。只有调用了notify或notifyAll方法后才开始竞争。</p><ol><li>sleep是<strong>Thread类</strong>的静态本地方法，wait是<strong>Object类</strong>的本地方法。</li><li>sleep方法不会释放lock，而wait会释放后加入等待队列。</li><li>sleep不依赖synchronized，而wait需要synchronized</li><li>sleep不需要被唤醒，wait需要</li><li>sleep一般为当前线程休眠，wait则多用于多线程之间的通信</li><li>sleep会让出cpu执行事件强制上下文切换，wait不一定</li></ol><p>yield执行后线程直接进入就绪状态，马上释放cpu的执行权</p><p>join执行后线程进入阻塞状态，例如线程B中调用了线程A的join方法，那线程B会进入阻塞队列，直到线程A结束或中断线程</p><blockquote><p>线程的五种状态：创建，就绪，运行，阻塞，死亡</p></blockquote><h2 id="处理不想序列化的字段"><a href="#处理不想序列化的字段" class="headerlink" title="处理不想序列化的字段"></a>处理不想序列化的字段</h2><p>使用 transient 关键字修饰。</p><p>作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><p>transient 只能修饰变量，不能修饰类和方法。</p><h2 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h2><p>方法 1：通过 Scanner</p><pre class="line-numbers language-java"><code class="language-java">Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>String s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方法 2：通过 BufferedReader</p><pre class="line-numbers language-java"><code class="language-java">BufferedReader input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h2><p>Native Method就是一个java调用非java代码的接口。</p><p>被native关键字修饰的方法叫做本地方法，本地方法和其它方法不一样，本地方法意味着和平台有关，因此使用了native的程序可移植性都不太高。另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的<strong>本地方法栈</strong>。native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。被native修饰的方法可以被C语言重写。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p><strong>堆</strong>是进程和线程共有的空间，唯一目的是<strong>存放对象实例</strong>，创建的对象和数组都保存在堆中。</p><p><strong>栈</strong>是每个线程独有的，每个线程的栈相互独立。每个方法在执行的同时都会创建一个栈帧用来存储<strong>局部变量表、操作数栈、动态链接（代码中的符号引用（#10）=&gt;方法区中的直接引用）、方法出口</strong>等信息。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-4.jpg" alt></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>每条线程都还有<strong>私有的</strong>ThreadLocalMap容器，无需使用同步机制<strong>保证多线程访问容器的互斥性</strong>。（使用static，又不想考虑线程安全的时候用）</p><p>使用场景：</p><ol><li>在进行<strong>对象跨层传递</strong>的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束</li><li>线程间数据隔离</li><li>进行事务操作，用于<strong>存储线程事务信息</strong>（Spring框架在事务开始时会给当前线程绑定一个<strong>Jdbc Connection</strong>）</li><li>数据库连接，<strong>Session会话管理</strong></li></ol><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-1.png" alt></p><p>ThreadLocal内存泄漏的根源：<strong>由于ThreadLocalMap的生命周期跟Thread一样长</strong>，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p>正确用法：</p><ol><li>每次使用完ThreadLocal都<strong>调用它的remove（）方法</strong>清除数据</li><li>将ThreadLocal变量定义成<strong>private static</strong>，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="对象锁（monitor）"><a href="#对象锁（monitor）" class="headerlink" title="对象锁（monitor）"></a>对象锁（monitor）</h3><p>synchronized的具体底层实现，demo:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中有一个同步代码块，<strong>锁住的是类对象</strong>，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到SynchronizedDemo.class的同级目录之后，然后用<code>javap -v SynchronizedDemo.class</code>查看字节码文件：</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-2.png" alt></p><p>使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是<strong>互斥</strong>的，即同一时刻只有一个线程能够获取到monitor。</p><p>从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是<strong>锁的重入性</strong>，<strong>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</strong>。</p><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-3.png" alt></p><p>看图，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在J.U.C包中利用CAS实现类，在Lock实现中会有CAS改变state变量，在atomic包也是</p><h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的。</p><h4 id="自旋时间过长"><a href="#自旋时间过长" class="headerlink" title="自旋时间过长"></a>自旋时间过长</h4><p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时CAS能保证其原子性，<strong>如果对多个共享变量进行操作，CAS就不能保证其原子性</strong>。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><h4 id="总线lock"><a href="#总线lock" class="headerlink" title="总线lock"></a>总线lock</h4><p>在CPU1要操作共享变量的时候，其在总线上发出一个 LOCK# 信号，其他处理器就不能操作缓存了该共享变量内存地址的缓存。</p><h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h4><p>当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在它们内部的缓存，或者从主内存中重新读取</p><p>MESI协议：在<strong>每个缓存行</strong>上维护两个状态位</p><ol><li>​    M：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且<strong>没有更新到内存</strong>中。</li><li>​    E：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其<strong>数据没有修改</strong>，即与内存中一致。</li><li>​    S：共享的。处于这一状态的数据在多个CPU中都有缓存，且<strong>与内存一致</strong>。</li><li>​    I：无效的。本CPU中的这份缓存已经无效。</li></ol><p>M状态必须时刻<strong>监听所有试图读取该缓存行</strong>对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</p><p>E状态必须时刻<strong>监听其他试图读取该缓存行</strong>对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</p><p>S状态必须时刻<strong>监听使该缓存行无效或者独享该缓存行的请求</strong>，如果监听到，则必须把其缓存行状态设置为I。</p><blockquote><p>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</p><p>当CPU需要写数据时，只有在其缓存行是<strong>M或者E</strong>的时候才能执行，否则需要发出特殊的RFO指令（Read Or Ownership，这是一种总线事务），通知其他CPU置缓存无效（I），这种情况下性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger.incrementAndGet（用了CAS）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>quartz实现高级定制化定时任务中用AtomicInteger标识程序执行过程中是否发生了异常</p></blockquote><p>把普通变量升级为原子变量：主要是<code>AtomicIntegerFieldUpdater&lt;T&gt;</code>类</p><p>在高并发情况下，LongAdder（累加器）比AtomicLong原子操作效率更高，LongAdder累加器是java8新加入的</p><p>在高度并发竞争情形下，AtomicLong每次进行add都需要flush和refresh（这一块涉及到java内存模型中的工作内存和主内存的，所有变量操作只能在工作内存中进行，然后写回主内存，其它线程再次读取新值），每次add都需要同步，在高并发时会有比较多冲突，比较耗时导致效率低；而LongAdder中每个线程会维护自己的一个计数器，在最后执行<code>LongAdder.sum()</code>方法时候才需要同步，把所有计数器全部加起来，不需要flush和refresh操作。</p><p>转载：<a href="https://blog.csdn.net/fanrenxiang/article/details/80623884" target="_blank" rel="noopener">https://blog.csdn.net/fanrenxiang/article/details/80623884</a></p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>final</strong>也保证可见性</p><p><strong>synchronized</strong>（阻塞同步）</p><ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol><p><strong>volatile</strong>（非阻塞同步）：在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令</strong>（缓存一致性）</p><ol><li><strong>它先对总线和缓存加锁</strong>，再执行后面的指令，期间<strong>其他CPU的读写请求都会被阻塞</strong>（其他线程可以看见）</li><li>最后释放锁后会把高速缓存中的脏数据全部刷新回主内存，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效（M操作）。</li></ol><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>synchronized</strong>：排他的、可重入的锁。通过排他锁保证了是<strong>单线程</strong>执行的。满足了as-if-serial语义（单线程），单线程的有序性就天然存在了（<strong>不能禁止重排序</strong>）</p><blockquote><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器和处理器不会对存在<strong>数据依赖关系</strong>的操作做重排序，因为这种重排序会改变执行结果。</p></blockquote><p><strong>volatile</strong>：禁止重排序，使用内存屏障，统一由jvm来生成内存屏障的指令，Lock是软件指令。</p><p><strong>内存屏障</strong>的作用：</p><ol><li>屏障下面的代码不能跟屏障上面的代码交换执行顺序</li><li>线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本失效（使用MESI协议）</li></ol><p><strong>内存屏障</strong>是CPU指令。volatile<strong>读前插</strong>读屏障，<strong>写后加</strong>写屏障：</p><ol><li>Load Barrier，<strong>读前插</strong>读屏障，可以<strong>让高速缓存中的数据失效，强制重新从主内存加载新数据</strong></li><li>Store Barrier，<strong>写后加</strong>写屏障，能<strong>让写入缓存中的最新数据更新写入主内存，让其他线程可见</strong></li></ol><p><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p><blockquote><p>如果指令甲happens-before指令乙，那么指令甲必须排序在指令乙之前，并且指令甲的执行结果对指令乙可见。</p></blockquote><h2 id="ThreadPool-中-submit-和-execute"><a href="#ThreadPool-中-submit-和-execute" class="headerlink" title="ThreadPool 中 submit 和 execute"></a>ThreadPool 中 submit 和 execute</h2><p>都是用来执行线程池的，只不过使用 execute 执行线程池<strong>不能有返回方法</strong>，而使用 submit 可以使用 <strong>Future 接收线程池执行的返回值</strong>。</p><h2 id="ThreadPoolExecutor-都需要哪些参数"><a href="#ThreadPoolExecutor-都需要哪些参数" class="headerlink" title="ThreadPoolExecutor 都需要哪些参数"></a>ThreadPoolExecutor 都需要哪些参数</h2><ol><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中最大线程数</li><li>keepAliveTime：闲置超时时间</li><li>unit：keepAliveTime 超时时间的<strong>单位</strong>（时/分/秒等）</li><li>workQueue：线程池中的<strong>任务队列</strong></li><li>threadFactory：为线程池提供创建新线程的<strong>线程工厂</strong></li><li>rejectedExecutionHandler：线程池任务队列超过最大值之后的<strong>拒绝策略</strong></li></ol><h2 id="线程池的队列类型"><a href="#线程池的队列类型" class="headerlink" title="线程池的队列类型"></a>线程池的队列类型</h2><p>1、ArrayBlockingQueue<br>是一个基于数组结构的<strong>有界阻塞队列</strong>，此队列按 FIFO（先进先出）原则对元素进行排序。<br>2、LinkedBlockingQueue<br>一个基于链表结构的<strong>阻塞队列</strong>，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool（）使用了这个队列<br>3、SynchronousQueue<br>一个不存储元素的<strong>阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool（5）使用了这个队列。<br>4、PriorityBlockingQueue<br>一个具有优先级的<strong>无限阻塞队列</strong>。</p><h2 id="线程池中为什么先入队列而不是先创建最大线程"><a href="#线程池中为什么先入队列而不是先创建最大线程" class="headerlink" title="线程池中为什么先入队列而不是先创建最大线程"></a>线程池中为什么先入队列而不是先创建最大线程</h2><p>在创建新线程时，<strong>要获取全局锁</strong>，这时其他都得阻塞，影响效率。</p><h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><p>线程池将线程和任务进行解耦，摆脱了之前通过Thread创建线程时一个线程必须对应一个任务的限制。</p><p>同一个线程可以从阻塞队列中不对获取新任务来执行，其核心原理在于线程池对Thread封装，并<strong>不是每次执行任务都调用Thread.start（）来创建新线程</strong>，而是让每个线程执行一个“循环任务”，不断检查是否有任务需要被执行，有就<strong>调用任务中的run方法</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;p&gt;优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
      
    
    </summary>
    
      <category term="Java" scheme="https://arthurjq.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://arthurjq.com/tags/java/"/>
    
  </entry>
  
</feed>
