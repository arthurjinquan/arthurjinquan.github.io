<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="面试, SCUT JAVA mybatis SpringBoot SpringCloud 锦泉 arthurjinquan jinquan">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="什么是高效的面试自信
要怎么准备拉伸知识的广度：了解互联网的主要技术栈，形成知识网络
提升知识的深度：由浅入深，由点到面，对每个技术栈形成梯度，整理梳理。每个梯度都要准备1到2个由代表性的高频面试题。（种子）
并发篇一、Java如何开启线程">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>面试 | 锦泉^-^</title>
    <link rel="icon" type="image/png" href="https://gitee.com/arthurjq/blogimage/raw/master/img/logo.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://gitee.com/arthurjq/blogimage/raw/master/img/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">锦泉^-^</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://gitee.com/arthurjq/blogimage/raw/master/img/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">锦泉^-^</div>
        <div class="logo-desc">
            
            华南理工大学 | 软件工程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://gitee.com/arthurjq/blogimage/raw/master/img/feature/94.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        面试
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/java/" target="_blank">
                            <span class="chip bg-color">java</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/Java/" class="post-category" target="_blank">
                            Java
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-09
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    锦泉
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    41 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="什么是高效的面试"><a href="#什么是高效的面试" class="headerlink" title="什么是高效的面试"></a>什么是高效的面试</h2><p><strong>自信</strong></p>
<h2 id="要怎么准备"><a href="#要怎么准备" class="headerlink" title="要怎么准备"></a>要怎么准备</h2><p><strong>拉伸知识的广度</strong>：了解互联网的主要技术栈，形成知识网络</p>
<p><strong>提升知识的深度</strong>：由浅入深，由点到面，对每个技术栈形成梯度，整理梳理。每个梯度都要准备1到2个由代表性的高频面试题。（种子）</p>
<h2 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h2><p><strong>一、Java如何开启线程？怎么保证线程安全？</strong></p>
<p>线程和进程的区别：进程是操作系统进行<strong>资源分配</strong>的最小单元。线程是操作系统进行<strong>任务分配</strong>的最小单元，线程隶属于进程。</p>
<p>如何开启线程？1、继承Thread类，重写run方法。2、实现Runnable接口，实现run方法。3、实现Callable接口，实现call方法。通过FutureTask创建一个线程，获取到线程执行的返回值。4、通过线程池开启线程。</p>
<p>JVM的Synchronized和JDK提供的Lock</p>
<p><strong>二、volatile和Synchronized？volatile能不能保证线程安全？DCL（Double Check Lock）单例模式为什么要加volatile？</strong></p>
<p>1、Synchronized用来加锁。volatile只能保证变量的线程可见性和有序性。通常用于一个线程写，多个线程读的情况。</p>
<p>2、不能，volatile不保证原子性。</p>
<p>3、volatile防止指令重排序。在DCL中，防止高并发情况下，指令重排造成的线程安全问题。（int i= 1；分三步1，分配内存2，对象初始化3，建立指针关系）</p>
<p><strong>三、java线程锁机制？偏向锁，轻量级锁，重量级锁？如何升级</strong></p>
<p>1、就是在对象头第一个字节后三位中记录一个<strong>锁状态</strong>。1位是否偏向，2位锁标志</p>
<p>2、java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</p>
<p><strong>四、AQS（AbstractQueuedSynchronizer）？AQS如何实现可重入锁</strong></p>
<p>1、AQS是一个java<strong>线程同步框架</strong>，是jdk中很多锁工具的核心实现框架。</p>
<p>2、维护了state信号量和一个线程组成的双向链表队列，这个线程队列用来给线程排队的。</p>
<p><strong>五、</strong>CountDownLatch（模拟高并发），CylicBarrier（满足个数才走），Semaphore（给排队的线程一个权重，交错执行）</p>
<h2 id="网络通信篇"><a href="#网络通信篇" class="headerlink" title="网络通信篇"></a>网络通信篇</h2><p><strong>一、TCP和UDP</strong></p>
<p>Transfer Control Protocol 面向连接，可靠的传输层协议</p>
<p>close_wait，time_wait 2MSL最长报文段寿命</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-6.jpg" alt></p>
<p>User Datagram Protocol 无连接，不可靠的传输层协议</p>
<p>Ø 同步：客户端在发送请求之后必须等到服务器回应之后才可以发送下一条请求。串行运行</p>
<p>Ø 异步：客户端请求之后，不必等到服务器回应之后就可以发送下一条请求。并行运行</p>
<p><strong>二、NIO、AIO</strong></p>
<p>同步非阻塞，解决了BIO中线程太多的问题，引入了Selector，不过还是要检查有没有处理完</p>
<blockquote>
<p><strong>异步是针对请求，阻塞、非阻塞是针对客户端</strong></p>
</blockquote>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-7.jpg" alt></p>
<p>AIO：后端有一个异步请求队列，服务端处理完之后放入队列，通过队列把响应推给客户端，解决了服务端一直守着线程的问题</p>
<p>然而异步通知的过程服务是没法做的，需要操作系统的支持，因为服务是不稳定的。</p>
<p><strong>三、NIO的组件</strong></p>
<p>client→<strong>Buffer→Channel→Selector</strong>→Thread</p>
<p>Channel类似于“流”。每个Channel对应一个Buffer缓冲区。Channel会注册到selector。</p>
<p>Selector会根据Channel上发生的读写事件，将请求交由某个空闲的线程处理。底层是epoll实现，有两个集合，socketchannel集合和就绪事件集合</p>
<p>buffer和channel都是<strong>全双工</strong></p>
<p><strong>四、select、poll和epoll（API）</strong></p>
<p>他们是NIO中多路复用的三种实现机制，由LinuxOS提供。</p>
<p><strong>文件描述符</strong> File Descriptor（FD）：形式上是个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开或创建一个文件时，内核就会向进程返回一个FD。</p>
<ol>
<li>Select机制：会维护一个FD的<strong>数组</strong> fd_set。将fd_set从用户空间复制到内核空间，激活socket。最大为2048</li>
<li>Poll机制：和select机制差不多，把fd_set结构进行优化换成了<strong>链表</strong>实现，FD集合的大小突破了OS的限制</li>
<li>EPoll（<strong>红黑树</strong>）：Event Poll，epoll不再扫描所有的FD，只将用户关心的FD事件放到内核的一个事件表中。减少用户空间和内核空间之间需要拷贝的数据</li>
</ol>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-8.jpg" alt></p>
<p><strong>五、http和https</strong></p>
<ol>
<li>https要<strong>ca证书</strong>，要钱</li>
<li>传输协议不同，https443端口，而http80端口</li>
<li>http的连接是简单无状态的，https的数据传输时经过证书加密的</li>
</ol>
<h2 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h2><p><strong>一、JVM内存模型</strong></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-basis-4.jpg" alt="JMM"></p>
<p><strong>二、类加载过程，双亲委派，一个对象从加载到JVM，到被GC清除经历了什么过程？</strong></p>
<p><strong>类加载过程</strong>：加载→验证→准备→解析→初始化</p>
<p>加载：把Java的字节码数据加载到JVM内存（方法区）中，并映射成JVM认可的数据结构。</p>
<p>验证：检查加载到的字节信息是否符合JVM规范。（比如.class字节码文件开头的CA FE BA BE）</p>
<p>准备：创建<strong>类或接口</strong>的静态变量，并赋初始值，<strong>半初始化</strong>状态（在堆中初始化，classpoint指向元空间的class）</p>
<p>解析：把符号引用转为直接引用（在栈里初始化指针，指向堆里面的内存）</p>
<p>初始化：执行类构造器clinit方法，静态变量赋值和静态代码块，如果类构造器方法中触发了对象初始化（init方法），会执行init方法之后回来继续执行clinit方法。</p>
<p><strong>类加载器</strong>：AppClassloader→ExtClassloader→BootStrap Classloader（在Java中不是继承关系）</p>
<p>每个类加载器对他加载过的类，都有一个缓存</p>
<p>双亲委派：<strong>向上委托查找，向下委托加载</strong></p>
<p><strong>一个对象的一生</strong>：</p>
<ol>
<li>用户创建了一个对象，JVM首先需要到方法区去找对象的类型信息。然后再创建对象。</li>
<li>JVM实例化一个对象，首先要在堆中创建一个对象。→半初始化状态</li>
<li>对象首先会分配在堆中的Eden，然后经过一次Minor GC，对象如果存活就进入S区。在后续的每次GC中如果对象一直存活，就会在S区来回拷贝，每移动一次年龄加一（4bit）。超过一定年龄后对象转入老年代。</li>
<li>当方法执行结束后，<strong>栈中指针先移除</strong></li>
<li>堆中的对象，经过Full GC，就会被标记为垃圾被GC线程清除。</li>
</ol>
<p><strong>三、确定垃圾，GC root</strong></p>
<p>引用计数：给堆内存中的每个对象记录一个引用计数。无法解决循环引用</p>
<p>可达性分析：从GC root向下一直找引用，找不到就是垃圾。</p>
<p>GC Root：Stack→JVM Stack，Native Stack，方法区→static，Class类，常量池</p>
<p><strong>四、垃圾回收算法</strong></p>
<p>MarkSweep 标记清除</p>
<p>Copying 复制</p>
<p>MarkCompact 标记压缩</p>
<p><strong>五、垃圾回收器，STW发生在哪些阶段，三色标记，如何解决错标和漏标？为什么设计这么多垃圾收集器？</strong></p>
<p>Serial 串行：只有一个线程在GC</p>
<p>Parallel 并行：多线程GC，PS+PO是JDK1.8默认的垃圾回收器</p>
<p>Concurrent Mark Sweep：将STW打散， 让一部分GC线程和用户线程并发执行。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-1.jpg" alt="CMS"></p>
<ol>
<li>初始标记：STW，只标记出GC Roots直接引用的对象。</li>
<li>并发标记：继续标记其他对象，并发执行。</li>
<li>重新标记：STW，对并发执行阶段的对象进行重新标记。</li>
<li>并发清除：并发将产生的垃圾清除。</li>
</ol>
<p>G1 Garbage First 垃圾优先</p>
<p>对堆内存不在分old和eden，而是划分为一个一个小内存块Region。每个Region可以隶属于不同的年代。</p>
<ol>
<li>初始标记：STW，标记出GC Roots直接引用的Region。</li>
<li>标记Region：通过RSet标记出初始标记的Region引用的Old区Region。</li>
<li>并发标记：跟CMS差不多，只需遍历第二步标记出的Region。</li>
<li>最终标记：STW，跟CMS差不多。</li>
<li>筛选回收：跟CMS不同，G1可以采用<strong>拷贝算法</strong>。这个阶段G1只选择垃圾较多的Region清理。</li>
</ol>
<p>CMS核心算法就是三色标记。</p>
<p>CMS通过增量标记 increment update 方式来解决漏标问题</p>
<p>G1通过SATB（Snapshot at the Beginning）将所有即将被删除的引用关系的旧引用记录下来。</p>
<p><strong>六、如何JVM调优？JVM参数，怎么查看JAVA进程的JVM参数，谈谈你了解的jvm参数。一个java程序每运行一段时间后都变得非常卡顿，如何优化？</strong></p>
<p>通过定制JVM运行参数来提高JAVA应用程度的运行。</p>
<p>JVM参数大致分为三类：</p>
<ol>
<li>标注指令：-开头，所有HotSpot都支持的指令。java -help</li>
<li>非标准指令：-X开头，跟特定的HotSpot版本对应。java -X</li>
<li>不稳定指令：-XX开头，变化大。如java -XX:+PrintCommandLineFlags：查看当前命令的不稳定指令。java -XX:+PrintFlagsInitial：查看所有不稳定指令的默认值。java -XX:+PrintFlagsFinal：查看所有不稳定指令最终生效的实际值。</li>
</ol>
<p><a href="https://arthurjq.com/2021/03/16/java/jvm-tuning/">https://arthurjq.com/2021/03/16/java/jvm-tuning/</a></p>
<h2 id="缓存篇"><a href="#缓存篇" class="headerlink" title="缓存篇"></a>缓存篇</h2><p><strong>一、为什么使用缓存</strong></p>
<p>高性能、高并发</p>
<p><strong>二、缓存击穿，缓存雪崩，缓存穿透</strong></p>
<p>并发查同一条数据，同一时间大面积失效，并发查不存在的数据</p>
<p><strong>三、如何保证redis和数据库的一致性</strong></p>
<ol>
<li>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</li>
<li>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li>
</ol>
<p>没有什么方案是完美的，先更新数据库，然后删除缓存，删除缓存时，把key放到消息队列，直到删除成功。</p>
<p><strong>四、如何设计一个分布式锁，如何对锁性能优化</strong></p>
<p>数据库利用<strong>主键冲突</strong>控制一次只有一个线程能获取锁，非阻塞（要自己写阻塞代码）、不可重入（递归不支持，要自己实现AQS）、单点、不支持失效时间（要自己写定时器）</p>
<p>zk通过Znode解决<strong>死锁</strong>问题，一旦客户端获取锁后突然挂掉，这个临时节点会自动删除，其他客户端自动获取锁。临时顺序节点解决惊群效应。</p>
<p>setNX命令，单线程处理网络请求，不需要考虑并发安全性。</p>
<p>setNX问题：</p>
<ol>
<li>早期版本<strong>没有超时参数</strong>，需要单独设置，存在死锁问题（key不会超时）</li>
<li>后期版本提供加锁和设置时间原子操作（set（NX，timeout）），但是存在任务超时，锁自动释放，导致<strong>并发问题</strong>，加锁和释放锁不是同一线程问题（假如T1获得锁要执行15s，锁失效时间为10s，在这5s内T2获得了锁，T1执行完了要把锁释放掉，结果把T2的锁释放了，解决方法可以在value中存上线程的唯一标识或者uuid，删除锁：<strong>判断线程唯一标识再删除</strong>）</li>
</ol>
<p>可重入性及<strong>锁续期</strong>没有实现，通过redisson解决（类似AQS实现（count计数），看门狗监听机制（设置一个监听器监听任务，任务没有执行完就延长过期时间））</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-9.jpg" alt></p>
<p><strong>redlock</strong>：以上的机制都只操作单节点，即使Redis通过Sentinel保证高可用，如果这个master节点由于某些发生了主从切换，那么就会出现锁丢失的情况（主从节点间是异步通信，Redis同步设置可能数据丢失）。redlock从多个节点申请锁，当一半以上节点获取成功才算成功，redisson有相应的实现</p>
<img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/redis-7.jpg" style="zoom:50%;">

<p><strong>五、redis如何配置key的过期时间？实现原理</strong></p>
<p>1、EXPIRE 。2、SETEX</p>
<p>实现原理：1、定期删除：每隔一段时间，执行一次删除过期key的操作。2、懒汉式删除：当使用get、getset等指令取获取数据时，判断key是否过期。过期后，就先把key删除，再执行后面的操作。</p>
<p>Redis是将两种方式结合使用。定期删除：平衡执行频率和执行时长。定期删除时会遍历每个database，检查当前库中指定个数的key（默认20）。随机抽查这些key，过期了就删除。程序中有一个全局变量记录扫描到哪个库</p>
<p>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间的某个键的指针，value是该键的毫秒精度的unix时间戳表示的过期时间，键空间是指向该redis集群中保存的所有键。</p>
<p><strong>六、海量数据快速查询</strong></p>
<p>1、使用布隆过滤器，快速过滤不存在的记录。使用Redis的bitmap结构来实现布隆过滤器</p>
<p>2、再Redis中建立数据存储。将对redis使用场景的理解表达出来</p>
<p>以字符串存储（userId-&gt;user.json）。以hash存储一条数据（HMSET user {userId}:name jinquan {userId}:age 24），一个hash最多能支持2^32 - 1（40多亿）个键值对</p>
<p>缓存击穿：对不存在的数据也建立key，这些key都是经过布隆过滤器过滤的，所以一般不会太多</p>
<p>缓存过期：将热点数据设置永不过期，定期重建缓存。使用分布式锁重建缓存</p>
<p>3、查询优化，按槽位分配数据 </p>
<h2 id="微服务篇"><a href="#微服务篇" class="headerlink" title="微服务篇"></a>微服务篇</h2><p><strong>一、微服务的理解，优点</strong></p>
<p>微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低整个系统的复杂度。</p>
<p>优点：</p>
<ol>
<li>服务部署更灵活：每个应用都可以是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性降低。</li>
<li>技术更新灵活：再大型单体应用中，技术要进行更新，往往是非常困难的。而微服务可以根据业务特点，灵活选择技术栈。</li>
<li>应用的性能得到提高：大型单体应用中，往往启动就是一个难关。而采用微服务后，整个系统的性能能够提高</li>
<li>更容易组合专门的团队：在单体应用时，团队成员往往需要对系统的各个部分都要深入了解，门槛高。采用微服务后可以给每个微服务建专门的团队。</li>
<li>代码复用：很多底层服务可以以REST API的方式对外提供统一的服务，所有基础服务可以在整个微服务系统中通用。</li>
</ol>
<p>缺点：</p>
<ol>
<li>服务调用的复杂性提高：网络问题，容错问题，负载问题，高并发问题等</li>
<li>分布式事务：尽量不要使用微服务事务</li>
<li>测试难度提高</li>
<li>运维难度提高：单体架构只要维护一个环境，而到了微服务是很多个环境，并且维护方式不一样，所以对部署、监控、告警等要求就会变得非常困难。</li>
</ol>
<p>去中心化，独立数据库</p>
<p>建module→改pom→写yml→主启动→业务类</p>
<p><strong>二、SpringCloud和SpringCloudAlibaba组件？都解决了什么问题</strong></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-10.jpg" alt="Netflix"></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-11.jpg" alt="Alibaba"></p>
<p>SpringCloud提供了构建微服务系统所需要的一组通用开发模式以及一系列</p>
<p>gateway：统一服务对外入口，鉴权，过滤拦截（Gateway Handler Mapping→Gateway Web Handler， http请求断言，发送代理请求前后的Filter链），webflux→Reactor模式的netty</p>
<p>hystrix：熔断：防止异常扩散，降级：断路器打开，调用失败的补救，只是服务水平下降，监控</p>
<p>Ribbon：客户端负载均衡</p>
<p>Feign/OpenFeign：RESTful的http服务客户端，定义一个服务接口添加注解</p>
<p>sleuth-zipkin：每个请求都会形成一条复杂的分布式服务调用链路，链路中任何一环出现高延时或错误都会引起整个请求最后的失败</p>
<p>nacos：集成ribbon，项目初始化时先从配置中心拉取配置</p>
<p>sentinel：@SentinelResourse，熔断，降级（异常比例或异常数），限流（QPS，线程数快速失败，预热，排队等待）组件可以单独独立出来，界面化的细粒度统一配置，信号量隔离</p>
<p>seata：</p>
<ol>
<li>事务管理器TM（事务的发起方）向事务协调者TC申请开启事务，全局事务创建成功并生成一个全局唯一XID</li>
<li>XID在多个TM和RM中传播</li>
<li>RM向TC注册分支事务（<strong>branch_id</strong>），将其纳入XID管辖</li>
<li>TM向TC发起针对XID的全局提交或回滚</li>
<li>TC协调XID下全部事务分支完成提交或回滚</li>
</ol>
<p><strong>三、分布式事务如何处理？怎么保证事务一致性</strong></p>
<p>分布式事务就是将不同节点上的事务操作，提供操作原子性保证，同时成功或者同时失败。分布式事务的第一个要点就是在原来没有直接关联的事务之间建立联系。</p>
<p>1、HTTP连接：最大努力通知。本质上通过定期校对（事后补偿），实现数据一致性</p>
<p>2、MQ：事务消息机制。</p>
<p>3、Redis：除了下图外，还有很多细节需要处理，分布式事务时长，幂等性问题</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-12.jpg" alt="Redis实现分布式事务"></p>
<p>4、Seata：通过TC在多个事务之间建立联系</p>
<p>2PC：1、准备阶段，协调者向参与者发送pre，询问参与者是否能够提交事务；参与者收到pre后进行本地事务的预处理但不提交。2、提交阶段，如果协调者收到参与者失败就rollback，所有的参与者都返回ready就都发送commit回去。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-13.jpg" alt="两阶段"></p>
<p>2PC问题：单点故障，事务管理器一旦故障参与者就被阻塞。同步阻塞，需要锁资源，所以XA和AT前提需要连接数据库来保障，数据不一致</p>
<p>3PC：把2PC的准备阶段再次拆分，第一个阶段不锁资源，引入参与者超时机制，解决了协调者故障后参与者阻塞问题。解决了单点故障问题。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-14.jpg" alt="3阶段"></p>
<ol>
<li>canCommit：协调者问参与者，是否具备执行事务的条件</li>
<li>preCommit：协调者通知参与者进行事务的预提交</li>
<li>doCommit：协调者根据preCommit参与者反馈结果通知参与者commit or rollback</li>
</ol>
<p>TCC（业务层次）：校验、资源锁定、补偿，对每个操作（Try）都提供确认（Confirm）和取消（cancel）的操作</p>
<p>TCC问题：<strong>业务服务需要提供try、confirm、cancel三种方法来支持</strong>，业务侵入性强。Confirm / Cancel要做幂等性设计</p>
<p>Sage：与TCC不同的是Saga不需要Try，而是直接进行confirm、cancel操作，适合长流程的业务。不需要锁资源。事件驱动模式，参与者可异步执行，高吞吐，成本低，但是无法保证隔离性</p>
<p>AT：无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本（sql都由框架托管统一执行，会存在脏写问题）</p>
<ol>
<li>保存before image→业务sql→保存after image→生成行锁，业务sql和undo log/redo log在同一个本地事务提交，释放本地锁和连接资源</li>
<li>提交异步，回滚通过一阶段的回滚日志反向补偿（<strong>校验脏写</strong>→还原数据），成功或回滚都要删除前后快照和行锁</li>
</ol>
<p><a href="https://arthurjq.com/2021/03/20/mq/">https://arthurjq.com/2021/03/20/mq/</a></p>
<p><strong>四、怎么拆分微服务？怎么设计出高内聚低耦合的微服务？DDD领域驱动设计？中台？中台和微服务的关系</strong></p>
<p>拆分微服务时，为了尽量保证微服务的稳定，会有一些基本的准则：1、微服务之间尽量不要有业务交叉。2、微服务之间只能通过接口进行服务调用，不能直接访问对方数据库。3、高内聚低耦合，一种从上而下指导微服务设计的方法。实现工具有 同步的接口调用 和 异步的事件驱动（如MQ）</p>
<ol>
<li>基于<strong>工作流</strong>拆分服务：服务的拆分法则，基于工作流拆分服务，确保该工作流运行在一个实例中。</li>
<li>服务器即是服务池：所有物理机应该是一个服务池，根据我们的需求，可以将它部署成任何服务。</li>
</ol>
<p>比如：用户 —&gt; 商品中心（浏览）—&gt; 搜索中心（过滤）—&gt; 用户中心（添加购物车）—&gt; 物流中心 （物流方式） —&gt; 结算中心（支付结算/扣积分）—&gt; 商品中心（扣库存）—&gt; 用户中心 （完成）</p>
<p>Domain-Driven-Design在2004年有Eric Evans提出，面向软件复杂之道</p>
<p>Maritin Fowler 贫血模型，贫血失忆症→充血模型</p>
<p>MVC架构→领域优先的四层架构</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-15.jpg" alt="充血模型"></p>
<p>大泥团：不利于微服务的拆分。大泥团结构拆分出来的微服务依然是泥团结构，当服务业务逐渐复杂，这个妮团又会膨胀成大泥团（比如下单微服务和物流微服务公用一个DB）</p>
<p>所以采用领域拆分：</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-16.jpg" alt></p>
<p>DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域跟技术、存储、通信无关。</p>
<p>中台：将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可复用的组件。大体上分为三类：业务中台（抽象出来的在各个业务线都能公用的组件，如用户的权限管理，用户支付）、数据中台（对整个系统的数据进行统一的存储建模与计算，为各个系统的分析与利用提供支持，如芝麻信用，大数据杀熟）和技术中台（封装各个系统需要的技术框架，对上层业务开发的门槛降低，提高交互的速度）。</p>
<p>中台和DDD结合：DDD会通过限界上下文将系统拆分成一个一个的领域，而这种限界上下文，天然就成为了中台的逻辑屏障。设计不再凭个人，而是整个团队的力量。DDD在技术与资源调度方面都能够给中台建设提供不错的指导。</p>
<p>DDD分为战略设计和战术设计。上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</p>
<p><strong>五、你的项目中是怎么保证微服务敏捷开发的？微服务链路追踪，持续集成，AB发布要怎么做？</strong></p>
<p>敏捷开发：目的是提高团队的交付效率，快速迭代，快速试错。</p>
<p>每个月固定发布新版本，以分支的形式保存到代码仓库中。快速入职。任务面板，站立会议。团队人员灵活流动，同时形成各个专家代表。测试环境-生产环境 →开发测试环境SIT、集成测试环境、压测环境STR、预投产环境、删除环境PRD。文档优先。晨会、周会、需求拆分会。</p>
<p>链路追踪：1、基于日志。形成全局事务ID，落地到日志文件。filebeat→logstash→elasticsearch形成大型报表。2、基于MQ，往往需要架构支持。经过<strong>流式计算</strong>形成一些可视化的结果。</p>
<p>持续集成：SpringBoot maven pom→build→shell；Jenkins。</p>
<p>AB发布：1、蓝绿发布（基于本地）、红黑发布（基于云计算）。老版本和新版本是同时存在的。2、灰度发布、金丝雀发布。邀请一部分人新版本尝试</p>
<h2 id="Spring底层篇"><a href="#Spring底层篇" class="headerlink" title="Spring底层篇"></a>Spring底层篇</h2><p><strong>一、什么是Spring，IOC和AOP</strong></p>
<p>装java bean的容器框架</p>
<p>IOC：</p>
<ol>
<li>容器：实际上就是个map存各种对象，在代码需要用到里面对象时，再通过DI注入</li>
<li>控制反转：解耦，获得依赖对象的过程由主动变为被动</li>
<li>依赖注入：实现IOC的方法，动态地注入依赖关系</li>
</ol>
<p>AOP：</p>
<p>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前或之后额外做一些事情。</p>
<p><strong>二、Spring容器启动流程</strong></p>
<ol>
<li>初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中</li>
<li>将用户配置类的BeanDefinition注册到容器中</li>
<li>调用refresh方法刷新容器</li>
</ol>
<p><strong>三、Bean的创建流程</strong></p>
<p>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</p>
<p>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</p>
<p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/java-advance-7.jpg" alt></p>
<p><strong>四、Spring中Bean是线程安全的么？如何处理</strong></p>
<p>单例无状态Bean是线程安全的，有状态的Bean通过<strong>ThreadLocal</strong>解决，因为ThreadLocal每个线程私有</p>
<p><strong>五、Spring如何处理循环依赖</strong></p>
<p>三级缓存（解决循环依赖）：</p>
<p>一级：singletonObjects map&lt;beanName，Object&gt; （单例池）</p>
<p>二级：earlySingletonObjects map&lt;beanName，Object&gt; （提前AOP）</p>
<p>三级：singletonFactories （放了个lambda）</p>
<p>earlyProxyReferences ConcurrentHashMap&lt;beanName，bean的原始对象&gt;（循环引用时记录是否提前生成了代理对象）</p>
<p>creatingSet （）</p>
<p><strong>流程</strong>：假设Aservice和Bservice互相依赖，当Aservice出现循环依赖的话会提前AOP</p>
<ol>
<li>creatingSet.add（Aservice）</li>
<li>class→实例化得到Aservice原始对象→singletonFactories map&lt;beanName，lambda（beanName，BeanDefinition，Aservice原始对象）&gt;</li>
<li>给Bservice属性赋值→从单例池找Bservice→找不到→创建Bservice的bean<ol>
<li>class→实例化得到Bservice原始对象</li>
<li>给Aservice属性赋值→从单例池找Aservice→找不到→creatingSet→Aservice出现循环→earlySingletonObjects→singletonFactories→lambda→AOP→Aservice代理对象→放入二级缓存（调用getEarlyBeanReference（）提前生成代理对象）</li>
<li>给其他属性赋值</li>
<li>其余AOP</li>
<li>将对象放入单例池</li>
</ol>
</li>
<li>给其他属性赋值</li>
<li>其余事情AOP→Aservice代理对象→postProcessAfterInitialization（）（看earlyProxyReferences有没有提前生成代理对象）</li>
<li>earlySingletonObjects.get（Aservice）</li>
<li>creatingSet.remove（Aservice）</li>
<li>将对象放入单例池</li>
</ol>
<p><strong>六、Spring如何处理事务</strong></p>
<p>编程式事务：通过编码方式实现事务，使用TransactionTemplate或PlatformTrasactionManager</p>
<p>声明式事务：注解，AOP，本质就是在目标方法执行前后进行拦截</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/spring%20transaction-9.png" alt></p>
<p><strong>七、SpringMVC中控制器如何保证线程安全</strong></p>
<p>SpringMVC中控制器默认单例，在Controller中使用ThreadLocal变量或scope=”prototype”</p>
<p>最好的方式是将控制器设计成无状态模式，在控制器中不要携带数据，但可以引用无状态的service和dao。</p>
<h2 id="Mysql篇"><a href="#Mysql篇" class="headerlink" title="Mysql篇"></a>Mysql篇</h2><p><strong>一、数据存储引擎，区别</strong></p>
<p>show ENGINES</p>
<p>MyISAM：</p>
<ol>
<li>不支持事务，但是每次查询都是<strong>原子</strong>的</li>
<li>支持表级锁</li>
<li><strong>存储表的总行数</strong></li>
<li>一个MyISAM表有三个文件：表结构文件，索引文件，数据文件</li>
<li>采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不保证唯一性</li>
</ol>
<p>InnoDB</p>
<ol>
<li>支持ACID事务，支持四种隔离级别</li>
<li>支持SAVEPOINT部分回滚</li>
<li>支持行级锁及外键约束，因此可以<strong>支持写并发</strong></li>
<li>不存储总行数，算行数要全表扫描</li>
<li>一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也可能多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G）</li>
<li>主键索引采用聚簇索引，辅索引的数据域存储主键的值；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li>
</ol>
<p><strong>二、脏读，不可重复读，幻读，如何处理</strong></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/spring%20transaction-7.png" alt></p>
<p>为了防止脏读，每次写入前，数据库都会记住旧值，当前事务尚未提交时，其他事务的读取都会拿到旧值。当前事务提交后，其他事务才能读取到新值。</p>
<p>原子写，for update锁行，CAS</p>
<p>加锁：1、脏读和不可重复读：在修改时加排他锁，直到事务提交才释放。读取时加共享锁。2、幻读：加范围锁。</p>
<p><strong>三、事务的基本特性和隔离级别</strong></p>
<p><a href="https://arthurjq.com/2020/12/25/database/isolation/">https://arthurjq.com/2020/12/25/database/isolation/</a></p>
<p><strong>四、Mysql的锁有哪些，间隙锁</strong></p>
<p>共享锁：读锁。多个事务可以对同一个数据共享一把锁。持有锁的事务都可以访问数据，但是不能修改。select xxx LOCK IN SHARE MODE</p>
<p>排他锁：写锁。只有一个事务能够获得。InnoDB会对ipdate/delete/insert语句自动添加排他锁。</p>
<p>自增锁：通常时针对mysql的自增字段。如果又事务回滚，数据回回滚，但自增序列不会回滚。</p>
<p>粒度：表锁，行锁（记录锁+间隙锁=临建锁），页锁，全局锁（Flush tables with read lock）</p>
<p>间隙锁（Gap Lock）：属于行锁的一种，是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现间隙则会形成一个区间，遵循左开右闭原则。只会出现在重复读的事务级别中。</p>
<p><strong>五、Mysql的索引结构是什么？</strong></p>
<p>B+ Tree</p>
<p><strong>六、Mysql的集群如何搭建，读写分离怎么做</strong></p>
<p>让master来响应事务性操作，让slave来响应select非事务性操作，然后再采用主从复制来把master上的事务性操作同步到slave数据库中。实现简单的负载均衡。</p>
<p>show master status查看binlog文件和Position</p>
<p>show slave status查看Slave_io_State,Master_Host,Master_Log_File,Read_Master_Log_Position等</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-2.png" alt="mysql主从复制"></p>
<p>主要由三个线程：master（binlog dump thread）、slave（I / O thread、SQL thread）</p>
<ol>
<li>主节点binlog，主从复制的基础是<strong>主库记录数据库的所有变更记录到binlog</strong>。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</li>
<li>主节点log dump线程，当binlog有变动时，lo g dump线程读取其内容并发送给从节点。</li>
<li>从节点I /O 线程接受binlog 内容，并将其写入到relay log 文件中。（relay log在从节点）</li>
<li>从节点的SQL线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库一致性。</li>
</ol>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-17.jpg" alt="半同步复制"></p>
<p><strong>七、分库分表，多大数据量需要分库分表，分库分表方式和分片策略，分库分表后sql的执行流程？</strong></p>
<p>1，阿里开发手册建议一个表的数据量超过500w或数据文件超过2G</p>
<p>分库分表最常用组件：Mycat / ShardingSphere（Sharding-JDBC）</p>
<p>垂直分库：指按照业务将表进行分类，分布到不同的数据库上面，专库专用</p>
<p>水平分库：把同一个表的数据按一定规则拆到不同的数据库中，如id%2</p>
<p>垂直分表：将一个表按照字段分成多表，每个表存储其中一部分字段</p>
<p>水平分表：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中，跟水平分库类似</p>
<p>分片策略：地理，id，用户，时间，目标字段前缀，取决于你的应用</p>
<img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-18.jpg" alt="解析流程" style="zoom:80%;">

<p>解析过程分为词法解析和语法解析。词法接卸器用于将SQL拆解为不可再分的原子符号，称为Token，并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。再使用语法解析器将SQL转换为抽象语法树（Abstract Syntax Tree）</p>
<p>例如：SELECT id,name FROM t_user WHERE status = ‘ACTIVE’ AND age &gt; 18</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-19.jpg" alt="抽象语法树"></p>
<p>关键字Token用绿色表示，变量Token用红色标识。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-20.jpg" alt="查询优化"></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-21.jpg" alt="SQL路由引擎"></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-22.jpg" alt="SQL改写"></p>
<p>将基于逻辑表的sql语句改写成真正到数据库执行的sql</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-23.jpg" alt="执行"></p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-24.jpg" alt="结果归并"></p>
<h2 id="搜索引擎篇"><a href="#搜索引擎篇" class="headerlink" title="搜索引擎篇"></a>搜索引擎篇</h2><p><strong>一、倒排索引？有什么好处</strong></p>
<p>索引：从ID到内容。倒排索引：从内容到ID。</p>
<p>记录每个词条出现在那些文档，及文档中的位置，快速定位到包含这个词条的文档和出现的位置，控制数据的总量</p>
<p>倒排本质上就是基于term的反向列表，基于FST形成一个有向无环图，FST定位到倒排链后，然后倒排链的合并</p>
<p>为了能够快速查找docid，SkipList本质上是在有序的链表上实现实现二分查找，空间换时间</p>
<p>文章→term→排序term dictionary→term index（维护了字典的前缀和偏移范围）→Posting List→[文章ID，[在文章中出现的偏移量]，权重] TFIDF</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/lucene-7.jpg" alt></p>
<p><strong>二、ES？说说你们公司的es集群架构</strong></p>
<ol>
<li>index：mysql中的table。</li>
<li>document：row。</li>
<li>字段 field text/keyword/byte ：列</li>
<li>映射 Mapping：Schema</li>
<li>查询方式 DSL：sql，新版也支持sql</li>
<li>分片sharding和副本replicas</li>
</ol>
<p>动态映射，不需要定义Mapping映射</p>
<p>ES 集群架构 3 个节点，索引根据通道不同共 10+索引，根据日期，每日递增 10+，索引：1 分片，replica默认1对1，每日递增3GB数据</p>
<p>默认混合部署，Data Node 和 Transport Node，Node中会持有一个全局的路由表，缺点就是多种类型的请求会相互影响，不能支持集群的热更新</p>
<p><strong>三、如何进行中文分词？用过哪些分词器</strong></p>
<p>ik_smart、ik_max_word</p>
<p>HanLP</p>
<p><strong>四、es写入数据的工作原理？</strong></p>
<ol>
<li>客户端通过hash选择一个node发送请求，这个node被称做coordinating node（协调节点）</li>
<li>协调节点对document进行路由，将请求转发给到对应的primary shard</li>
<li>primary shard 处理请求，将数据同步到所有的replica shard</li>
<li>此时协调节点，发现primary shard 和所有的replica shard都处理完之后，就反馈给客户端。</li>
</ol>
<p><strong>五、es查询数据的工作原理</strong></p>
<ol>
<li>客户端发送get请求到任意一个node节点，然后这个节点就称为协调节点</li>
<li>协调节点将查询请求广播到每一个数据节点，每个分片进行数据查询，将符合条件的数据放在一个<strong>队列</strong>中，并将这些数据的文档ID，节点信息，分片信息都返回给协调节点</li>
<li>由协调节点将所有的结果进行汇总并排序</li>
<li>协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回协调节点，最后协调节点将数据整合返回客户端</li>
</ol>
<p><strong>六、es部署时如何优化</strong></p>
<p>调整ES的一些重要参数，path.data目录尽量使用SSD。更合理的sharding布局。定制JVM堆内存大小</p>
<p>liunx：不要用root用户，修改虚拟内存大小，普通用户最大线程数</p>
<p>1、根据业务增量需求，采取<strong>基于日期</strong>模板<strong>创建索引</strong>，通过 roll over API 滚动索引；</p>
<p>2、使用别名进行索引管理；</p>
<p>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；</p>
<p>4、采取<strong>冷热分离</strong>机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink</p>
<p>5、采取 curator 进行索引的生命周期管理；</p>
<p>6、仅针对需要分词的字段，<strong>合理的设置分词器</strong>；</p>
<p>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p>
<h2 id="安全验证篇"><a href="#安全验证篇" class="headerlink" title="安全验证篇"></a>安全验证篇</h2><p><strong>一、什么是认证和授权？如何设计一个权限认证框架？</strong></p>
<p>认证：验证您的身份。授权发生在系统成功验证您的身份后，最终会授予您访问资源的完全权限。后台接口访问权限、前台控件的访问权限</p>
<p>RBAC（Role-Based Access Control）模型：主体→角色→资源→访问系统得到行为</p>
<p>用户←多对多→角色←多对多→权限</p>
<p><strong>二、Cookie和Session区别</strong></p>
<p>Session在服务端保存，用来跟踪用户的状态</p>
<p>Cookie客户端保存，用来记录用户的一些信息</p>
<p><strong>三、如果没有Cookie，Session还能进行身份验证么</strong></p>
<p>Cookie中存有SessionID</p>
<p><strong>四、CSRF攻击，如何防止</strong></p>
<p>Cross-site request forgery, 跨站请求伪造</p>
<ul>
<li>添加并验证 token</li>
<li>添加自定义 http 请求头</li>
<li>敏感操作<strong>添加验证码</strong></li>
</ul>
<p><strong>五、OAuth2.0协议？有几种认证方式？JWT令牌？和普通令牌的区别</strong></p>
<p>向第三方应用颁发令牌</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p>session随着认证用户的增多，服务端的开销会明显增大</p>
<p>JWT：header.payload.signature</p>
<p>头部声明类型，加密算法</p>
<p>载荷就是存放有效信息的地方</p>
<p>签证由HMACSHA256（base64UrlEncode（header） + ‘.’ + base64UrlEncode（payload）, ‘secret’）</p>
<p>secret是保存在服务器端的私钥，JWT可以跨语言支持</p>
<p>token需要查库验证token 是否有效，而JWT<strong>不用查库</strong>或者少查库，直接在服务端进行校验，并且不用查库</p>
<h2 id="self-introduction"><a href="#self-introduction" class="headerlink" title="self-introduction"></a>self-introduction</h2><p>面试官角度：最希望知道的是你能否胜任你面试的岗位工作；</p>
<p>所有你可以在介绍的时候，最好是加入你最擅长的专业技能、对哪块知识比较深的理解、你项目中曾经完成了哪个模块功能、项目中让你感觉最有收获的事。</p>
<p>STAR：Situation什么情况下，Task你要干什么，Action你采用了什么样的行动和努力，Result得到什么样的结果</p>
<p>要有细节，要有感情，要有思考，总结得失</p>
<p>项目贡献了多少代码，解决了多少问题，修复了多少bug</p>
<h3 id="范文"><a href="#范文" class="headerlink" title="范文"></a>范文</h3><p>您好，我叫吴锦泉，就读于华南理工大学，软件工程专业，曾经在广州慧扬健康参与过两个项目，分别是吴川市人民医院的互联网医院和茂名市妇幼保健院、吴川市人民医院的消毒供应室系统。使用的技术大多是SpringBoot、SpringCloud、 Netty、elasticsearch、Mysql和Redis等。</p>
<p>在互联网医院项目中用了SpringBoot，nacos服务发现治理配置中心，gateway网关服务负载均衡和服务路由，Netty，kafka，elasticsearch，redis，mysql。移动端线上问诊开药平台，类似于好大夫，核心功能是基于nettyws的im即时通讯服务的在线问诊，此外还有预约挂号，智能导诊和复诊开药功能。</p>
<p>通信流程大概是这样的：上边是客户端，下边为多个WS服务器，服务器要往nacos里边注册。</p>
<ol>
<li>客户端携带授权token（jwt请求头加token）向服务集群发起connect请求，请求会被网关转发都具体的某一个ws节点</li>
<li>ws服务针对connect进行鉴权，并且将该连接会话缓存在服务内，返回连接成功</li>
<li>客户端定时向服务端发送ws心跳，服务端返回ping报文</li>
<li>客户端需要发送消息时，通过ws发送报文。对应的ws节点收到报文信息后，直接发布到kafka的topic中</li>
<li>所有ws服务器监听消息队列topic，收到topic信息后根据busiCode类型，toUserId，groupId等寻找对应的用户id。再通过用户id获取到session，通过session进行消息推送</li>
<li>redis负责缓存用户信息和实现分布式锁，作为服务端和mysql数据库的中间件</li>
<li>elk负责持久化kafka信息，提供http get接口进行历史信息模糊查询</li>
</ol>
<p>我在项目中负责在线问诊和复诊开药流程的开发，elk的搭建和相关需求开发。</p>
<p>nacos：集成ribbon，项目初始化时先从配置中心拉取配置。</p>
<p>gateway：统一服务对外入口，鉴权，过滤拦截（Gateway Handler Mapping→Gateway Web Handler， http请求断言，发送代理请求前后的Filter链），webflux→Reactor模式的netty</p>
<h2 id="Zookeeper（CP）"><a href="#Zookeeper（CP）" class="headerlink" title="Zookeeper（CP）"></a>Zookeeper（CP）</h2><p>Znode兼具<strong>文件和目录</strong>两种特点，具有原子性操作</p>
<p>watch机制实现实时监听znode，不告知事件内容</p>
<p>ZAB：1、消息广播：第一步是广播事务操作，第二步时广播提交操作，其中过半数指的是<strong>反馈节点数 &gt;= N/2 + 1</strong>。</p>
<p>2、崩溃恢复：开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，<strong>强一致性</strong></p>
<p>Zxid，事务编号，高32位代表每代Leader的唯一性，低32位代表了每代Leader中事务的唯一性</p>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>三主三从，随机需要遍历所有redis服务器，hash取模的话如果服务器变动所有缓存都改变，不易拓展</p>
<p>使用饿汉模式进行管理。只有在读时才缓存加载，其他操作删除相关缓存。<br>缓存时间设置不宜过长，5分钟内为宜（因为现在业务没什么对数据库压力特别大）<br>不同Key的缓存失效时间尽量随机<br>考虑缓存穿透问题<br>不要使用redis事务<br>先进行数据库操作，再操作缓存<br>数据粒度要很大时，借助定时任务定期刷新内存<br>缓存中找不到时，应该去查找数据库中是否存在，记得用一定策略保证击穿问题得到解决<br>用service屏蔽缓存的直接操作，避免造成缓存管理困难（因为service的操作一定可以反映到数据库上，直接操作缓存不一定能落到数据库）</p>
<p><strong>key定义的规范</strong>，这个是用的时候比较容易出错的，重名，和系统关键字冲突，长度等，都需要给出规范来</p>
<p>value上，应该<strong>控制数据的长度</strong>，比如防止一些大数据类型，redis本来是提速的，不要因为数据长度影响了自身性能，另外就是合理的使用数据类型，节省存储提升性能，比如能整型的就不要字符串型</p>
<p>一致性hash，对2的32方取模，服务器iphash，keyHash后沿环顺时针查找直到遇到服务器，容错性和可拓展性高（只需重定位环空间中的一小部分数据），数据倾斜问题用虚拟节点解决。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol>
<li>从节点执行slaveof masterIp port保存主节点信息</li>
<li>从节点中的定时任务发现主节点信息，建立和主节点socket连接</li>
<li>建立连接后，主节点将所有数据发送给从节点</li>
<li>完成数据同步后，主节点就会持续的把写命令发送给从节点，保证主从数据一致</li>
</ol>
<p>runId：每个redis节点启动都会生成唯一的uuid</p>
<p>offset：主从节点各自维护自己的偏移量</p>
<p>repl_backlog_size：保存在主节点的一个固定长度的FIFO队列，默认1MB</p>
<p><strong>全量复制</strong></p>
<ol>
<li>从节点发送psync命令，psync runid offset（第一次runid为？，offset为-1）</li>
<li>主节点返回 FULLRESYNC runid offset</li>
<li>主节点启动bgsave命令fork子进程进行RDB持久化</li>
<li>主节点将RDB文件发送给从节点，到从节点加载数据完成之前，写命令写入缓存区</li>
<li>从节点清理本地数据并加载RDB，如果开启AOF会重新AOF</li>
</ol>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/redis-2.jpg" alt></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-3.jpg" alt></p>
<ol>
<li>Netty抽象出两组线程池BossGroup专门负责接收客户端连接，WorkerGroup专门负责网络的读写</li>
<li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li>
<li>NidEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是NioEventLoop</li>
<li>NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector用于监听绑定在其上的socket的网络通讯</li>
<li>每个BossEventLoopGroup的NioEventLoop循环执行：<ol>
<li>轮询accept事件</li>
<li>处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker的NioEventLoop上的selector</li>
<li>处理taskQueue的任务，即 runAllTasks</li>
</ol>
</li>
<li>每个Worker-NioEventLoop 循环执行：<ol>
<li>轮询 read、write 事件</li>
<li>处理异步 i / o事件（ChannelFuture接口实现异步），即read，write 事件，在对应的NioSocketChannel处理（每个NioSocketChannel都绑定一个自己的全新的ChannelPipeline）</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ol>
</li>
<li>每个Worker的NioEventLoop 处理业务时，会使用pipeline，pipeline中包含了 channel，即通过pipeline可以获得对应通道，管道中维护了很多 handler。</li>
</ol>
<p>NioEventLoop内部串行化，消息在多个handler中读取→解码→处理→编码→发送</p>
<p>ChannelInboundHandler / ChannelOutboundHandler 入站（server→client） / 出站io</p>
<p>ChannelPipeline是一个ChannelHandler集合链，负责处理和拦截inbound或者outbound事件和操作</p>
<p>ChannelHandlerContext：上下文对象，含具体的事件管理器ChannelHandler，含pipeline，channel，地址</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-4.jpg" alt></p>
<p>每添加一个handler都会创建一个关联的Context，调用addLast方法将Context追加到链表</p>
<p>tail是inbound类型的handler，head既是inbound又是outbound类型的handler。</p>
<p><img src="https://gitee.com/arthurjq/blogimage/raw/master/img/pic/interview-5.jpg" alt></p>
<ol>
<li>pipeline首先调用ctx的pipeline的静态方法fireXXX（如fireChannelRead），并传入head</li>
<li>静态方法调用ctx的invoke方法，invoke方法内部调用该ctx所包含的Handler的真正方法，调用结束传递给下一个ctx</li>
</ol>
<p><a href="https://arthurjq.com/2021/01/21/project/netty-pipeline/">https://arthurjq.com/2021/01/21/project/netty-pipeline/</a></p>
<blockquote>
<p>http+json      tcp+protobuf</p>
</blockquote>
<h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><p>调整堆内存最少2g -Xms2g -Xmx2g</p>
<p>通过ElasticsearchRepository接口自定义基本查询</p>
<p>模糊查询：restHighLevelClient→boolQueryBuilder.filter（queryBuilder.multiMatchQuery（id，fromUserId，toUserId））→boolQueryBuilder.must（queryBuilder.matchQuery（key，content））</p>
<h3 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h3><ol>
<li>禁用 wildcard</li>
<li>禁用批量 terms</li>
<li>充分利用倒排索引机制，能 keyword 类型尽量 keyword</li>
<li>数据量大时候，可以先基于时间敲定索引再检索</li>
<li>设置合理的路由机制</li>
</ol>
<h3 id="es写入和查询慢"><a href="#es写入和查询慢" class="headerlink" title="es写入和查询慢"></a>es写入和查询慢</h3><p>先查看监控、硬件资源以及es中各种线程池的状况</p>
<h3 id="kafka作用"><a href="#kafka作用" class="headerlink" title="kafka作用"></a>kafka作用</h3><p>即使WS server因故障停止运行，数据会先被存储下来，从而避免数据丢失</p>
<h2 id="ssd定时任务"><a href="#ssd定时任务" class="headerlink" title="ssd定时任务"></a>ssd定时任务</h2><p>@Scheduled（cron = “0 0 0 <em> </em> ?”）</p>
<p>没有开关，项目启动总会启动一个线程</p>
<p>使用Java的timer，这个设置开关即可自由的控制，关闭的时候，不会启动线程；</p>
<p>Java的timer也需要找到一个启动类，可以放到main函数里面启动，这样的话，代码的耦合性太高了，而使用PostConstruct是很干净的。</p>
<p><a href="https://arthurjq.com/2020/12/28/web/servlet/">https://arthurjq.com/2020/12/28/web/servlet/</a></p>
<h2 id="尖锐的问题"><a href="#尖锐的问题" class="headerlink" title="尖锐的问题"></a>尖锐的问题</h2><h3 id="答不出来的问题"><a href="#答不出来的问题" class="headerlink" title="答不出来的问题"></a>答不出来的问题</h3><p>不要放弃，让面试官看到你的思考，如果不懂可以追问，但回去要努力补课</p>
<h3 id="你有什么缺点"><a href="#你有什么缺点" class="headerlink" title="你有什么缺点"></a>你有什么缺点</h3><p>表达能力需提高，直，学技术喜欢深挖，可能会对别人不好</p>
<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>我想解决问题，想成为技术专家，成为团队里的核心，学习基础知识，做项目，向大佬学习，跟leader学习，让他帮助我成长</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《面试》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/03/09/interview/" property="cc:attributionName"
               rel="cc:attributionURL">
                锦泉
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'arthurjinquan.github.io',
        owner: 'arthurjinquan',
        admin: "arthurjinquan",
        id: '2021/03/09/interview/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/03/09/java/daemon-thread/">
                    <div class="card-image">
                        
                        
                        <img src="https://gitee.com/arthurjq/blogimage/raw/master/img/feature/77.jpg" class="responsive-img" alt="Java的守护线程">
                        
                        <span class="card-title">Java的守护线程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java中有两类线程：User Thread（用户线程）、Daemon Thread（守护线程）
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category" target="_blank">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/" target="_blank">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                    <a href="/tags/thread/" target="_blank">
                        <span class="chip bg-color">thread</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/08/java-basis/">
                    <div class="card-image">
                        
                        
                        <img src="https://gitee.com/arthurjq/blogimage/raw/master/img/feature/23.jpg" class="responsive-img" alt="Java基础">
                        
                        <span class="card-title">Java基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java基础面试总结
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category" target="_blank">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/" target="_blank">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 锦泉^-^<br />'
            + '作者: 锦泉<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2021 JinQuan. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">226.6k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:793787018@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=793787018&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的qq" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 08, 00, 00, 00); //北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->



    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    
	
	
	<!-- 背景雪花飘落特效 -->
	
		
	<!-- 背景静止彩带  -->
	
    
	<!-- 背景动态彩带 -->
	
            <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 992) {
                document.write('<script type="text/javascript" src="/libs/background/ribbon-dynamic.js"><\/script>');
            }
            </script>
        	
        

	
	<!-- 背景樱花飘落特效 -->
	
    
	
	<script src="/js/cursor.js"></script>

</body>

</html>